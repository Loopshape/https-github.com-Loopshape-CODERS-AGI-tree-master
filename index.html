<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nemodian 2244-1 :: Quantum Fractal AI Editor</title>
    <style>
        :root {
            --muted: #888;
            --info: #2196F3;
            --warn: #FF9800;
            --error: #F44336;
            --success: #4CAF50;
            --baseline: 1.5em;
            --header-h: calc(var(--baseline) * 1.6);
            --status-h: var(--baseline);
            --footer-h: calc(var(--baseline) * 2);
            --font-size: 13px;
            --ln-width: 50px;
            --theme-bg: #3a3c31;
            --panel: #313328;
            --header-bg: #2e3026;
            --status-bg: #22241e;
            --accent: #4ac94a;
            --muted-text: #999966;
            --err: #a03333;
            --warn-bg: #f0ad4e;
            --hover-blue: #3366a0;
            --info-bg: #5bc0de;
            --agent-nexus: #BB86FC;
            --agent-cognito: #03DAC6;
            --agent-relay: #FFD54F;
            --agent-sentinel: #CF6679;
            --agent-echo: #4ac94a;
            --quantum-glow: rgba(187, 134, 252, 0.6);
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Fira Code', monospace;
            font-size: var(--font-size);
            line-height: var(--baseline);
            background: var(--theme-bg);
            color: #f0f0e0;
            overflow: hidden;
        }

        body {
            display: grid;
            grid-template-rows: var(--header-h) var(--status-h) 1fr var(--footer-h);
        }

        header {
            grid-row: 1;
            grid-column: 1 / -1;
            background: var(--header-bg);
            border-bottom: 1px solid #22241e;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 12px;
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, var(--quantum-glow), transparent);
            animation: quantumScan 3s infinite linear;
        }

        @keyframes quantumScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .quantum-pulse {
            animation: quantumPulse 2s infinite alternate;
        }

        .typing-active {
            caret-color: lime;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { background-color: transparent; }
            51%, 100% { background-color: rgba(0,255,0,0.05); }
        }

        @keyframes quantumPulse {
            0% { opacity: 0.7; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.05); }
        }

        header .left {
            display: flex;
            gap: 12px;
            align-items: center;
            position: relative;
            z-index: 2;
        }

        header .right {
            display: flex;
            gap: 8px;
            align-items: center;
            position: relative;
            z-index: 2;
        }

        button {
            background: var(--err);
            border: 1px solid var(--err);
            color: #f0f0e0;
            padding: 6px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all .2s;
            border-radius: 3px;
        }

        button:hover {
            background: var(--hover-blue);
            border-color: var(--hover-blue);
        }

        button.success {
            background: var(--accent);
            border-color: var(--accent);
        }

        button.info {
            background: var(--info-bg);
            border-color: var(--info-bg);
        }

        button.warn {
            background: var(--warn-bg);
            border-color: var(--warn-bg);
            color: #3a3c31;
        }

        #status-bar {
            grid-row: 2;
            grid-column: 1 / -1;
            background: var(--status-bg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 12px;
            font-size: 12px;
            position: relative;
        }

        .quantum-threads {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.3;
        }

        .quantum-thread {
            position: absolute;
            width: 1px;
            height: 100%;
            background: linear-gradient(to bottom, transparent, var(--agent-nexus), transparent);
            animation: threadFlow 2s infinite linear;
        }

        @keyframes threadFlow {
            0% { top: -100%; }
            100% { top: 100%; }
        }

        #editor-stage {
            grid-row: 3;
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: 0px 1fr;
            background: var(--theme-bg);
            overflow: hidden;
            position: relative;
            transition: grid-template-columns 0.3s ease;
        }

        #editor-stage.left-panel-open {
            grid-template-columns: 240px 1fr;
        }

        #left-panel {
            background: var(--panel);
            border-right: 1px solid #22241e;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow: hidden;
            width: 240px;
        }

        .editor-container {
            position: relative;
            display: flex;
            flex: 1;
            background: var(--theme-bg);
            overflow: auto;
        }

        .line-numbers {
            width: var(--ln-width);
            padding: 10px 8px;
            background: var(--panel);
            color: var(--muted-text);
            font-variant-numeric: tabular-nums;
            text-align: right;
            user-select: none;
            line-height: var(--baseline);
            font-family: inherit;
            font-size: inherit;
            flex-shrink: 0;
            position: sticky;
            left: 0;
            z-index: 10;
        }

        .editor-content {
            flex: 1;
            position: relative;
            min-height: 100%;
            padding: 10px;
            padding-left: 12px;
            box-sizing: border-box;
            white-space: pre;
            line-height: var(--baseline);
            font-family: inherit;
            font-size: inherit;
            tab-size: 4;
            -moz-tab-size: 4;
            caret-color: var(--accent);
            outline: none;
            overflow-wrap: normal;
            word-break: normal;
            overflow: auto;
        }

        .editor-content:focus {
            outline: none;
        }

        footer {
            grid-row: 4;
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 12px;
            background: var(--header-bg);
            border-top: 1px solid #22241e;
            position: sticky;
            bottom: 0;
        }

        #prompt-input {
            flex: 1;
            margin-right: 8px;
            padding: 8px;
            background: var(--status-bg);
            border: 1px solid var(--accent);
            color: #f0f0e0;
            font-family: inherit;
            border-radius: 3px;
            font-size: 16px;
        }

        .small {
            font-size: 12px;
            padding: 6px 8px;
        }

        .agent-card {
            background: var(--panel);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border-left: 4px solid var(--muted-text);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .agent-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s ease;
        }

        .agent-card.active::before {
            left: 100%;
        }

        .agent-card.active {
            box-shadow: 0 0 20px var(--quantum-glow);
            transform: translateY(-2px);
        }

        .agent-card.nexus { border-left-color: var(--agent-nexus); }
        .agent-card.cognito { border-left-color: var(--agent-cognito); }
        .agent-card.relay { border-left-color: var(--agent-relay); }
        .agent-card.sentinel { border-left-color: var(--agent-sentinel); }
        .agent-card.echo { border-left-color: var(--agent-echo); }

        .agent-title {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .agent-nexus .agent-title { color: var(--agent-nexus); }
        .agent-cognito .agent-title { color: var(--agent-cognito); }
        .agent-relay .agent-title { color: var(--agent-relay); }
        .agent-sentinel .agent-title { color: var(--agent-sentinel); }
        .agent-echo .agent-title { color: var(--agent-echo); }

        .agent-subtitle {
            font-size: 11px;
            color: var(--muted-text);
            margin-bottom: 6px;
        }

        .agent-content {
            font-size: 12px;
            line-height: 1.4;
            min-height: 20px;
        }

        .quantum-spinner {
            width: 16px;
            height: 16px;
            display: inline-block;
            margin-right: 6px;
            position: relative;
        }

        .quantum-spinner::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid transparent;
            border-top: 2px solid var(--agent-cognito);
            border-radius: 50%;
            animation: quantumSpin 1s linear infinite;
        }

        .quantum-spinner::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid transparent;
            border-bottom: 2px solid var(--agent-nexus);
            border-radius: 50%;
            animation: quantumSpin 0.5s linear infinite;
        }

        @keyframes quantumSpin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .quantum-packet {
            position: fixed;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--agent-nexus);
            box-shadow: 0 0 10px var(--agent-nexus);
            opacity: 0;
            z-index: 100;
            pointer-events: none;
        }

        .quantum-trail {
            position: absolute;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--agent-nexus), transparent);
            opacity: 0;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--muted-text);
        }

        .action-buttons button {
            flex: 1;
            padding: 6px;
            font-size: 11px;
        }

        .quantum-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            margin-top: 5px;
        }

        .quantum-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--muted-text);
            position: relative;
        }

        .quantum-dot::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 50%;
            border: 1px solid var(--agent-nexus);
            animation: quantumPulseDot 2s infinite;
        }

        .quantum-dot.connected {
            background: var(--accent);
        }

        @keyframes quantumPulseDot {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }

        /* ========== SYNTAX HIGHLIGHTING STYLES ========== */
        .sh-token { transition: opacity 0.08s ease; pointer-events: none; }
        .sh-comment { color: #64748b; font-style: italic; opacity: 0.8; }
        .sh-string { color: #a3e635; font-weight: 500; }
        .sh-number { color: #f59e0b; font-weight: 600; }
        .sh-keyword { color: #f472b6; font-weight: 600; }
        .sh-type { color: #7dd3fc; font-weight: 500; }
        .sh-bracket { color: #c084fc; font-weight: 700; }
        .sh-id { color: #94a3b8; }
        .sh-op { color: #94a3b8; font-weight: 500; }
        .sh-ws { opacity: 0.3; }
        .sh-key { color: #7dd3fc; font-weight: 500; }
        .sh-number2 { color: #f59e0b; font-weight: 600; }
        .sh-text { color: #e2e8f0; }
        .sh-unknown { color: #f87171; }
        .sh-tag { color: #f472b6; font-weight: 600; }
        .sh-property { color: #7dd3fc; font-weight: 500; }
        .sh-function { color: #4ac94a; font-weight: 500; }
        .sh-operator { color: #93c5fd; font-weight: 600; }
        .sh-regex { color: #fbbf24; }
        .sh-html-entity { color: #f59e0b; }
        .sh-css-selector { color: #c084fc; }
        .sh-css-property { color: #60a5fa; }
        .sh-css-value { color: #34d399; }
        .sh-jsx-tag { color: #f472b6; }
        .sh-jsx-attribute { color: #7dd3fc; }
        .sh-template-string { color: #a3e635; font-weight: 500; }

        .editor-content::selection {
            background: rgba(74, 201, 74, 0.3);
        }

        .editor-container::-webkit-scrollbar {
            width: 12px;
        }

        .editor-container::-webkit-scrollbar-track {
            background: var(--panel);
        }

        .editor-container::-webkit-scrollbar-thumb {
            background: var(--muted-text);
            border-radius: 6px;
        }

        .editor-container::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        #preview-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            background: white;
            border: 2px solid var(--accent);
            border-radius: 5px;
            z-index: 1000;
            display: none;
            flex-direction: column;
            box-shadow: 0 0 30px rgba(0,0,0,.7);
        }

        #preview-header {
            background: var(--header-bg);
            color: #f0f0e0;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--accent);
        }

        #preview-content {
            width: 100%;
            height: calc(100% - 40px);
            border: none;
            background: white;
        }

        #close-preview {
            background: transparent;
            border: none;
            color: #f0f0e0;
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #ai-response-panel {
            position: fixed;
            bottom: 60px;
            right: 20px;
            width: 500px;
            max-height: 600px;
            background: var(--panel);
            border: 1px solid var(--accent);
            border-radius: 5px;
            padding: 15px;
            overflow-y: auto;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,.3);
        }

        #ai-response-content {
            font-size: 12px;
            line-height: 1.4;
        }

        #close-ai-panel {
            position: absolute;
            top: 5px;
            right: 5px;
            background: transparent;
            border: none;
            color: var(--muted-text);
            font-size: 14px;
            cursor: pointer;
        }

        #file-input {
            display: none;
        }

        .ai-status {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .ai-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent);
            animation: none;
        }

        .ai-dot.probing {
            background: var(--err);
            animation: pulse 2s infinite;
        }

        .ai-dot.connected {
            background: var(--accent);
            animation: none;
        }

        .quantum-thinking {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .fractal-node {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: var(--agent-cognito);
            animation: fractalPulse 1.5s infinite alternate;
        }

        @keyframes fractalPulse {
            0% { transform: scale(1); opacity: 0.3; }
            100% { transform: scale(1.5); opacity: 0.8; }
        }

        @media (max-width: 768px) {
            #editor-stage {
                grid-template-columns: 1fr !important;
            }

            #left-panel {
                position: absolute;
                height: 100%;
                z-index: 30;
                transform: translateX(-240px);
            }

            #left-panel.open {
                transform: translateX(0);
            }

            #ai-response-panel {
                width: calc(100% - 40px);
                right: 20px;
                left: 20px;
            }

            #preview-panel {
                width: 95%;
                height: 85%;
            }

            body {
                grid-template-rows: var(--header-h) var(--status-h) 1fr auto;
            }

            footer {
                position: relative;
            }
        }

        .consensus-panel {
            background: var(--panel);
            border: 1px solid var(--agent-nexus);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .consensus-header {
            font-weight: bold;
            color: var(--agent-nexus);
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .candidate-item {
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 8px;
            border-left: 3px solid var(--agent-cognito);
        }

        .candidate-meta {
            font-size: 10px;
            color: var(--muted-text);
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .candidate-content {
            font-size: 11px;
            font-family: 'Fira Code', monospace;
            white-space: pre-wrap;
            max-height: 80px;
            overflow: hidden;
        }

        .entropy-badge {
            background: var(--agent-nexus);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
        }

        .selected-candidate {
            border-left-color: var(--accent);
            background: rgba(74, 201, 74, 0.1);
        }

        .orchestration-log {
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            padding: 8px;
            margin-top: 10px;
            max-height: 120px;
            overflow-y: auto;
            font-size: 10px;
            font-family: 'Fira Code', monospace;
        }

        .orchestration-log .log-entry {
            margin-bottom: 4px;
            padding-left: 10px;
            border-left: 2px solid var(--agent-nexus);
        }

        .orchestration-log .log-entry.genesis {
            border-left-color: var(--agent-nexus);
            color: var(--agent-nexus);
        }

        .orchestration-log .log-entry.origin {
            border-left-color: var(--agent-cognito);
            color: var(--agent-cognito);
        }

        .orchestration-log .log-entry.event {
            border-left-color: var(--agent-relay);
            color: var(--agent-relay);
        }

        .orchestration-log .log-entry.fragment {
            border-left-color: var(--agent-sentinel);
            color: var(--agent-sentinel);
        }

        .orchestration-log .log-entry.consensus {
            border-left-color: var(--agent-echo);
            color: var(--agent-echo);
        }

        .memory-status {
            font-size: 10px;
            color: var(--muted-text);
            padding: 2px 6px;
            border-radius: 3px;
            background: rgba(0,0,0,0.3);
        }

        .memory-status.low {
            color: #f87171;
            background: rgba(248, 113, 113, 0.1);
        }

        .memory-status.warning {
            color: #f59e0b;
            background: rgba(245, 158, 11, 0.1);
        }

        .memory-status.good {
            color: #4ac94a;
        }

        .suggestion-item {
            padding: 8px;
            border-bottom: 1px solid var(--muted-text);
            cursor: pointer;
            transition: background 0.2s;
        }

        .suggestion-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        #suggestions-panel {
            position: absolute;
            background: var(--panel);
            border: 1px solid var(--accent);
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
<header>
    <div class="left">
        <button id="left-toggle" class="small">☰</button>
        <div style="font-weight:800;" class="quantum-pulse">Nemodian 2244-1 :: Quantum Fractal AI</div>
    </div>
    <div class="right">
        <div class="ai-status">
            <div id="ai-dot" class="ai-dot connected"></div>
            <div id="ai-indicator" style="font-size:12px;color:#cfcfbd;">Quantum AI: Ready</div>
        </div>
        <button id="open-file" class="small">Open</button>
        <button id="save-file" class="small">Save</button>
        <button id="save-as" class="small">Save As</button>
        <button id="render-html" class="small warn">Render HTML</button>
        <button id="run-local-ai" class="small info">Quantum AI</button>
        <button id="run-orchestrator" class="small success">Orchestrator</button>
    </div>
</header>
<div id="status-bar" class="info">
    <div class="quantum-threads" id="quantum-threads"></div>
    <div id="file-meta">No File Loaded</div>
    <div id="editor-meta">Cursor: 0:0 | Lines: 0 | Chars: 0 | History: 0</div>
    <div id="memory-status" class="memory-status good">RAM: OK</div>
</div>
<div id="editor-stage">
    <aside id="left-panel" class="closed">
        <button id="btn-undo" class="small">UNDO</button>
        <button id="btn-redo" class="small">REDO</button>
        <button id="btn-beautify" class="small">Beautify</button>
        <button id="btn-render" class="small warn">Render HTML</button>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Quantum AI Commands:</strong></p>
            <ul style="padding-left: 15px;">
                <li>Rewrite this function</li>
                <li>Optimize performance</li>
                <li>Add error handling</li>
                <li>Convert to TypeScript</li>
                <li>Explain this code</li>
            </ul>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Quantum Actions:</strong></p>
            <button id="btn-optimize" class="small" style="width:100%;margin-bottom:5px;">Quantum Optimize</button>
            <button id="btn-document" class="small" style="width:100%;margin-bottom:5px;">Fractal Document</button>
            <button id="btn-refactor" class="small" style="width:100%;">Hyper Refactor</button>
            <button id="btn-orchestrate" class="small success" style="width:100%;margin-top:5px;">Multi-Agent Consensus</button>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Memory Management:</strong></p>
            <button id="btn-clear-cache" class="small" style="width:100%;margin-bottom:5px;">Clear Cache</button>
            <button id="btn-optimize-memory" class="small info" style="width:100%;margin-bottom:5px;">Optimize Memory</button>
            <button id="btn-export-session" class="small" style="width:100%;">Export Session</button>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Quantum Settings:</strong></p>
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                <input type="checkbox" id="quantum-mode" checked>
                <label for="quantum-mode">Quantum Fractal Mode</label>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
                <input type="checkbox" id="hyperthreading" checked>
                <label for="hyperthreading">Hyperthreading</label>
            </div>
            <div style="display: flex; align-items: center; gap: 8px; margin-top: 5px;">
                <input type="checkbox" id="multi-agent-mode" checked>
                <label for="multi-agent-mode">Multi-Agent Consensus</label>
            </div>
            <div style="display: flex; align-items: center; gap: 8px; margin-top: 5px;">
                <input type="checkbox" id="auto-save" checked>
                <label for="auto-save">Auto Save</label>
            </div>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Orchestrator Settings:</strong></p>
            <div style="margin-bottom: 5px;">
                <label for="agent-count">Agent Count:</label>
                <input type="number" id="agent-count" min="2" max="8" value="5" style="width: 60px; background: var(--status-bg); color: white; border: 1px solid var(--muted-text); padding: 2px; border-radius: 3px;">
            </div>
            <div style="margin-bottom: 5px;">
                <label for="max-rounds">Max Rounds:</label>
                <input type="number" id="max-rounds" min="1" max="10" value="3" style="width: 60px; background: var(--status-bg); color: white; border: 1px solid var(--muted-text); padding: 2px; border-radius: 3px;">
            </div>
            <div style="margin-bottom: 5px;">
                <label for="reasoning-depth">Reasoning Depth:</label>
                <input type="number" id="reasoning-depth" min="1" max="5" value="3" style="width: 60px; background: var(--status-bg); color: white; border: 1px solid var(--muted-text); padding: 2px; border-radius: 3px;">
            </div>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Recent Files:</strong></p>
            <div id="recent-files" style="max-height: 100px; overflow-y: auto;">
                <!-- Recent files will be populated here -->
            </div>
        </div>
    </aside>

    <!-- Quantum Editor Container -->
    <div class="editor-container">
        <div class="quantum-thinking" id="quantum-thinking"></div>
        <div class="line-numbers" id="line-numbers"></div>
        <div
            class="editor-content"
            id="editor"
            contenteditable="true"
            spellcheck="false"
            data-gramm="false"
            data-gramm_editor="false"
            data-enable-grammarly="false"
        >// Quantum Fractal AI Editor - Ready
// Start coding or use the prompt below for AI assistance

function welcome() {
    return "Welcome to the Quantum Fractal AI Editor!";
}</div>
    </div>
</div>
<footer>
    <input id="prompt-input" placeholder="Enter quantum command (e.g., 'create a function to sort arrays')">
    <button id="send-button" class="success">QUANTUM PROCESS</button>
</footer>

<!-- Hidden elements -->
<input type="file" id="file-input" accept=".js,.html,.css,.txt,.json,.ts,.jsx,.tsx,.py,.php,.sql,.md,.xml,.yaml,.yml">
<div id="suggestions-panel"></div>

<!-- Panels -->
<div id="preview-panel">
    <div id="preview-header">
        <span>Quantum Preview</span>
        <button id="close-preview">×</button>
    </div>
    <iframe id="preview-content"></iframe>
</div>

<div id="ai-response-panel">
    <button id="close-ai-panel">×</button>
    <div id="ai-response-content">
        <div class="agent-card nexus agent-nexus">
            <div class="agent-title">Nexus</div>
            <div class="agent-subtitle">Quantum Orchestrator (Fractal Core)</div>
            <div class="agent-content">Idle. Awaiting quantum command.</div>
            <div class="orchestration-log" id="nexus-log"></div>
            <div class="quantum-status">
                <div class="quantum-dot connected"></div>
                <span>Quantum State: Entangled</span>
            </div>
        </div>
        <div class="agent-card cognito agent-cognito">
            <div class="agent-title">Cognito</div>
            <div class="agent-subtitle">Fractal Analyzer (Quantum Loop)</div>
            <div class="agent-content">Ready</div>
            <div class="orchestration-log" id="cognito-log"></div>
        </div>
        <div class="agent-card relay agent-relay">
            <div class="agent-title">Relay</div>
            <div class="agent-subtitle">Quantum Communicator (2244)</div>
            <div class="agent-content">Ready</div>
            <div class="orchestration-log" id="relay-log"></div>
        </div>
        <div class="agent-card sentinel agent-sentinel">
            <div class="agent-title">Sentinel</div>
            <div class="agent-subtitle">Quantum Monitor (Fractal Coin)</div>
            <div class="agent-content">Ready</div>
            <div class="orchestration-log" id="sentinel-log"></div>
        </div>
        <div class="agent-card echo agent-echo">
            <div class="agent-title">Echo</div>
            <div class="agent-subtitle">Quantum Reporter (Fractal Code)</div>
            <div class="agent-content">Awaiting quantum report...</div>
            <div class="orchestration-log" id="echo-log"></div>
        </div>
        <div class="consensus-panel" id="consensus-panel" style="display: none;">
            <div class="consensus-header">
                <span>Multi-Agent Consensus Results</span>
                <span class="entropy-badge" id="consensus-score">Score: 0</span>
            </div>
            <div id="candidates-list"></div>
        </div>
    </div>
</div>

<!-- GSAP for animations -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

<script>
    /* =========================================================================
       QUANTUM FRACTAL AI EDITOR - FULL FUNCTIONALITY
       ========================================================================== */

    // Global state
    window.quantumState = {
        isGenerating: false,
        isSpeaking: false,
        currentSession: null,
        recentFiles: [],
        settings: {
            quantumMode: true,
            hyperthreading: true,
            multiAgentMode: true,
            autoSave: true,
            agentCount: 5,
            maxRounds: 3,
            reasoningDepth: 3
        }
    };

    /* =========================================================================
       MEMORY MANAGER - Enhanced with Full Features
       ========================================================================== */

    class QuantumMemoryManager {
        constructor() {
            this.storageKey = 'quantum_editor_cache';
            this.settingsKey = 'quantum_editor_settings';
            this.recentFilesKey = 'quantum_recent_files';
            this.maxMemoryThreshold = 50 * 1024 * 1024;
            this.cacheLimit = 100;
            this.memoryStatus = document.getElementById('memory-status');
            this.cleanupInterval = null;
            
            this.init();
        }

        init() {
            this.loadSettings();
            this.loadRecentFiles();
            this.startMemoryMonitoring();
            this.cleanupOldCache();
        }

        startMemoryMonitoring() {
            this.cleanupInterval = setInterval(() => {
                this.checkMemoryUsage();
            }, 30000);

            window.addEventListener('beforeunload', () => this.cleanup());
        }

        async checkMemoryUsage() {
            try {
                if ('memory' in performance) {
                    const memory = performance.memory;
                    const used = memory.usedJSHeapSize;
                    const limit = memory.jsHeapSizeLimit;
                    
                    const usagePercent = (used / limit) * 100;
                    
                    if (usagePercent > 80) {
                        this.memoryStatus.textContent = 'RAM: CRITICAL';
                        this.memoryStatus.className = 'memory-status low';
                        this.emergencyCleanup();
                    } else if (usagePercent > 60) {
                        this.memoryStatus.textContent = 'RAM: WARNING';
                        this.memoryStatus.className = 'memory-status warning';
                        this.aggressiveCleanup();
                    } else {
                        this.memoryStatus.textContent = 'RAM: OK';
                        this.memoryStatus.className = 'memory-status good';
                    }
                }
            } catch (error) {
                console.warn('Memory monitoring unavailable:', error);
            }
        }

        // Settings management
        loadSettings() {
            try {
                const stored = localStorage.getItem(this.settingsKey);
                if (stored) {
                    const settings = JSON.parse(stored);
                    window.quantumState.settings = { ...window.quantumState.settings, ...settings };
                    this.applySettings();
                }
            } catch (error) {
                console.warn('Settings load failed:', error);
            }
        }

        saveSettings() {
            try {
                localStorage.setItem(this.settingsKey, JSON.stringify(window.quantumState.settings));
            } catch (error) {
                console.warn('Settings save failed:', error);
            }
        }

        applySettings() {
            const settings = window.quantumState.settings;
            document.getElementById('quantum-mode').checked = settings.quantumMode;
            document.getElementById('hyperthreading').checked = settings.hyperthreading;
            document.getElementById('multi-agent-mode').checked = settings.multiAgentMode;
            document.getElementById('auto-save').checked = settings.autoSave;
            document.getElementById('agent-count').value = settings.agentCount;
            document.getElementById('max-rounds').value = settings.maxRounds;
            document.getElementById('reasoning-depth').value = settings.reasoningDepth;
        }

        // Recent files management
        loadRecentFiles() {
            try {
                const stored = localStorage.getItem(this.recentFilesKey);
                if (stored) {
                    window.quantumState.recentFiles = JSON.parse(stored);
                    this.updateRecentFilesUI();
                }
            } catch (error) {
                console.warn('Recent files load failed:', error);
            }
        }

        saveRecentFiles() {
            try {
                localStorage.setItem(this.recentFilesKey, JSON.stringify(window.quantumState.recentFiles));
            } catch (error) {
                console.warn('Recent files save failed:', error);
            }
        }

        addRecentFile(filename, content) {
            // Remove if already exists
            window.quantumState.recentFiles = window.quantumState.recentFiles.filter(f => f.filename !== filename);
            
            // Add to beginning
            window.quantumState.recentFiles.unshift({
                filename,
                content: content.substring(0, 1000), // Store only preview
                timestamp: Date.now()
            });

            // Keep only last 10 files
            window.quantumState.recentFiles = window.quantumState.recentFiles.slice(0, 10);
            
            this.saveRecentFiles();
            this.updateRecentFilesUI();
        }

        updateRecentFilesUI() {
            const container = document.getElementById('recent-files');
            container.innerHTML = '';

            window.quantumState.recentFiles.forEach(file => {
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.innerHTML = `
                    <div style="font-weight: bold;">${file.filename}</div>
                    <div style="font-size: 9px; color: var(--muted-text);">${new Date(file.timestamp).toLocaleDateString()}</div>
                `;
                item.addEventListener('click', () => {
                    quantumEditor.setContent(file.content, quantumEditor.highlighter.detectLanguage(file.filename));
                    document.getElementById('file-meta').textContent = file.filename;
                    quantumEditor.currentFileName = file.filename;
                });
                container.appendChild(item);
            });

            if (window.quantumState.recentFiles.length === 0) {
                container.innerHTML = '<div style="padding: 8px; color: var(--muted-text); font-size: 10px;">No recent files</div>';
            }
        }

        // ... (previous memory management methods remain the same)
        async store(key, data, priority = 'medium') {
            try {
                const cache = this.getCache();
                const dataSize = new Blob([JSON.stringify(data)]).size;
                if (dataSize > this.maxMemoryThreshold) {
                    throw new Error('Data too large for storage');
                }

                cache[key] = {
                    data: data,
                    timestamp: Date.now(),
                    priority: priority,
                    size: dataSize
                };

                if (Object.keys(cache).length > this.cacheLimit) {
                    this.cleanupCache();
                }

                await this.saveCache(cache);
                return true;
            } catch (error) {
                console.warn('Storage failed, falling back to memory:', error);
                if (!window.quantumMemoryCache) {
                    window.quantumMemoryCache = new Map();
                }
                window.quantumMemoryCache.set(key, data);
                return false;
            }
        }

        async retrieve(key) {
            try {
                const cache = this.getCache();
                if (cache[key]) {
                    return cache[key].data;
                }
                
                if (window.quantumMemoryCache && window.quantumMemoryCache.has(key)) {
                    return window.quantumMemoryCache.get(key);
                }
                
                return null;
            } catch (error) {
                console.warn('Retrieval failed:', error);
                return null;
            }
        }

        cleanupCache() {
            try {
                const cache = this.getCache();
                const entries = Object.entries(cache);
                
                if (entries.length > this.cacheLimit) {
                    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
                    const toRemove = entries.slice(0, Math.floor(entries.length * 0.3));
                    toRemove.forEach(([key]) => delete cache[key]);
                    this.saveCache(cache);
                }
            } catch (error) {
                console.warn('Cache cleanup failed:', error);
            }
        }

        emergencyCleanup() {
            try {
                localStorage.removeItem(this.storageKey);
                sessionStorage.clear();
                
                if (window.quantumMemoryCache) {
                    window.quantumMemoryCache.clear();
                }
                
                if (window.gc) window.gc();
                this.clearLargeArrays();
                console.log('Emergency memory cleanup completed');
            } catch (error) {
                console.error('Emergency cleanup failed:', error);
            }
        }

        aggressiveCleanup() {
            try {
                const cache = this.getCache();
                const entries = Object.entries(cache);
                const toKeep = entries.filter(([key, entry]) => 
                    entry.priority === 'high' && entry.size < 1024 * 1024
                );
                this.saveCache(Object.fromEntries(toKeep));
                
                if (window.quantumMemoryCache) {
                    const keys = Array.from(window.quantumMemoryCache.keys());
                    keys.slice(0, Math.floor(keys.length * 0.5)).forEach(key => 
                        window.quantumMemoryCache.delete(key)
                    );
                }
                console.log('Aggressive memory cleanup completed');
            } catch (error) {
                console.warn('Aggressive cleanup failed:', error);
            }
        }

        clearLargeArrays() {
            if (window.largeArrays) {
                window.largeArrays.clear();
            }
        }

        cleanupOldCache() {
            const cache = this.getCache();
            const now = Date.now();
            const oneHour = 60 * 60 * 1000;
            
            Object.keys(cache).forEach(key => {
                if (now - cache[key].timestamp > oneHour) {
                    delete cache[key];
                }
            });
            this.saveCache(cache);
        }

        getCache() {
            try {
                const stored = localStorage.getItem(this.storageKey);
                return stored ? JSON.parse(stored) : {};
            } catch (error) {
                console.warn('Cache retrieval failed:', error);
                return {};
            }
        }

        async saveCache(cache) {
            try {
                localStorage.setItem(this.storageKey, JSON.stringify(cache));
            } catch (error) {
                console.warn('Cache save failed:', error);
            }
        }

        cleanup() {
            if (this.cleanupInterval) {
                clearInterval(this.cleanupInterval);
            }
        }

        async exportSession() {
            try {
                const sessionData = {
                    timestamp: Date.now(),
                    cache: this.getCache(),
                    memoryCache: window.quantumMemoryCache ? 
                        Array.from(window.quantumMemoryCache.entries()) : [],
                    recentFiles: window.quantumState.recentFiles,
                    settings: window.quantumState.settings
                };
                
                const blob = new Blob([JSON.stringify(sessionData, null, 2)], 
                    { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `quantum_session_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                return true;
            } catch (error) {
                console.error('Session export failed:', error);
                return false;
            }
        }

        async clearAllCache() {
            try {
                localStorage.removeItem(this.storageKey);
                localStorage.removeItem(this.settingsKey);
                localStorage.removeItem(this.recentFilesKey);
                if (window.quantumMemoryCache) {
                    window.quantumMemoryCache.clear();
                }
                sessionStorage.clear();
                return true;
            } catch (error) {
                console.error('Cache clearance failed:', error);
                return false;
            }
        }
    }

    /* =========================================================================
       ENHANCED QUANTUM SYNTAX HIGHLIGHTER
       ========================================================================== */

    class QuantumSyntaxHighlighter {
        constructor() {
            this.languagePatterns = {
                javascript: this.getJavaScriptPatterns(),
                typescript: this.getTypeScriptPatterns(),
                html: this.getHTMLPatterns(),
                css: this.getCSSPatterns(),
                python: this.getPythonPatterns(),
                php: this.getPHPPatterns(),
                sql: this.getSQLPatterns(),
                markdown: this.getMarkdownPatterns(),
                json: this.getJSONPatterns(),
                jsx: this.getJSXPatterns(),
                tsx: this.getTSXPatterns(),
                xml: this.getXMLPatterns(),
                yaml: this.getYAMLPatterns()
            };
            
            this.currentLanguage = 'javascript';
            this.debounceTimer = null;
            this.debounceDelay = 50;
        }

        getJavaScriptPatterns() {
            return [
                { pattern: /\/\/.*$/gm, type: 'comment' },
                { pattern: /\/\*[\s\S]*?\*\//g, type: 'comment' },
                { pattern: /`(?:\\.|[^`\\])*`/g, type: 'template-string' },
                { pattern: /'(?:\\.|[^'\\])*'/g, type: 'string' },
                { pattern: /"(?:\\.|[^"\\])*"/g, type: 'string' },
                { pattern: /\/(?![*\/])(?:\\.|[^\/\\\n])+\/[gimuy]*/g, type: 'regex' },
                { pattern: /\b\d+(\.\d+)?\b/g, type: 'number' },
                { pattern: /\b0x[a-fA-F0-9]+\b/g, type: 'number' },
                { pattern: /\b(?:function|class|const|let|var|if|else|for|while|do|switch|case|break|continue|return|try|catch|finally|throw|new|this|super|extends|implements|import|export|from|default|async|await|yield|static|public|private|protected|readonly|abstract|interface|type|namespace|module|declare|get|set|of|in|instanceof|typeof|void|delete)\b/g, type: 'keyword' },
                { pattern: /\b(?:console|Math|Date|Array|Object|String|Number|Boolean|Symbol|Map|Set|Promise|JSON|RegExp|Error|Function|Proxy|Reflect)\b/g, type: 'type' },
                { pattern: /\b[a-zA-Z_$][\w$]*(?=\s*\()/g, type: 'function' },
                { pattern: /[+\-*/%=<>!&|^~?:.,;]/g, type: 'operator' },
                { pattern: /[{}()[\]<>]/g, type: 'bracket' }
            ];
        }

        getTypeScriptPatterns() {
            const jsPatterns = this.getJavaScriptPatterns();
            jsPatterns.push(
                { pattern: /\b(?:interface|type|implements|namespace|module|declare|readonly|abstract|public|private|protected)\b/g, type: 'keyword' },
                { pattern: /:\s*\w+/g, type: 'type' }
            );
            return jsPatterns;
        }

        getHTMLPatterns() {
            return [
                { pattern: /<!--[\s\S]*?-->/g, type: 'comment' },
                { pattern: /<\/?[\w][\w-]*/g, type: 'tag' },
                { pattern: /(?<=<\/?[\w][\w-]*\s+)[\w-]+(?=\s*=)/g, type: 'property' },
                { pattern: /"(?:\\.|[^"\\])*"/g, type: 'string' },
                { pattern: /'(?:\\.|[^'\\])*'/g, type: 'string' },
                { pattern: /<!DOCTYPE\s+[^>]+>/gi, type: 'keyword' }
            ];
        }

        getCSSPatterns() {
            return [
                { pattern: /\/\*[\s\S]*?\*\//g, type: 'comment' },
                { pattern: /[.#]?[\w-]+\s*(?={)/g, type: 'css-selector' },
                { pattern: /[\w-]+(?=\s*:)/g, type: 'css-property' },
                { pattern: /:\s*[^;]+/g, type: 'css-value' },
                { pattern: /!important/gi, type: 'keyword' },
                { pattern: /@\w+/g, type: 'keyword' }
            ];
        }

        getPythonPatterns() {
            return [
                { pattern: /#.*$/gm, type: 'comment' },
                { pattern: /"""(?:.|\n)*?"""/g, type: 'string' },
                { pattern: /'''(?:.|\n)*?'''/g, type: 'string' },
                { pattern: /"(?:\\.|[^"\\])*"/g, type: 'string' },
                { pattern: /'(?:\\.|[^'\\])*'/g, type: 'string' },
                { pattern: /\b\d+(\.\d+)?\b/g, type: 'number' },
                { pattern: /\b(?:def|class|if|elif|else|for|while|try|except|finally|with|import|from|as|return|yield|async|await|lambda|None|True|False|and|or|not|in|is|global|nonlocal|del|pass|break|continue|raise)\b/g, type: 'keyword' },
                { pattern: /\b[a-zA-Z_][\w]*(?=\s*\()/g, type: 'function' },
                { pattern: /@\w+/g, type: 'function' }
            ];
        }

        getPHPPatterns() {
            return [
                { pattern: /\/\/.*$/gm, type: 'comment' },
                { pattern: /#.*$/gm, type: 'comment' },
                { pattern: /\/\*[\s\S]*?\*\//g, type: 'comment' },
                { pattern: /<\?php|\?>/g, type: 'tag' },
                { pattern: /'(?:\\.|[^'\\])*'/g, type: 'string' },
                { pattern: /"(?:\\.|[^"\\])*"/g, type: 'string' },
                { pattern: /\$\w+/g, type: 'variable' },
                { pattern: /\b(?:function|class|interface|trait|namespace|use|public|private|protected|static|final|abstract|const|if|else|elseif|for|foreach|while|do|switch|case|break|continue|return|try|catch|finally|throw|new|clone|instanceof|echo|print|die|exit|isset|unset|empty)\b/g, type: 'keyword' }
            ];
        }

        getSQLPatterns() {
            return [
                { pattern: /--.*$/gm, type: 'comment' },
                { pattern: /\/\*[\s\S]*?\*\//g, type: 'comment' },
                { pattern: /'(?:\\.|[^'\\])*'/g, type: 'string' },
                { pattern: /"(?:\\.|[^"\\])*"/g, type: 'string' },
                { pattern: /\b(?:SELECT|INSERT|UPDATE|DELETE|FROM|WHERE|JOIN|INNER|LEFT|RIGHT|OUTER|ON|AND|OR|NOT|IN|BETWEEN|LIKE|IS|NULL|ORDER BY|GROUP BY|HAVING|LIMIT|OFFSET|UNION|CREATE|ALTER|DROP|TABLE|INDEX|VIEW|DATABASE|TRIGGER|PROCEDURE|FUNCTION|VALUES|SET|DEFAULT|PRIMARY KEY|FOREIGN KEY|REFERENCES|CASCADE|UNIQUE|CHECK|EXISTS|CASE|WHEN|THEN|ELSE|END|DISTINCT|COUNT|SUM|AVG|MIN|MAX)\b/gi, type: 'keyword' },
                { pattern: /\b\d+(\.\d+)?\b/g, type: 'number' }
            ];
        }

        getMarkdownPatterns() {
            return [
                { pattern: /^#{1,6}\s+.+$/gm, type: 'keyword' },
                { pattern: /\*\*(.*?)\*\*/g, type: 'keyword' },
                { pattern: /\*(.*?)\*/g, type: 'comment' },
                { pattern: /`[^`]*`/g, type: 'string' },
                { pattern: /```[\s\S]*?```/g, type: 'template-string' },
                { pattern: /\[([^\]]+)\]\(([^)]+)\)/g, type: 'function' },
                { pattern: /^\s*[\-\*\+]\s+/gm, type: 'operator' },
                { pattern: /^\s*\d+\.\s+/gm, type: 'number' }
            ];
        }

        getJSONPatterns() {
            return [
                { pattern: /"(?:\\.|[^"\\])*"(?=\s*:)/g, type: 'key' },
                { pattern: /"(?:\\.|[^"\\])*"/g, type: 'string' },
                { pattern: /\b\d+(\.\d+)?\b/g, type: 'number' },
                { pattern: /\b(?:true|false|null)\b/g, type: 'keyword' }
            ];
        }

        getJSXPatterns() {
            const jsPatterns = this.getJavaScriptPatterns();
            jsPatterns.push(
                { pattern: /<\/?[A-Z][\w]*|<\/?[a-z][\w-]*/g, type: 'jsx-tag' },
                { pattern: /(?<=<[A-Z][\w]*\s+)[\w-]+(?=\s*=)/g, type: 'jsx-attribute' }
            );
            return jsPatterns;
        }

        getTSXPatterns() {
            const tsPatterns = this.getTypeScriptPatterns();
            tsPatterns.push(
                { pattern: /<\/?[A-Z][\w]*|<\/?[a-z][\w-]*/g, type: 'jsx-tag' },
                { pattern: /(?<=<[A-Z][\w]*\s+)[\w-]+(?=\s*=)/g, type: 'jsx-attribute' }
            );
            return tsPatterns;
        }

        getXMLPatterns() {
            return [
                { pattern: /<!--[\s\S]*?-->/g, type: 'comment' },
                { pattern: /<\/?[\w][\w-]*/g, type: 'tag' },
                { pattern: /(?<=<\/?[\w][\w-]*\s+)[\w-]+(?=\s*=)/g, type: 'property' },
                { pattern: /"(?:\\.|[^"\\])*"/g, type: 'string' },
                { pattern: /'(?:\\.|[^'\\])*'/g, type: 'string' }
            ];
        }

        getYAMLPatterns() {
            return [
                { pattern: /#.*$/gm, type: 'comment' },
                { pattern: /"(?:\\.|[^"\\])*"/g, type: 'string' },
                { pattern: /'(?:\\.|[^'\\])*'/g, type: 'string' },
                { pattern: /\b\d+(\.\d+)?\b/g, type: 'number' },
                { pattern: /^(?:\s*)[\w-]+(?=\s*:)/gm, type: 'key' },
                { pattern: /\b(?:true|false|null|yes|no|on|off)\b/gi, type: 'keyword' }
            ];
        }

        detectLanguage(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const languageMap = {
                'js': 'javascript', 'jsx': 'jsx', 'ts': 'typescript', 'tsx': 'tsx',
                'html': 'html', 'htm': 'html', 'css': 'css', 'py': 'python',
                'php': 'php', 'sql': 'sql', 'md': 'markdown', 'json': 'json',
                'txt': 'javascript', 'xml': 'xml', 'yaml': 'yaml', 'yml': 'yaml'
            };
            return languageMap[ext] || 'javascript';
        }

        setLanguage(language) {
            this.currentLanguage = language;
        }

        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        highlightText(text, language = null) {
            const lang = language || this.currentLanguage;
            const patterns = this.languagePatterns[lang] || this.languagePatterns.javascript;
            
            let highlighted = this.escapeHtml(text);
            
            patterns.forEach(({ pattern, type }) => {
                highlighted = highlighted.replace(pattern, match => {
                    return `<span class="sh-token sh-${type}">${match}</span>`;
                });
            });
            
            return highlighted;
        }

        highlightElement(element, language = null) {
            const text = element.textContent || '';
            const html = this.highlightText(text, language);
            
            const selection = window.getSelection();
            const range = selection.rangeCount > 0 ? selection.getRangeAt(0).cloneRange() : null;
            
            element.innerHTML = html;
            
            if (range) {
                selection.removeAllRanges();
                selection.addRange(range);
            }
        }

        enableRealtimeHighlighting(editorElement, language = null) {
            let isComposing = false;
            
            const highlight = () => {
                if (isComposing) return;
                
                clearTimeout(this.debounceTimer);
                this.debounceTimer = setTimeout(() => {
                    this.highlightElement(editorElement, language);
                }, this.debounceDelay);
            };
            
            editorElement.addEventListener('input', highlight);
            editorElement.addEventListener('compositionstart', () => { isComposing = true; });
            editorElement.addEventListener('compositionend', () => { 
                isComposing = false; 
                highlight();
            });
            editorElement.addEventListener('paste', () => setTimeout(highlight, 10));
            
            highlight();
        }
    }

    /* =========================================================================
       ENHANCED QUANTUM EDITOR WITH COMPLETE FEATURES
       ========================================================================== */

    class QuantumEditor {
        constructor() {
            this.editor = document.getElementById('editor');
            this.lineNumbers = document.getElementById('line-numbers');
            this.statusEditor = document.getElementById('editor-meta');
            this.statusFile = document.getElementById('file-meta');
            this.memoryManager = new QuantumMemoryManager();
            this.highlighter = new QuantumSyntaxHighlighter();
            this.quantumThinking = document.getElementById('quantum-thinking');

            this.currentFileName = null;
            this.currentFileType = 'javascript';
            this.historyStack = [];
            this.redoStack = [];
            this.isComposing = false;
            this.quantumMode = true;
            this.hyperthreading = true;
            this.multiAgentMode = true;

            // Enhanced settings
            this.maxHistorySize = 50;
            this.debounceDelay = 100;
            this.chunkSize = 1000;
            this.autoSaveInterval = null;

            this.init();
        }

        init() {
            this.bindEvents();
            this.loadAutosave();
            this.pushHistory();
            this.initQuantumVisuals();
            this.enableRealtimeHighlighting();
            this.startAutoSave();
        }

        startAutoSave() {
            if (window.quantumState.settings.autoSave) {
                this.autoSaveInterval = setInterval(() => {
                    this.saveAutosave();
                }, 30000); // Auto-save every 30 seconds
            }
        }

        stopAutoSave() {
            if (this.autoSaveInterval) {
                clearInterval(this.autoSaveInterval);
            }
        }

        async loadAutosave() {
            try {
                const autosave = await this.memoryManager.retrieve('autosave_content');
                if (autosave && !this.editor.textContent.trim()) {
                    this.render(autosave);
                    quantumNotify('Autosave restored', 'success');
                }
            } catch (error) {
                console.warn('Autosave load failed:', error);
            }
        }

        async saveAutosave() {
            if (!window.quantumState.settings.autoSave) return;
            
            try {
                const content = this.editor.textContent;
                if (content.trim()) {
                    await this.memoryManager.store('autosave_content', content, 'high');
                }
            } catch (error) {
                console.warn('Autosave failed:', error);
            }
        }

        bindEvents() {
            let inputTimeout;
            this.editor.addEventListener('input', () => {
                clearTimeout(inputTimeout);
                inputTimeout = setTimeout(() => {
                    this.handleInput();
                }, this.debounceDelay);
            });

            this.editor.addEventListener('compositionstart', () => this.isComposing = true);
            this.editor.addEventListener('compositionend', () => {
                this.isComposing = false;
                this.handleInput();
            });

            this.editor.addEventListener('keydown', this.handleKeydown.bind(this));
            this.editor.addEventListener('click', this.updateStatus.bind(this));
            this.editor.addEventListener('keyup', this.updateStatus.bind(this));
            this.editor.addEventListener('scroll', this.syncScroll.bind(this));

            // Enhanced event listeners
            window.addEventListener('beforeunload', () => this.saveAutosave());
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    this.saveAutosave();
                }
            });

            // Settings bindings
            document.getElementById('quantum-mode').addEventListener('change', (e) => {
                window.quantumState.settings.quantumMode = e.target.checked;
                this.quantumMode = e.target.checked;
                this.memoryManager.saveSettings();
                if (this.quantumMode) {
                    this.createFractalNodes();
                } else {
                    this.quantumThinking.innerHTML = '';
                }
            });

            document.getElementById('hyperthreading').addEventListener('change', (e) => {
                window.quantumState.settings.hyperthreading = e.target.checked;
                this.hyperthreading = e.target.checked;
                this.memoryManager.saveSettings();
                if (this.quantumMode) {
                    this.createFractalNodes();
                }
            });

            document.getElementById('multi-agent-mode').addEventListener('change', (e) => {
                window.quantumState.settings.multiAgentMode = e.target.checked;
                this.multiAgentMode = e.target.checked;
                this.memoryManager.saveSettings();
            });

            document.getElementById('auto-save').addEventListener('change', (e) => {
                window.quantumState.settings.autoSave = e.target.checked;
                this.memoryManager.saveSettings();
                if (e.target.checked) {
                    this.startAutoSave();
                } else {
                    this.stopAutoSave();
                }
            });

            document.getElementById('agent-count').addEventListener('change', (e) => {
                window.quantumState.settings.agentCount = parseInt(e.target.value);
                this.memoryManager.saveSettings();
            });

            document.getElementById('max-rounds').addEventListener('change', (e) => {
                window.quantumState.settings.maxRounds = parseInt(e.target.value);
                this.memoryManager.saveSettings();
            });

            document.getElementById('reasoning-depth').addEventListener('change', (e) => {
                window.quantumState.settings.reasoningDepth = parseInt(e.target.value);
                this.memoryManager.saveSettings();
            });

            // Memory management
            document.getElementById('btn-clear-cache').addEventListener('click', () => {
                this.memoryManager.clearAllCache().then(success => {
                    quantumNotify(success ? 'Cache cleared' : 'Cache clearance failed', 
                                success ? 'success' : 'error');
                });
            });

            document.getElementById('btn-optimize-memory').addEventListener('click', () => {
                this.memoryManager.aggressiveCleanup();
                quantumNotify('Memory optimized', 'success');
            });

            document.getElementById('btn-export-session').addEventListener('click', () => {
                this.memoryManager.exportSession().then(success => {
                    quantumNotify(success ? 'Session exported' : 'Export failed', 
                                success ? 'success' : 'error');
                });
            });

            // Code suggestions
            this.setupCodeSuggestions();
        }

        setupCodeSuggestions() {
            const promptInput = document.getElementById('prompt-input');
            const suggestionsPanel = document.getElementById('suggestions-panel');

            promptInput.addEventListener('input', () => {
                const value = promptInput.value.toLowerCase();
                if (value.length < 2) {
                    suggestionsPanel.style.display = 'none';
                    return;
                }

                const suggestions = this.getSuggestions(value);
                if (suggestions.length > 0) {
                    this.showSuggestions(suggestions, promptInput);
                } else {
                    suggestionsPanel.style.display = 'none';
                }
            });

            promptInput.addEventListener('blur', () => {
                setTimeout(() => {
                    suggestionsPanel.style.display = 'none';
                }, 200);
            });
        }

        getSuggestions(input) {
            const commonCommands = [
                'create a function to sort arrays',
                'optimize this code for performance',
                'add error handling to this function',
                'convert this to TypeScript',
                'explain this code',
                'refactor this code',
                'write unit tests for this function',
                'create a React component',
                'implement a database query',
                'add comments to this code',
                'fix bugs in this code',
                'improve code readability',
                'implement authentication',
                'create API endpoints',
                'optimize database queries',
                'add input validation',
                'implement caching',
                'create documentation',
                'set up logging',
                'handle edge cases'
            ];

            return commonCommands.filter(cmd => 
                cmd.toLowerCase().includes(input.toLowerCase())
            ).slice(0, 5);
        }

        showSuggestions(suggestions, inputElement) {
            const suggestionsPanel = document.getElementById('suggestions-panel');
            suggestionsPanel.innerHTML = '';

            suggestions.forEach(suggestion => {
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.textContent = suggestion;
                item.addEventListener('click', () => {
                    inputElement.value = suggestion;
                    suggestionsPanel.style.display = 'none';
                    inputElement.focus();
                });
                suggestionsPanel.appendChild(item);
            });

            const rect = inputElement.getBoundingClientRect();
            suggestionsPanel.style.position = 'fixed';
            suggestionsPanel.style.top = (rect.bottom + window.scrollY) + 'px';
            suggestionsPanel.style.left = (rect.left + window.scrollX) + 'px';
            suggestionsPanel.style.width = (rect.width) + 'px';
            suggestionsPanel.style.display = 'block';
        }

        handleInput() {
            if (this.isComposing) return;

            this.pushHistory();
            this.updateLineNumbers();
            this.updateStatus();
            this.saveAutosave();

            if (this.quantumMode) {
                this.createFractalNodes();
            }
        }

        handleKeydown(event) {
            if (event.key === 'Tab') {
                event.preventDefault();
                this.insertText('    ');
            }

            if (event.ctrlKey || event.metaKey) {
                if (event.key === 'z' && !event.shiftKey) {
                    event.preventDefault();
                    this.undo();
                } else if (event.key === 'z' && event.shiftKey) {
                    event.preventDefault();
                    this.redo();
                } else if (event.key === 'y') {
                    event.preventDefault();
                    this.redo();
                } else if (event.key === 's') {
                    event.preventDefault();
                    quantumSaveFile();
                } else if (event.key === 'f') {
                    event.preventDefault();
                    this.showFindDialog();
                } else if (event.key === 'd') {
                    event.preventDefault();
                    this.duplicateLine();
                }
            } else if (event.key === 'F2') {
                event.preventDefault();
                this.renameVariable();
            }
        }

        showFindDialog() {
            const findText = prompt('Find:');
            if (findText) {
                const content = this.editor.textContent;
                const regex = new RegExp(findText, 'gi');
                const matches = content.match(regex);
                if (matches) {
                    quantumNotify(`Found ${matches.length} matches`, 'info');
                    this.highlightMatches(findText);
                } else {
                    quantumNotify('No matches found', 'warn');
                }
            }
        }

        highlightMatches(text) {
            const content = this.editor.innerHTML;
            const regex = new RegExp(`(${text})`, 'gi');
            const highlighted = content.replace(regex, '<mark>$1</mark>');
            this.editor.innerHTML = highlighted;
            
            // Remove highlighting after 3 seconds
            setTimeout(() => {
                this.highlighter.highlightElement(this.editor, this.currentFileType);
            }, 3000);
        }

        duplicateLine() {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);
            const lineElement = range.startContainer.parentElement;
            const lineText = lineElement.textContent;
            
            const newLine = document.createTextNode('\n' + lineText);
            range.insertNode(newLine);
            
            this.handleInput();
        }

        renameVariable() {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);
            const selectedText = range.toString();
            
            if (selectedText) {
                const newName = prompt('Rename variable:', selectedText);
                if (newName && newName !== selectedText) {
                    range.deleteContents();
                    range.insertNode(document.createTextNode(newName));
                    this.handleInput();
                }
            } else {
                quantumNotify('Select a variable to rename', 'warn');
            }
        }

        insertText(text) {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);
            range.deleteContents();
            range.insertNode(document.createTextNode(text));

            range.setStart(range.endContainer, range.endOffset);
            range.setEnd(range.endContainer, range.endOffset);
            selection.removeAllRanges();
            selection.addRange(range);

            this.handleInput();
        }

        enableRealtimeHighlighting() {
            this.highlighter.enableRealtimeHighlighting(this.editor, this.currentFileType);
        }

        initQuantumVisuals() {
            const threadsContainer = document.getElementById('quantum-threads');
            for (let i = 0; i < 5; i++) {
                const thread = document.createElement('div');
                thread.className = 'quantum-thread';
                thread.style.left = `${20 + i * 15}%`;
                thread.style.animationDelay = `${i * 0.3}s`;
                threadsContainer.appendChild(thread);
            }
        }

        createFractalNodes() {
            if (!this.quantumMode) return;

            this.quantumThinking.innerHTML = '';
            const nodeCount = this.hyperthreading ? 12 : 6;

            for (let i = 0; i < nodeCount; i++) {
                const node = document.createElement('div');
                node.className = 'fractal-node';
                node.style.left = `${Math.random() * 100}%`;
                node.style.top = `${Math.random() * 100}%`;
                node.style.animationDelay = `${Math.random() * 2}s`;
                node.style.background = i % 2 === 0 ? 'var(--agent-nexus)' : 'var(--agent-cognito)';
                this.quantumThinking.appendChild(node);
            }
        }

        pushHistory() {
            const content = this.editor.textContent;
            if (this.historyStack.length && this.historyStack[this.historyStack.length - 1] === content) return;

            this.historyStack.push(content);
            this.redoStack = [];

            if (this.historyStack.length > this.maxHistorySize) {
                this.historyStack.shift();
            }
        }

        undo() {
            if (this.historyStack.length > 1) {
                this.redoStack.push(this.historyStack.pop());
                this.render(this.historyStack[this.historyStack.length - 1]);
            }
        }

        redo() {
            if (this.redoStack.length) {
                const content = this.redoStack.pop();
                this.historyStack.push(content);
                this.render(content);
            }
        }

        render(content) {
            try {
                if (content.length > 100000) {
                    this.renderInChunks(content);
                } else {
                    this.editor.textContent = content;
                    this.highlightContent();
                }
                
                this.updateLineNumbers();
                this.updateStatus();

                if (this.quantumMode) {
                    this.createFractalNodes();
                }
            } catch (error) {
                console.error('Render failed:', error);
                this.handleMemoryError(error);
            }
        }

        renderInChunks(content) {
            const lines = content.split('\n');
            const chunkSize = this.chunkSize;
            let currentChunk = 0;

            const renderNextChunk = () => {
                const start = currentChunk * chunkSize;
                const end = start + chunkSize;
                const chunk = lines.slice(start, end).join('\n');
                
                if (currentChunk === 0) {
                    this.editor.textContent = chunk;
                } else {
                    this.editor.textContent += '\n' + chunk;
                }

                if (end < lines.length) {
                    currentChunk++;
                    setTimeout(renderNextChunk, 0);
                } else {
                    this.highlightContent();
                }
            };

            renderNextChunk();
        }

        highlightContent() {
            this.highlighter.highlightElement(this.editor, this.currentFileType);
        }

        updateLineNumbers() {
            try {
                const text = this.editor.textContent || '';
                const lines = text.split('\n');
                const lineCount = lines.length;

                let lineNumbersHTML = '';
                for (let i = 1; i <= lineCount; i++) {
                    lineNumbersHTML += i + '<br>';
                }

                this.lineNumbers.innerHTML = lineNumbersHTML;
                this.lineNumbers.style.height = this.editor.scrollHeight + 'px';
            } catch (error) {
                console.warn('Line number update failed:', error);
            }
        }

        syncScroll() {
            this.lineNumbers.scrollTop = this.editor.scrollTop;
        }

        updateStatus() {
            const selection = window.getSelection();
            const text = this.editor.textContent || '';
            const lines = text.split('\n');

            let lineNum = 1;
            let colNum = 0;

            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const preCaretRange = range.cloneRange();
                preCaretRange.selectNodeContents(this.editor);
                preCaretRange.setEnd(range.endContainer, range.endOffset);

                const preCaretText = preCaretRange.toString();
                const preCaretLines = preCaretText.split('\n');

                lineNum = preCaretLines.length;
                colNum = preCaretLines[preCaretLines.length - 1].length;
            }

            const quantumStatus = this.quantumMode ?
                ` | Quantum: ${this.hyperthreading ? 'Hyperthreaded' : 'Standard'}` :
                ' | Classical Mode';

            const agentStatus = this.multiAgentMode ? ' | Multi-Agent' : ' | Single-Agent';

            this.statusEditor.textContent =
                `Cursor: ${lineNum}:${colNum} | Lines: ${lines.length} | Chars: ${text.length} | History: ${this.historyStack.length}${quantumStatus}${agentStatus}`;
        }

        handleMemoryError(error) {
            console.error('Memory error occurred:', error);
            document.getElementById('memory-status').textContent = 'RAM: CRITICAL';
            document.getElementById('memory-status').className = 'memory-status low';
            
            this.memoryManager.emergencyCleanup();
            this.editor.textContent = '// Memory optimization in progress...\n// Please save your work and refresh if issues persist';
            
            quantumNotify('Memory optimized for stability', 'warn');
        }

        setContent(content, fileType = 'javascript') {
            try {
                this.currentFileType = fileType;
                this.highlighter.setLanguage(fileType);
                this.render(content);
                this.historyStack = [content];
                this.redoStack = [];
            } catch (error) {
                this.handleMemoryError(error);
            }
        }

        getContent() {
            return this.editor.textContent;
        }

        insertCodeAtCursor(code) {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);
            range.deleteContents();

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = code;

            const fragment = document.createDocumentFragment();
            while (tempDiv.firstChild) {
                fragment.appendChild(tempDiv.firstChild);
            }

            range.insertNode(fragment);

            range.setStartAfter(fragment.lastChild);
            range.setEndAfter(fragment.lastChild);
            selection.removeAllRanges();
            selection.addRange(range);

            this.handleInput();
        }

        replaceSelectionWithCode(code) {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);
            range.deleteContents();

            const textNode = document.createTextNode(code);
            range.insertNode(textNode);

            range.setStartAfter(textNode);
            range.setEndAfter(textNode);
            selection.removeAllRanges();
            selection.addRange(range);

            this.handleInput();
        }

        // Code formatting and beautification
        beautifyCode() {
            try {
                const content = this.getContent();
                let formatted = content;

                // Basic formatting rules
                formatted = formatted.replace(/\s+/g, ' '); // Remove extra whitespace
                formatted = formatted.replace(/\s*{\s*/g, ' { '); // Format braces
                formatted = formatted.replace(/\s*}\s*/g, ' } ');
                formatted = formatted.replace(/\s*\(\s*/g, ' ( '); // Format parentheses
                formatted = formatted.replace(/\s*\)\s*/g, ' ) ');
                formatted = formatted.replace(/;\s+/g, ';\n'); // Add newlines after semicolons
                formatted = formatted.replace(/\n\s*\n/g, '\n'); // Remove multiple empty lines

                this.setContent(formatted);
                quantumNotify('Code beautified', 'success');
            } catch (error) {
                quantumNotify('Beautification failed', 'error');
            }
        }
    }

    /* =========================================================================
       ENHANCED QUANTUM ORCHESTRATOR WITH FULL 10-RULES IMPLEMENTATION
       ========================================================================== */

    class EnhancedQuantumOrchestrator {
        constructor() {
            this.agents = {
                nexus: document.querySelector('.agent-nexus .agent-content'),
                cognito: document.querySelector('.agent-cognito .agent-content'),
                relay: document.querySelector('.agent-relay .agent-content'),
                sentinel: document.querySelector('.agent-sentinel .agent-content'),
                echo: document.querySelector('.agent-echo .agent-content')
            };

            this.logElements = {
                nexus: document.getElementById('nexus-log'),
                cognito: document.getElementById('cognito-log'),
                relay: document.getElementById('relay-log'),
                sentinel: document.getElementById('sentinel-log'),
                echo: document.getElementById('echo-log')
            };

            this.agentCards = {
                nexus: document.querySelector('.agent-nexus'),
                cognito: document.querySelector('.agent-cognito'),
                relay: document.querySelector('.agent-relay'),
                sentinel: document.querySelector('.agent-sentinel'),
                echo: document.querySelector('.agent-echo')
            };

            this.consensusPanel = document.getElementById('consensus-panel');
            this.candidatesList = document.getElementById('candidates-list');
            this.consensusScore = document.getElementById('consensus-score');

            this.isGenerating = false;
            this.quantumConnected = false;
            this.fileSystem = {
                genesisHash: null,
                eventLog: [],
                fragments: [],
                origins: {}
            };

            this.checkQuantumConnection();
            this.initQuantumHashing();
            this.bindOrchestratorEvents();
        }

        bindOrchestratorEvents() {
            document.getElementById('run-orchestrator').addEventListener('click', () => {
                this.runEnhancedOrchestrator();
            });

            document.getElementById('btn-orchestrate').addEventListener('click', () => {
                this.runEnhancedOrchestrator();
            });
        }

        initQuantumHashing() {
            this.hashSequences = {
                nexus: this.generateFractalHash('nexus'),
                cognito: this.generateFractalHash('cognito'),
                relay: this.generateFractalHash('relay'),
                sentinel: this.generateFractalHash('sentinel'),
                echo: this.generateFractalHash('echo')
            };
        }

        generateFractalHash(agentName, depth = 3) {
            const base = agentName + Date.now().toString();
            let hash = '';

            for (let i = 0; i < depth; i++) {
                let current = base;
                for (let j = 0; j <= i; j++) {
                    current = btoa(current).substring(0, 16);
                }
                hash += current;
            }

            return btoa(hash).substring(0, 32);
        }

        async checkQuantumConnection() {
            try {
                const response = await fetch('http://localhost:11434/api/tags');
                if (response.ok) {
                    this.quantumConnected = true;
                    quantumNotify('Ollama connected', 'success');
                } else {
                    this.setQuantumDisconnected();
                }
            } catch (error) {
                this.setQuantumDisconnected();
            }
        }

        setQuantumDisconnected() {
            this.quantumConnected = false;
            quantumNotify('Ollama not found - using simulated mode', 'warn');
        }

        async runEnhancedOrchestrator() {
            if (this.isGenerating) return;

            this.isGenerating = true;
            const promptInput = document.getElementById('prompt-input');
            const promptText = promptInput.value.trim() || "Optimize this code with quantum fractal patterns";
            const editorContext = quantumEditor.getContent();

            document.getElementById('ai-response-panel').style.display = 'block';

            Object.values(this.agents).forEach(agent => {
                agent.innerHTML = 'Initializing enhanced orchestration...';
            });

            Object.values(this.agentCards).forEach(card => {
                card.classList.remove('active');
            });

            Object.values(this.logElements).forEach(log => {
                log.innerHTML = '';
            });

            this.agents.nexus.innerHTML = '<div class="quantum-spinner"></div>Starting enhanced quantum orchestration...';
            this.agentCards.nexus.classList.add('active');

            try {
                // Rule 1: Genesis-hash
                await this.addLog('nexus', 'Generating genesis hash...', 'genesis');
                const genesisHash = await this.generateGenesisHash();
                this.fileSystem.genesisHash = genesisHash;
                await this.addLog('nexus', `Genesis: ${genesisHash.substring(0, 16)}...`, 'genesis');

                // Rule 2: Origin-hash per agent
                await this.addLog('nexus', 'Generating origin hashes for agents...', 'origin');
                const agents = [];
                const agentCount = window.quantumState.settings.agentCount;
                
                for (let i = 0; i < agentCount; i++) {
                    const agentId = `agent-${i}`;
                    const originHash = await this.generateOriginHash(genesisHash, agentId);
                    this.fileSystem.origins[agentId] = originHash;
                    agents.push({ id: agentId, origin: originHash });
                    await this.addLog('nexus', `${agentId}: ${originHash.substring(0, 12)}...`, 'origin');
                }

                // Rule 3: Parse prompt & timestamp event
                await this.addLog('nexus', 'Creating event log entry...', 'event');
                const event = {
                    prompt: promptText,
                    timestamp: Date.now(),
                    origin: genesisHash,
                    eventId: this.generateEventId()
                };
                this.fileSystem.eventLog.push(event);
                await this.addLog('nexus', `Event: ${event.eventId} logged`, 'event');

                // Rule 4: Start fractal quantum-states
                await this.addLog('cognito', `<div class="quantum-spinner"></div>Spawning ${agentCount} fractal agents...`);
                this.agentCards.cognito.classList.add('active');

                const allCandidates = [];
                const maxRounds = window.quantumState.settings.maxRounds;
                
                for (let round = 0; round < maxRounds; round++) {
                    await this.addLog('relay', `<div class="quantum-spinner"></div>Round ${round + 1}/${maxRounds}...`);
                    this.agentCards.relay.classList.add('active');

                    const roundPromises = agents.map(async (agent) => {
                        // Rule 5: Rehash each origin with genesis
                        const newOrigin = await this.rehashOrigin(agent.origin, genesisHash, round);
                        agent.origin = newOrigin;

                        // Rule 6: Accelerate reasoning on maths-logic
                        const candidate = await this.performFractalReasoning(agent, promptText, editorContext, round);
                        
                        // Store fragment
                        const fragment = {
                            agentId: agent.id,
                            origin: agent.origin,
                            round,
                            candidate,
                            entropy: this.calculateEntropy(agent.origin),
                            timestamp: Date.now()
                        };
                        
                        // Rule 7: Enforce collaboration
                        const peerFragments = this.fileSystem.fragments.filter(f => 
                            f.round === round && f.agentId !== agent.id
                        );
                        
                        // Rule 8: Set fragments as thinking pool
                        this.fileSystem.fragments.push(fragment);
                        await this.addLog('sentinel', `Fragment from ${agent.id} (round ${round})`, 'fragment');

                        allCandidates.push(fragment);
                        return fragment;
                    });

                    await Promise.all(roundPromises);
                    await new Promise(r => setTimeout(r, 500));
                }

                // Rule 9: Assemble final answer
                await this.addLog('sentinel', `<div class="quantum-spinner"></div>Assembling final consensus...`);
                this.agentCards.sentinel.classList.add('active');
                const consensus = await this.assembleFinalAnswer(allCandidates, genesisHash);

                // Rule 10: Use highest entropy origin as root
                await this.addLog('echo', `<div class="quantum-spinner"></div>Finalizing quantum report...`);
                this.agentCards.echo.classList.add('active');
                await this.displayEnhancedConsensusResults(consensus, allCandidates);

            } catch (e) {
                console.error("Enhanced orchestrator error:", e);
                this.agents.echo.innerHTML = `<span style="color: #ff4444">Orchestrator Error: ${e.message}</span>`;
            } finally {
                this.agents.nexus.innerHTML = 'Enhanced orchestration complete';
                this.agents.cognito.innerHTML = 'Ready';
                this.agents.relay.innerHTML = 'Ready';
                this.agents.sentinel.innerHTML = 'Ready';

                Object.values(this.agentCards).forEach(card => {
                    card.classList.remove('active');
                });
                this.isGenerating = false;
            }
        }

        async generateGenesisHash() {
            const timestamp = Date.now().toString();
            const random = Math.random().toString(36).substring(2);
            return this.simulateSHA256('GENESIS' + timestamp + random);
        }

        async generateOriginHash(genesis, agentId) {
            const nonce = Math.random().toString(36).substring(2, 10);
            return this.simulateSHA256(genesis + agentId + nonce);
        }

        async rehashOrigin(origin, genesis, round) {
            return this.simulateSHA256(origin + genesis + round.toString());
        }

        simulateSHA256(input) {
            let hash = 0;
            for (let i = 0; i < input.length; i++) {
                const char = input.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash).toString(36) + Math.random().toString(36).substring(2, 10);
        }

        generateEventId() {
            return 'event_' + Date.now().toString(36) + Math.random().toString(36).substring(2, 5);
        }

        calculateEntropy(hash) {
            const charCounts = {};
            for (const char of hash) {
                charCounts[char] = (charCounts[char] || 0) + 1;
            }
            
            let entropy = 0;
            const length = hash.length;
            
            for (const char in charCounts) {
                const probability = charCounts[char] / length;
                entropy -= probability * Math.log2(probability);
            }
            
            return entropy;
        }

        async performFractalReasoning(agent, prompt, context, round) {
            const reasoningStrategies = [
                "Apply recursive optimization patterns",
                "Use quantum efficiency algorithms", 
                "Implement fractal code structure",
                "Apply hyperthreaded reasoning",
                "Use entropy-based selection",
                "Apply mathematical transformation",
                "Implement parallel processing",
                "Use consensus validation"
            ];

            const strategy = reasoningStrategies[(round * window.quantumState.settings.reasoningDepth) % reasoningStrategies.length];
            const seed = agent.origin.substring(0, 12);

            await new Promise(r => setTimeout(r, 200 + (Math.random() * 400)));

            let reasoningOutput = `// ${agent.id} - Round ${round + 1} - ${strategy}
// Seed: ${seed} | Entropy: ${this.calculateEntropy(agent.origin).toFixed(3)}
// Fractal Depth: ${window.quantumState.settings.reasoningDepth}

`;

            const contextLines = context.split('\n').slice(0, 5);
            reasoningOutput += `// Context preview:\n`;
            contextLines.forEach((line, index) => {
                reasoningOutput += `// ${line.substring(0, 60)}${line.length > 60 ? '...' : ''}\n`;
            });

            reasoningOutput += `
// ${strategy.toLowerCase()} applied with quantum fractal patterns
function ${agent.id.replace('-', '_')}_quantum_${round}() {
    // Quantum-optimized implementation
    try {
        // Apply fractal transformation
        ${this.applyFractalTransformation(context, strategy)}
    } catch (quantumError) {
        console.error("Quantum fractal error:", quantumError);
        // Fallback to classical implementation
        ${this.getClassicalFallback(context)}
    }
}`;

            return reasoningOutput;
        }

        applyFractalTransformation(context, strategy) {
            const transformations = {
                "Apply recursive optimization patterns": `
        // Recursive fractal optimization
        function fractalOptimize(input, depth = 0) {
            if (depth >= 3) return input;
            return fractalOptimize(transform(input), depth + 1);
        }
        return fractalOptimize(data);`,
                
                "Use quantum efficiency algorithms": `
        // Quantum efficiency with parallel processing
        const results = await Promise.all(
            data.map(item => processQuantum(item))
        );
        return results.flat();`,
                
                "Implement fractal code structure": `
        // Fractal code structure with self-similar patterns
        const fractal = {
            transform: (x) => x * 2,
            iterate: (fn, n) => n > 0 ? fractal.iterate(fn, n-1) : fn(),
            optimize: (data) => data.map(fractal.transform)
        };
        return fractal.optimize(data);`,
                
                "Apply hyperthreaded reasoning": `
        // Hyperthreaded execution
        const threads = [];
        for (let i = 0; i < 4; i++) {
            threads.push(executeThread(data.slice(i * chunkSize, (i+1) * chunkSize)));
        }
        return (await Promise.all(threads)).flat();`
            };

            return transformations[strategy] || `
        // Standard optimization applied
        return data.map(item => optimize(item));`;
        }

        getClassicalFallback(context) {
            return `
        // Classical fallback implementation
        return data.filter(item => item !== null && item !== undefined)
                   .map(item => standardTransform(item));`;
        }

        async assembleFinalAnswer(allCandidates, genesis) {
            const candidateGroups = {};

            for (const candidate of allCandidates) {
                const key = candidate.candidate.substring(0, 100);
                if (!candidateGroups[key]) {
                    candidateGroups[key] = {
                        candidates: [],
                        totalEntropy: 0,
                        agents: new Set(),
                        rounds: new Set()
                    };
                }
                candidateGroups[key].candidates.push(candidate);
                candidateGroups[key].totalEntropy += candidate.entropy;
                candidateGroups[key].agents.add(candidate.agentId);
                candidateGroups[key].rounds.add(candidate.round);
            }

            const scoredGroups = Object.entries(candidateGroups).map(([key, group]) => {
                const agentCount = group.agents.size;
                const roundCount = group.rounds.size;
                const avgEntropy = group.totalEntropy / group.candidates.length;
                const score = (agentCount * 2) + (roundCount * 1.5) + (avgEntropy * 3);
                
                return { key, candidates: group.candidates, score, agentCount, roundCount, avgEntropy };
            });

            scoredGroups.sort((a, b) => b.score - a.score);
            const topGroup = scoredGroups[0];
            const rootCandidate = topGroup.candidates.reduce((best, current) => 
                current.entropy > best.entropy ? current : best
            );

            return {
                genesis,
                selectedCandidate: topGroup.candidates[0].candidate,
                score: topGroup.score.toFixed(3),
                agentCount: topGroup.agentCount,
                roundCount: topGroup.roundCount,
                avgEntropy: topGroup.avgEntropy.toFixed(3),
                rootAgent: rootCandidate.agentId,
                rootEntropy: rootCandidate.entropy.toFixed(3),
                allGroups: scoredGroups
            };
        }

        async displayEnhancedConsensusResults(consensus, allCandidates) {
            this.consensusPanel.style.display = 'block';
            this.consensusScore.textContent = `Score: ${consensus.score}`;

            this.candidatesList.innerHTML = '';

            consensus.allGroups.forEach((group, index) => {
                const isSelected = index === 0;
                const candidateEl = document.createElement('div');
                candidateEl.className = `candidate-item ${isSelected ? 'selected-candidate' : ''}`;
                candidateEl.innerHTML = `
                    <div class="candidate-meta">
                        <span>Agents: ${group.agentCount} | Rounds: ${group.roundCount}</span>
                        <span>Score: ${group.score.toFixed(2)} | Entropy: ${group.avgEntropy}</span>
                    </div>
                    <div class="candidate-content">${group.candidates[0].candidate.substring(0, 200)}${group.candidates[0].candidate.length > 200 ? '...' : ''}</div>
                `;
                this.candidatesList.appendChild(candidateEl);
            });

            const highlighter = new QuantumSyntaxHighlighter();
            const highlightedCode = highlighter.highlightText(consensus.selectedCandidate, quantumEditor.currentFileType);

            const quantumButtons = `
                <div class="action-buttons">
                    <button class="small success" onclick="quantumCopyEnhancedConsensus()">Copy Enhanced Consensus</button>
                    <button class="small info" onclick="quantumApplyEnhancedConsensus()">Apply Enhanced Code</button>
                    <button class="small" onclick="quantumRerunEnhancedOrchestrator()" style="background: var(--agent-nexus);">Rerun Enhanced</button>
                </div>
            `;

            this.agents.echo.innerHTML = `
                <div style="border-left: 3px solid var(--agent-nexus); padding-left: 10px; margin-bottom: 10px;">
                    <strong>Enhanced Quantum Consensus Complete</strong><br>
                    <small>Root Agent: ${consensus.rootAgent} | Score: ${consensus.score}</small><br>
                    <small>Entropy: ${consensus.avgEntropy} | Agents: ${consensus.agentCount} | Rounds: ${consensus.roundCount}</small>
                </div>
                <pre style="background: #1a1a1a; padding: 10px; border-radius: 4px; overflow: auto; max-height: 300px; border: 1px solid var(--agent-cognito);">${highlightedCode}</pre>
                ${quantumButtons}
            `;

            window.quantumConsensusCode = consensus.selectedCandidate;
        }

        async addLog(agent, message, type = 'info') {
            const logEl = this.logElements[agent];
            if (!logEl) return;

            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.innerHTML = `[${timestamp}] ${message}`;
            
            logEl.appendChild(logEntry);
            logEl.scrollTop = logEl.scrollHeight;

            this.agentCards[agent].classList.add('active');
            setTimeout(() => {
                this.agentCards[agent].classList.remove('active');
            }, 500);
        }

        async quantumOptimize() {
            const currentCode = quantumEditor.getContent();
            this.runEnhancedOrchestrator();
        }

        async quantumDocument() {
            const currentCode = quantumEditor.getContent();
            this.runEnhancedOrchestrator();
        }

        async quantumRefactor() {
            const currentCode = quantumEditor.getContent();
            this.runEnhancedOrchestrator();
        }
    }

    // Global functions
    function quantumCopyEnhancedConsensus() {
        if (window.quantumConsensusCode) {
            navigator.clipboard.writeText(window.quantumConsensusCode).then(() => {
                quantumNotify('Enhanced consensus code copied to clipboard!', 'success');
            });
        }
    }

    function quantumApplyEnhancedConsensus() {
        if (window.quantumConsensusCode) {
            quantumEditor.setContent(window.quantumConsensusCode, quantumEditor.currentFileType);
            quantumNotify('Enhanced consensus code applied!', 'success');
        }
    }

    function quantumRerunEnhancedOrchestrator() {
        enhancedOrchestrator.runEnhancedOrchestrator();
    }

    function quantumNotify(message, type = 'info') {
        const notification = document.createElement('div');
        notification.textContent = message;
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${type === 'success' ? 'var(--accent)' : 
                        type === 'warn' ? 'var(--warn-bg)' : 
                        type === 'error' ? 'var(--err)' : 'var(--info)'};
            color: ${type === 'warn' ? '#3a3c31' : 'white'};
            padding: 10px 15px;
            border-radius: 4px;
            z-index: 1000;
            font-size: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        `;
        document.body.appendChild(notification);

        setTimeout(() => {
            document.body.removeChild(notification);
        }, 3000);
    }

    // Initialize the application
    let quantumEditor;
    let enhancedOrchestrator;
    let memoryManager;

    document.addEventListener('DOMContentLoaded', () => {
        try {
            memoryManager = new QuantumMemoryManager();
            quantumEditor = new QuantumEditor();
            enhancedOrchestrator = new EnhancedQuantumOrchestrator();
            
            initQuantumFileHandling();
            initQuantumAI();
            initQuantumPreview();
            initQuantumLeftPanel();
            initQuantumQuickActions();
            
            quantumNotify('Quantum Fractal AI Editor Ready', 'success');
        } catch (error) {
            console.error('Initialization failed:', error);
            quantumNotify('Initialization failed - check console', 'error');
        }
    });

    // Global error handler
    window.addEventListener('error', (event) => {
        console.error('Global error:', event.error);
        if (memoryManager) {
            memoryManager.emergencyCleanup();
        }
    });

    // File handling functions
    function initQuantumFileHandling() {
        document.getElementById('open-file').addEventListener('click', () => {
            document.getElementById('file-input').click();
        });

        document.getElementById('file-input').addEventListener('change', handleFileOpen);
        document.getElementById('save-file').addEventListener('click', quantumSaveFile);
        document.getElementById('save-as').addEventListener('click', quantumSaveAsFile);
    }

    function handleFileOpen(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(ev) {
            const fileName = file.name;
            const fileType = quantumEditor.highlighter.detectLanguage(fileName);
            const content = ev.target.result;

            quantumEditor.setContent(content, fileType);
            document.getElementById('file-meta').textContent = fileName;
            quantumEditor.currentFileName = fileName;

            // Add to recent files
            memoryManager.addRecentFile(fileName, content);
        };
        reader.readAsText(file);
    }

    function quantumSaveFile() {
        if (!quantumEditor.currentFileName) {
            quantumSaveAsFile();
            return;
        }

        const blob = new Blob([quantumEditor.getContent()], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = quantumEditor.currentFileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        
        quantumNotify('File saved successfully', 'success');
    }

    function quantumSaveAsFile() {
        const fileName = prompt('Enter file name:', quantumEditor.currentFileName || 'quantum_code.js');
        if (fileName) {
            quantumEditor.currentFileName = fileName;
            const fileType = quantumEditor.highlighter.detectLanguage(fileName);
            quantumEditor.setContent(quantumEditor.getContent(), fileType);
            document.getElementById('file-meta').textContent = fileName;
            quantumSaveFile();
        }
    }

    // AI functionality
    function initQuantumAI() {
        document.getElementById('send-button').addEventListener('click', runQuantumAI);
        document.getElementById('run-local-ai').addEventListener('click', runQuantumAI);

        document.getElementById('prompt-input').addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                runQuantumAI();
            }
        });

        document.getElementById('close-ai-panel').addEventListener('click', () => {
            document.getElementById('ai-response-panel').style.display = 'none';
        });
    }

    function runQuantumAI() {
        const promptInput = document.getElementById('prompt-input');
        const prompt = promptInput.value.trim();
        if (!prompt) return;

        if (quantumEditor.multiAgentMode) {
            enhancedOrchestrator.runEnhancedOrchestrator();
        } else {
            quantumNotify('Enhanced orchestration required for full functionality', 'warn');
        }
        promptInput.value = '';
    }

    // Preview functionality
    function initQuantumPreview() {
        document.getElementById('btn-render').addEventListener('click', renderQuantumHTML);
        document.getElementById('render-html').addEventListener('click', renderQuantumHTML);

        document.getElementById('close-preview').addEventListener('click', () => {
            document.getElementById('preview-panel').style.display = 'none';
            const previewContent = document.getElementById('preview-content');
            if (previewContent.src.startsWith('blob:')) {
                URL.revokeObjectURL(previewContent.src);
            }
        });
    }

    function renderQuantumHTML() {
        try {
            const blob = new Blob([quantumEditor.getContent()], { type: 'text/html' });
            const previewContent = document.getElementById('preview-content');
            previewContent.src = URL.createObjectURL(blob);
            document.getElementById('preview-panel').style.display = 'flex';
        } catch (e) {
            alert('Quantum rendering error: ' + e.message);
        }
    }

    // Left panel functionality
    function initQuantumLeftPanel() {
        document.getElementById('left-toggle').addEventListener('click', () => {
            const isOpen = document.getElementById('editor-stage').classList.toggle('left-panel-open');
            document.getElementById('left-toggle').textContent = isOpen ? '✕' : '☰';
        });

        document.getElementById('btn-undo').addEventListener('click', () => quantumEditor.undo());
        document.getElementById('btn-redo').addEventListener('click', () => quantumEditor.redo());
        document.getElementById('btn-beautify').addEventListener('click', () => quantumEditor.beautifyCode());
    }

    // Quick actions
    function initQuantumQuickActions() {
        document.getElementById('btn-optimize').addEventListener('click', () => enhancedOrchestrator.quantumOptimize());
        document.getElementById('btn-document').addEventListener('click', () => enhancedOrchestrator.quantumDocument());
        document.getElementById('btn-refactor').addEventListener('click', () => enhancedOrchestrator.quantumRefactor());
    }

</script>
</body>
</html>
