<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEXUS | Quantum AI Dashboard</title>

    <!-- External Dependencies -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chart.js/4.4.0/chart.min.js"></script>

    <!-- Prism.js Language Support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js"></script>
    
    <style>
        /* Custom Tailwind Configuration (for Inter font and basic styles) */
        :root {
            --primary-color: #00ffff;
            --background-color: #1a1a1a;
            --card-color: #2a2a2a;
            --text-color: #e0e0e0;

            /* Custom Syntax Highlighting Colors */
            --editor-keyword: #00ffff; /* Bright Cyan for Keywords */
            --editor-string: #90ee90;  /* Light Green for Strings */
            --editor-comment: #5a5a5a; /* Dark Gray for Comments */
            --editor-function: #ffa07a; /* Light Orange for Function Names */
            --editor-number: #dda0dd;  /* Light Magenta/Purple for Numbers/Booleans */
            --editor-punctuation: #e0e0e0; /* Default Text Color */
        }

        @keyframes glitch-text {
            0% { transform: translate(0); opacity: 1; }
            5% { transform: translate(-2px, 2px); opacity: 0.8; }
            10% { transform: translate(-5px, -5px); opacity: 0.9; }
            15% { transform: translate(3px, 3px); opacity: 0.7; }
            20% { transform: translate(0); opacity: 1; }
            100% { transform: translate(0); opacity: 1; }
        }

        @keyframes pulse-cyan {
            0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.4); }
            50% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.8); }
        }

        @keyframes rotate-slow {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .dashboard-container {
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: auto 1fr;
            min-height: 100vh;
        }
        
        @media (min-width: 1024px) {
            .dashboard-container {
                grid-template-columns: 2fr 1fr;
                grid-template-rows: auto 1fr;
            }
        }

        .card {
            background-color: var(--card-color);
            border: 1px solid #3a3a3a;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        .btn-primary {
            background-color: #00ffff;
            color: #1a1a1a;
            transition: all 0.2s;
            font-weight: 700;
        }

        .btn-primary:hover {
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
            background-color: #00e0e0;
        }

        .status-dot {
            animation: pulse-cyan 1.5s infinite;
        }

        /* Prism.js Overrides for Dark Theme */
        pre[class*="language-"] {
            /* Remove default Prism padding/margin/radius to fit the editor container */
            background: transparent !important;
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
            overflow: visible !important; /* Allow the content wrapper to handle scroll */
            white-space: pre !important;
            text-shadow: none; /* Helps with a cleaner look */
        }
        
        /* Custom styles for the editor container */
        #editor-content-wrapper {
            /* Scroll synchronization needs this to be the only scroll container */
            overflow-y: scroll;
        }

        #line-numbers {
            /* Hide the scrollbar on line numbers */
            overflow-y: hidden; 
            white-space: pre; /* Essential for line breaks to work */
            line-height: 1.5; /* Match pre/code line height */
        }

        #editor-content-wrapper pre {
            /* Apply padding only here */
            padding: 12px !important;
            line-height: 1.5; /* Match line-numbers line height */
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: var(--card-color);
        }
        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .glitch-active {
            animation: glitch-text 0.5s infinite;
        }

        /* 3D Background Styles */
        #quantum-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.2;
        }

        /* --- Custom Neon Syntax Highlighter (The 'Regex Mantra' Look) --- */
        .token.comment,
        .token.prolog,
        .token.doctype,
        .token.cdata {
            color: var(--editor-comment); /* Muted Gray */
        }

        .token.punctuation {
            color: var(--editor-punctuation); /* Default Text Color */
        }

        .token.namespace {
            opacity: .7;
        }

        .token.property,
        .token.tag,
        .token.boolean,
        .token.number,
        .token.constant,
        .token.symbol,
        .token.deleted {
            color: var(--editor-number); /* Magenta/Purple */
        }

        .token.selector,
        .token.attr-name,
        .token.string,
        .token.char,
        .token.builtin,
        .token.inserted {
            color: var(--editor-string); /* Light Green */
        }

        .token.operator,
        .token.entity,
        .token.url,
        .language-css .token.string,
        .style .token.string {
            color: var(--editor-punctuation); /* White */
        }

        .token.atrule,
        .token.attr-value,
        .token.keyword,
        .token.control-flow,
        .token.module,
        .token.important,
        .token.regex,
        .token.variable {
            color: var(--editor-keyword); /* Bright Cyan */
        }

        .token.function,
        .token.class-name,
        .token.script,
        .token.method {
            color: var(--editor-function); /* Light Orange */
        }

        .token.unit {
            color: #d8d8d8;
        }

        .token.bold {
            font-weight: bold;
        }
        .token.italic {
            font-style: italic;
        }
        .token.entity {
            cursor: help;
        }

        /* End Custom Neon Syntax Highlighter */

    </style>
</head>
<body class="antialiased">
    <div id="quantum-background"></div>

    <div class="dashboard-container relative z-10 p-4 lg:p-8 space-y-8">
        <!-- Main Content Area (Left/Top) -->
        <main class="lg:row-span-2 space-y-6">
            <header class="flex flex-col sm:flex-row justify-between items-start sm:items-center p-4 card rounded-lg sticky top-0 z-20">
                <h1 class="text-3xl font-extrabold text-white tracking-wider">
                    <span class="text-cyan-400">NEXUS</span> | Quantum AI Dashboard
                </h1>
                <div id="connection-status-container" class="mt-2 sm:mt-0 text-sm flex items-center space-x-2">
                    <!-- Status dot will be injected here -->
                </div>
            </header>

            <!-- Prompt & Input Area -->
            <section class="card p-6 rounded-lg space-y-4">
                <h2 class="text-xl font-semibold text-cyan-400">Command Input</h2>
                <div class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-3">
                    <input type="text" id="prompt-input" placeholder="e.g., Generate a Python script for binary search"
                           class="flex-grow p-3 bg-gray-700 text-white rounded-md border border-gray-600 focus:ring-cyan-500 focus:border-cyan-500 transition shadow-inner"
                           maxlength="200">
                    <button id="process-button" class="btn-primary p-3 rounded-md shadow-lg flex-shrink-0">
                        Process Command
                    </button>
                </div>
            </section>

            <!-- Code Output Area (New Structure with Line Numbers) -->
            <section class="card p-6 rounded-lg h-96 flex flex-col">
                <h2 class="text-xl font-semibold text-cyan-400 mb-4">Code Output (<span id="output-language">JS</span>)</h2>
                
                <!-- Editor Container (Flex-based Layout) -->
                <div id="editor-container" class="flex-grow flex border border-gray-600 rounded-lg overflow-hidden bg-[#101010] font-mono text-sm">
                    
                    <!-- Line Numbers (Static Column) -->
                    <div id="line-numbers" 
                         class="w-12 text-right p-3 pr-2 text-gray-500 bg-[#151515] select-none border-r border-gray-700">
                        1
                    </div>
                    
                    <!-- Editor Content (Scrollable Column) -->
                    <div id="editor-content-wrapper" 
                         class="flex-grow overflow-auto" 
                         onscroll="document.getElementById('line-numbers').scrollTop = this.scrollTop;">
                        
                        <pre class="h-full"><code id="code-output" class="language-javascript">
// Results from the Quantum Consensus Core will appear here.
// Press 'Process Command' to start the generation.

class Example {
    constructor() {
        this.status = "Ready";
    }
}
                        </code></pre>
                    </div>
                </div>
            </section>
        </main>

        <!-- Sidebar / Metrics Area (Right/Bottom) -->
        <aside class="lg:row-span-2 space-y-6">
            <!-- Processing Indicator -->
            <div id="processing-indicator" class="card p-4 rounded-lg hidden">
                <div class="flex items-center space-x-3">
                    <div class="w-5 h-5 border-2 border-cyan-400 border-t-transparent rounded-full animate-spin"></div>
                    <div>
                        <p class="text-sm font-bold text-cyan-400">Processing...</p>
                        <p id="processing-status" class="text-xs text-gray-400"></p>
                    </div>
                </div>
            </div>

            <!-- Quantum Results -->
            <section class="card p-6 rounded-lg space-y-4">
                <h2 class="text-xl font-semibold text-cyan-400">Quantum Consensus</h2>
                <div class="text-sm space-y-2">
                    <p class="flex justify-between items-center"><span class="font-bold">Genesis Hash:</span> <span id="genesis-hash" class="font-mono text-xs text-gray-400 truncate">N/A</span></p>
                    <p class="flex justify-between items-center"><span class="font-bold">Consensus Hash:</span> <span id="consensus-hash" class="font-mono text-xs text-cyan-400 truncate">N/A</span></p>
                    <p class="flex justify-between items-center"><span class="font-bold">Agents Count:</span> <span id="agents-count" class="font-mono text-cyan-400">0</span></p>
                </div>
            </section>

            <!-- Performance Metrics (Live) -->
            <section class="card p-6 rounded-lg space-y-4">
                <h2 class="text-xl font-semibold text-cyan-400 flex justify-between items-center">
                    <span>Performance Metrics</span>
                    <button id="toggle-metrics" class="text-xs text-gray-500 hover:text-cyan-400 transition">
                        LIVE
                    </button>
                </h2>
                <div class="text-sm space-y-2">
                    <p class="flex justify-between"><span class="text-gray-400">Latency:</span> <span id="metric-latency" class="font-mono">...ms</span></p>
                    <p class="flex justify-between"><span class="text-gray-400">Throughput:</span> <span id="metric-throughput" class="font-mono">...ops/s</span></p>
                    <p class="flex justify-between"><span class="text-gray-400">Quantum Fidelity:</span> <span id="metric-fidelity" class="font-mono">...%</span></p>
                    <div class="h-40">
                        <canvas id="performanceChart"></canvas>
                    </div>
                </div>
            </section>

            <!-- Activity Log -->
            <section class="card p-6 rounded-lg space-y-4">
                <h2 class="text-xl font-semibold text-cyan-400">Activity Log</h2>
                <ul id="activity-log" class="text-sm max-h-60 overflow-y-auto space-y-3">
                    <!-- Activity items will be injected here -->
                    <li class="p-2 bg-gray-700/50 rounded-md flex justify-between items-center text-xs">
                        <span class="text-gray-400">System Initialized</span>
                        <span class="text-cyan-400" data-timestamp>Just now</span>
                    </li>
                </ul>
            </section>

            <!-- Notification Container -->
            <div id="notification-container" class="fixed bottom-4 right-4 z-50 space-y-2">
                <!-- Notifications will be injected here -->
            </div>
        </aside>
    </div>

    <script>
        // Set up the Tailwind configuration to use the Inter font
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'cyan': {
                            400: '#00ffff',
                            500: '#00e0e0',
                        },
                        'gray': {
                            700: 'var(--card-color)',
                            800: 'var(--background-color)',
                        }
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['Consolas', 'Monaco', 'monospace'],
                        orbitron: ['Orbitron', 'sans-serif'] // For special console logs
                    }
                }
            }
        }

        // --- 3D Quantum Background ---
        class QuantumBackground {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.container = document.getElementById('quantum-background');
                this.particles = [];
                this.mouse = new THREE.Vector2();
                this.targetRotation = 0;

                this.init();
                window.addEventListener('resize', this.onWindowResize.bind(this));
                document.addEventListener('mousemove', this.onMouseMove.bind(this));
                document.addEventListener('touchmove', this.onTouchMove.bind(this));
            }

            init() {
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.container.appendChild(this.renderer.domElement);

                this.camera.position.z = 50;

                const particleCount = 100;
                const particleGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });

                for (let i = 0; i < particleCount; i++) {
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.position.x = (Math.random() - 0.5) * 100;
                    particle.position.y = (Math.random() - 0.5) * 100;
                    particle.position.z = (Math.random() - 0.5) * 100;
                    particle.userData.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.05,
                        (Math.random() - 0.5) * 0.05,
                        (Math.random() - 0.5) * 0.05
                    );
                    this.scene.add(particle);
                    this.particles.push(particle);
                }

                this.animate();
            }

            onWindowResize() {
                this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
            }

            onMouseMove(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                this.targetRotation = this.mouse.x * 0.005;
            }

            onTouchMove(event) {
                if (event.touches.length > 0) {
                    this.mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
                    this.targetRotation = this.mouse.x * 0.005;
                }
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));

                // Rotate the scene slowly
                this.scene.rotation.y += (this.targetRotation - this.scene.rotation.y) * 0.05;
                this.scene.rotation.x += (-this.mouse.y * 0.005 - this.scene.rotation.x) * 0.05;

                // Animate particles
                this.particles.forEach(p => {
                    p.position.add(p.userData.velocity);
                    // Wrap around
                    if (p.position.x > 50 || p.position.x < -50) p.userData.velocity.x *= -1;
                    if (p.position.y > 50 || p.position.y < -50) p.userData.velocity.y *= -1;
                    if (p.position.z > 50 || p.position.z < -50) p.userData.velocity.z *= -1;
                });

                this.renderer.render(this.scene, this.camera);
            }
        }

        // --- Agent Definitions ---
        const AGENTS = [
            { id: 'CODE_GEN_V8', reason: (prompt, seed) => `console.log('Generated code for: ${prompt.substring(0, 20)}...');\nfunction run() {\n    // Core logic here\n    const value = Math.floor(seed * 1000);\n    for (let i = 0; i < value; i++) {\n        // Heavy computation loop simulation\n        if (i % 100 === 0) console.log('Processing step', i);\n    }\n    return value;\n}\n\n/*\n * Agent: CODE_GEN_V8\n * Seed: ${seed.toFixed(8)}\n */` },
            { id: 'SECURITY_SCAN', reason: (prompt, seed) => `/*\n * Security Check: Passed.\n * Hash Integrity Score: ${seed.toFixed(6)}\n * Block-seed: ${seed.toFixed(6)}\n */` },
            { id: 'OPTIMIZATION_L4', reason: (prompt, seed) => `// Runtime optimized.\n// This block represents the post-optimization meta-code.\n// Optimization score: ${seed.toFixed(8)}` }
        ];

        // --- Quantum Entropy + Hash Consensus Core (v1.0 - 2025) ---
        
        /**
         * index.js â€” Quantum Entropy + Hash Consensus Core
         * v1.0 â€” 2025
         *
         * Provides:
         * - createGenesisHash(prompt)
         * - deriveOriginHash(agentId, genesisHash, payload)
         * - computeConsensus(agents, genesisHash, prompt)
         * - entropy utilities
         */
        
        async function getLocalEntropyBits(size = 32) {
          const buffer = new Uint8Array(size);
          crypto.getRandomValues(buffer);
          return buffer;
        }

        async function sha256hex(data) {
          const msgBuffer = new TextEncoder().encode(data);
          const hashBuffer = await crypto.subtle.digest("SHA-256", msgBuffer);
          return Array.from(new Uint8Array(hashBuffer))
            .map(b => b.toString(16).padStart(2, "0"))
            .join("");
        }

        // -- Hash Chain Functions --

        async function createGenesisHash(prompt = "GENESIS") {
          const entropy = await getLocalEntropyBits();
          const entropyHex = Array.from(entropy)
            .map(b => b.toString(16).padStart(2, "0"))
            .join("");
          const composite = `${prompt}:${entropyHex}:${Date.now()}`;
          return sha256hex(composite);
        }

        async function deriveOriginHash(agentId, genesisHash, payload = "") {
          const entropy = await getLocalEntropyBits(16);
          const entropyHex = Array.from(entropy)
            .map(b => b.toString(16).padStart(2, "0"))
            .join("");
          const composite = `${genesisHash}:${agentId}:${entropyHex}:${payload}:${Date.now()}`;
          return sha256hex(composite);
        }

        async function computeConsensus(agents, genesisHash, prompt = "") {
          const results = [];

          for (const agent of agents) {
            // Check if agent.reason is a function before calling
            const reasonFunc = agent.reason instanceof Function ? agent.reason : () => null; 
            
            const originHash = await deriveOriginHash(agent.id, genesisHash, prompt);
            const seedValue = parseInt(originHash.slice(0, 8), 16) / 0xffffffff;
            const output = reasonFunc(prompt, seedValue);

            results.push({
              agent: agent.id,
              hash: originHash,
              seed: seedValue,
              output
            });
          }

          // Consensus is a hash of all agent origin hashes (deterministic)
          const merged = results.map(r => r.hash).join("");
          const consensusHash = await sha256hex(merged);

          return { consensusHash, results };
        }

        // Utility to simulate one-shot full pipeline + Orchestrator Event Dispatch
        async function runEntropyConsensus(prompt, agents) {
          console.info(`[EntropyHashCore] Starting consensus for prompt: "${prompt.substring(0, 30)}..."`);
          const genesisHash = await createGenesisHash(prompt);
          const consensus = await computeConsensus(agents, genesisHash, prompt);

          const result = {
            genesisHash,
            consensusHash: consensus.consensusHash,
            agents: consensus.results
          };

          // New Orchestrator: Dispatch custom event after consensus is reached
          document.dispatchEvent(
            new CustomEvent("quantum-consensus-update", {
              detail: result
            })
          );

          return result;
        }

        console.info("%c[EntropyHashCore] Loaded successfully.", "color:#00ffff;font-family:Orbitron;");
        // --- End Quantum Entropy + Hash Consensus Core ---


        // --- NEXUS Dashboard Class ---

        class NexusDashboard {
            constructor() {
                this.promptInput = document.getElementById('prompt-input');
                this.processButton = document.getElementById('process-button');
                this.codeOutputElement = document.getElementById('code-output');
                this.outputLanguageElement = document.getElementById('output-language');
                this.genesisHashElement = document.getElementById('genesis-hash');
                this.consensusHashElement = document.getElementById('consensus-hash');
                this.agentsCountElement = document.getElementById('agents-count');
                this.activityLog = document.getElementById('activity-log');
                this.processingIndicator = document.getElementById('processing-indicator');
                this.processingStatus = document.getElementById('processing-status');
                this.metricLatency = document.getElementById('metric-latency');
                this.metricThroughput = document.getElementById('metric-throughput');
                this.metricFidelity = document.getElementById('metric-fidelity');
                this.toggleMetricsButton = document.getElementById('toggle-metrics');

                // NEW ELEMENTS FOR EDITOR
                this.lineNumbersElement = document.getElementById('line-numbers');
                this.editorContentWrapper = document.getElementById('editor-content-wrapper');

                this.isLive = true;
                this.chart = this.createPerformanceChart();

                this.createNotificationContainer();
                this.createConnectionStatus();
                this.setupEventListeners();
                this.startLiveUpdates();
            }

            setupEventListeners() {
                this.processButton.addEventListener('click', () => this.processPrompt(this.promptInput.value));
                this.promptInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.processPrompt(this.promptInput.value);
                    }
                });
                this.toggleMetricsButton.addEventListener('click', this.toggleLiveMetrics.bind(this));

                // Listener for the core orchestrator event
                document.addEventListener("quantum-consensus-update", (event) => this.handleConsensusUpdate(event));
            }

            /**
             * Handles the custom event dispatched by the core logic.
             * This acts as the final orchestrator step to update the UI.
             */
            handleConsensusUpdate(event) {
                const { genesisHash, consensusHash, agents } = event.detail;
                const promptText = this.promptInput.value;
                
                // 1. Display the quantum results (Hashes/Seeds)
                this.displayQuantumResult(event.detail);

                // 2. Prepare Code Output from Agent Outputs
                const codeOutput = agents.map(agent => 
                    `// ------------------------------------------------------------------------------------------------\n// Agent: ${agent.agent} | Hash: ${agent.hash.substring(0, 16)}... | Seed: ${agent.seed.toFixed(8)}\n// ------------------------------------------------------------------------------------------------\n${agent.output || '// No specific code generated or payload returned.'}\n\n`
                ).join('');

                // Determine language based on prompt (simplistic)
                const language = this.determineLanguage(promptText);
                this.updateCodeOutput(codeOutput, language);
                
                // 3. Update Activity Log
                this.addActivityItem({
                    time: new Date(),
                    prompt: promptText.substring(0, 50) + '...',
                    agentCount: agents.length,
                    consensusHash: consensusHash.substring(0, 10) + '...',
                    status: 'Consensus Reached'
                });

                this.showNotification("Consensus Reached! Quantum Core output generated.", 'success');
                this.hideProcessingIndicator();
            }

            async processPrompt(prompt) {
                if (!prompt) {
                    this.showNotification("Please enter a command to process.", 'warning');
                    return;
                }

                this.showProcessingIndicator({ prompt, status: 'Initializing Quantum Core...' });

                try {
                    await runEntropyConsensus(prompt, AGENTS);
                } catch (error) {
                    console.error("Consensus Core Error:", error);
                    this.showNotification(`Error during core processing: ${error.message}`, 'error');
                }
            }

            // Utility to infer language from a prompt (used for Prism.js highlighting)
            determineLanguage(prompt) {
                const languageMap = [
                    ['python', /python|script|pandas|numpy/i],
                    ['java', /java|class|interface|maven/i],
                    ['html', /html|webpage|css|tailwind/i],
                    ['javascript', /javascript|js|node|react/i]
                ];
                
                const detected = languageMap
                    .filter(([lang, pattern]) => pattern.test(prompt))
                    .map(([lang]) => lang);
                
                return detected.length > 0 ? detected[0] : 'javascript';
            }

            showProcessingIndicator(data) {
                this.processingIndicator.classList.remove('hidden');
                this.processingStatus.textContent = data.status;
                gsap.to(this.processButton, { duration: 0.1, scale: 0.95 });
                // Note: glitch-active is applied to the section *container* in the original logic, 
                // but I'll update it to apply to the new editor-container for a better effect
                document.getElementById('editor-container').classList.add('glitch-active'); 
            }

            hideProcessingIndicator() {
                this.processingIndicator.classList.add('hidden');
                gsap.to(this.processButton, { duration: 0.2, scale: 1 });
                document.getElementById('editor-container').classList.remove('glitch-active');
            }

            displayQuantumResult(data) {
                this.genesisHashElement.textContent = data.genesisHash;
                this.consensusHashElement.textContent = data.consensusHash;
                this.agentsCountElement.textContent = data.agents.length;
            }

            /**
             * Renders code, generates line numbers, and applies syntax highlighting.
             */
            updateCodeOutput(result, language = 'javascript') {
                // Determine the number of lines (handle edge case of empty content)
                const lines = result ? result.split('\n').length : 1; 
                
                // 1. Generate Line Numbers Content (1, 2, 3, 4, ... joined by newline)
                const lineNumberContent = Array.from({ length: lines }, (_, i) => i + 1).join('\n');
                this.lineNumbersElement.textContent = lineNumberContent;

                // 2. Update Code Content
                this.codeOutputElement.textContent = result;
                
                // 3. Highlight
                this.codeOutputElement.className = `language-${language}`;
                this.outputLanguageElement.textContent = language.toUpperCase();
                Prism.highlightElement(this.codeOutputElement);

                // Reset scroll position to top
                this.editorContentWrapper.scrollTop = 0;
            }

            createPerformanceChart() {
                const ctx = document.getElementById('performanceChart').getContext('2d');
                return new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Throughput (ops/s)',
                            data: [],
                            borderColor: 'rgb(0, 255, 255)',
                            backgroundColor: 'rgba(0, 255, 255, 0.2)',
                            tension: 0.3,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { color: 'var(--text-color)' }
                            },
                            x: {
                                grid: { display: false },
                                ticks: { color: 'var(--text-color)', maxTicksLimit: 5 }
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: { mode: 'index', intersect: false }
                        }
                    }
                });
            }

            updateLiveMetrics() {
                if (!this.isLive) return;

                const latency = (Math.random() * 50 + 20).toFixed(0); // 20-70ms
                const throughput = (Math.random() * 500 + 1000).toFixed(0); // 1000-1500 ops/s
                const fidelity = (Math.random() * 5 + 95).toFixed(2); // 95-100%

                this.metricLatency.textContent = `${latency}ms`;
                this.metricThroughput.textContent = `${throughput} ops/s`;
                this.metricFidelity.textContent = `${fidelity}%`;

                // Update Chart
                const now = new Date().toLocaleTimeString();
                this.chart.data.labels.push(now);
                this.chart.data.datasets[0].data.push(throughput);

                // Keep only the last 15 data points
                const maxPoints = 15;
                if (this.chart.data.labels.length > maxPoints) {
                    this.chart.data.labels.shift();
                    this.chart.data.datasets[0].data.shift();
                }

                this.chart.update('quiet');
            }

            startLiveUpdates() {
                this.updateLiveMetrics();
                this.updateActivityTimes();
                setInterval(this.updateLiveMetrics.bind(this), 2000);
                setInterval(this.updateActivityTimes.bind(this), 60000); // Update times every minute
            }

            toggleLiveMetrics() {
                this.isLive = !this.isLive;
                this.toggleMetricsButton.textContent = this.isLive ? 'LIVE' : 'PAUSED';
                this.toggleMetricsButton.classList.toggle('text-cyan-400', this.isLive);
                this.toggleMetricsButton.classList.toggle('text-red-400', !this.isLive);
                this.showNotification(`Live Metrics ${this.isLive ? 'Enabled' : 'Paused'}`, 'info');
            }

            addActivityItem(activity) {
                const time = activity.time.toLocaleTimeString();
                const li = document.createElement('li');
                li.className = 'p-2 bg-gray-700/50 rounded-md flex justify-between items-start text-xs hover:bg-gray-700 transition duration-150';
                li.innerHTML = `
                    <div class="flex flex-col">
                        <span class="text-white font-mono">${activity.consensusHash}</span>
                        <span class="text-gray-400">${activity.prompt}</span>
                    </div>
                    <div class="flex flex-col items-end">
                        <span class="text-cyan-400 font-bold">${activity.status}</span>
                        <span class="text-gray-500" data-timestamp="${activity.time.toISOString()}">${time}</span>
                    </div>
                `;
                if (this.activityLog.firstChild) {
                    this.activityLog.insertBefore(li, this.activityLog.firstChild);
                } else {
                    this.activityLog.appendChild(li);
                }
            }

            updateActivityTimes() {
                this.activityLog.querySelectorAll('[data-timestamp]').forEach(el => {
                    const timestamp = el.getAttribute('data-timestamp');
                    const date = new Date(timestamp);
                    const diffMinutes = Math.floor((new Date() - date) / 60000);
                    
                    let timeText;
                    if (diffMinutes === 0) {
                        timeText = 'Just now';
                    } else if (diffMinutes < 60) {
                        timeText = `${diffMinutes} min ago`;
                    } else if (diffMinutes < 1440) {
                        const diffHours = Math.floor(diffMinutes / 60);
                        timeText = `${diffHours} hr ago`;
                    } else {
                        timeText = date.toLocaleDateString();
                    }
                    el.textContent = timeText;
                });
            }

            createConnectionStatus() {
                const container = document.getElementById('connection-status-container');
                container.innerHTML = `
                    <span id="status-dot" class="status-dot w-3 h-3 rounded-full bg-cyan-400 inline-block"></span>
                    <span id="status-text" class="text-white font-mono">ONLINE</span>
                `;
            }

            updateConnectionStatus(connected) {
                const dot = document.getElementById('status-dot');
                const text = document.getElementById('status-text');
                
                if (connected) {
                    dot.className = 'status-dot w-3 h-3 rounded-full bg-cyan-400 inline-block';
                    text.textContent = 'ONLINE';
                    text.classList.remove('text-red-400');
                    text.classList.add('text-white');
                } else {
                    dot.className = 'w-3 h-3 rounded-full bg-red-400 inline-block';
                    text.textContent = 'DISCONNECTED';
                    text.classList.remove('text-white');
                    text.classList.add('text-red-400');
                }
            }

            createNotificationContainer() {
                // Ensure container is created if it doesn't exist (though it's in HTML)
                if (!document.getElementById('notification-container')) {
                    const div = document.createElement('div');
                    div.id = 'notification-container';
                    div.className = 'fixed bottom-4 right-4 z-50 space-y-2';
                    document.body.appendChild(div);
                }
            }

            showNotification(message, type = 'info') {
                const container = document.getElementById('notification-container');
                const div = document.createElement('div');
                
                let bgColor, icon;
                if (type === 'success') {
                    bgColor = 'bg-green-600';
                    icon = 'âœ“';
                } else if (type === 'warning') {
                    bgColor = 'bg-yellow-600';
                    icon = 'âš ';
                } else if (type === 'error') {
                    bgColor = 'bg-red-600';
                    icon = 'âœ–';
                } else {
                    bgColor = 'bg-blue-600';
                    icon = 'i';
                }

                div.className = `${bgColor} text-white p-3 rounded-lg shadow-xl flex items-center space-x-2 transition-all duration-300 ease-in-out transform translate-x-full`;
                div.innerHTML = `<span class="font-bold">${icon}</span> <span>${message}</span>`;
                
                container.appendChild(div);

                // Animate in
                setTimeout(() => {
                    div.style.transform = 'translateX(0)';
                }, 10);

                // Animate out and remove
                setTimeout(() => {
                    div.style.transform = 'translateX(120%)';
                    div.style.opacity = '0';
                    setTimeout(() => {
                        container.removeChild(div);
                    }, 300);
                }, 5000);
            }
        }

        // Initialize everything when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new QuantumBackground();
            window.nexusDashboard = new NexusDashboard();
            Prism.highlightAll();
            console.log('ðŸš€ NEXUS Quantum AI Dashboard initialized');
        });
    </script>
</body>
</html>


