<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ollama Hashing-Index Model-Pool Orchestrator</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --primary-color: #00aaff;
            --secondary-color: #2a2a2a;
            --border-color: #444;
            --success-color: #00ffaa;
            --error-color: #ff4444;
            --font-family: 'Courier New', Courier, monospace;
        }
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            flex-grow: 1;
        }
        header {
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }
        header h1 {
            color: var(--primary-color);
            margin: 0;
            font-size: 1.8em;
            text-shadow: 0 0 5px var(--primary-color);
        }
        header p {
            font-size: 0.9em;
            opacity: 0.7;
        }
        .controls {
            display: flex;
            gap: 15px;
            align-items: stretch;
        }
        textarea, input, button {
            background-color: var(--secondary-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            font-family: var(--font-family);
        }
        textarea {
            flex-grow: 1;
            resize: vertical;
            height: 80px;
        }
        button {
            cursor: pointer;
            background-color: var(--primary-color);
            color: var(--bg-color);
            font-weight: bold;
            border: none;
            transition: background-color 0.3s, transform 0.1s;
        }
        button:hover {
            background-color: #33bbff;
        }
        button:active {
            transform: scale(0.98);
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr 2fr;
            gap: 20px;
            flex-grow: 1;
        }
        .panel {
            background-color: var(--secondary-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .panel h2 {
            margin-top: 0;
            color: var(--primary-color);
            font-size: 1.2em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }
        .log-area {
            flex-grow: 1;
            overflow-y: auto;
            font-size: 0.8em;
            white-space: pre-wrap;
            word-break: break-all;
        }
        #thinking-stream .log-entry {
            margin-bottom: 5px;
            opacity: 0.8;
        }
        #final-answer-container code {
            color: var(--success-color);
            white-space: pre-wrap;
            word-break: break-word;
        }
        .agent-list {
            list-style: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
        }
        .agent-item {
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            border-left: 3px solid var(--border-color);
            font-size: 0.8em;
            transition: background-color 0.3s, border-color 0.3s;
        }
        .agent-item.thinking {
            border-left-color: var(--primary-color);
            animation: pulse 1.5s infinite;
        }
        .agent-item.success {
            border-left-color: var(--success-color);
        }
        .agent-item .agent-id {
            font-weight: bold;
        }
        .agent-item .agent-hash {
            font-size: 0.8em;
            opacity: 0.6;
            display: block;
            word-break: break-all;
        }
        @keyframes pulse {
            0% { background-color: rgba(0, 170, 255, 0.1); }
            50% { background-color: rgba(0, 170, 255, 0.2); }
            100% { background-color: rgba(0, 170, 255, 0.1); }
        }
    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1>Ollama Hashing-Index Orchestrator</h1>
            <p>A fractal-based, hyperthreaded reasoning simulation for collective problem-solving.</p>
        </header>

        <div class="controls">
            <textarea id="natural-prompt" placeholder="Enter natural language prompt... e.g., 'function to sort an array'"></textarea>
            <button id="start-button">Initiate Reasoning</button>
        </div>

        <div class="main-content">
            <div class="panel">
                <h2>Agents</h2>
                <ul id="agent-status-list" class="agent-list"></ul>
            </div>
            <div class="panel">
                <h2>Thinking Stream</h2>
                <div id="thinking-stream" class="log-area"></div>
            </div>
            <div class="panel">
                <h2>Final Answer</h2>
                <pre id="final-answer-container" class="log-area"><code>Waiting for solution...</code></pre>
            </div>
        </div>
    </div>

    <script>
        const AGENT_KEYWORDS = ['core', 'loop', '2244', 'coin', 'code'];
        const AGENT_COUNT = AGENT_KEYWORDS.length;

        // This string will be converted into a Blob and used as the source for our Web Workers.
        const workerScript = `
            // --- Hashing and Utility Functions (inside worker) ---
            async function sha256(str) {
                const buffer = new TextEncoder().encode(str);
                const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            function calculateEntropy(str) {
                if (!str) return 0;
                const freq = {};
                for (let i = 0; i < str.length; i++) {
                    const char = str[i];
                    freq[char] = (freq[char] || 0) + 1;
                }
                let entropy = 0;
                const len = str.length;
                for (let char in freq) {
                    const p = freq[char] / len;
                    entropy -= p * Math.log2(p);
                }
                return entropy;
            }

            // --- Agent State (inside worker) ---
            let agentId, originHash, genesisHash;
            let memoryCounter = 0;
            let sharedAnswer = null;
            
            // --- Core Agent Logic (inside worker) ---

            // Step 5 & 7: Rehash origin-hash with genesis-hash and adapt based on shared answers
            async function rehashState(data) {
                memoryCounter++;
                let combined = originHash + genesisHash + memoryCounter + data;
                if(sharedAnswer) {
                    combined += sharedAnswer.finalHash;
                }
                return await sha256(combined);
            }

            // Step 4 & 6: Fractal-based reasoning on chunks
            async function processChunk(chunk) {
                postMessage({ type: 'log', agentId, message: \`Processing chunk: "\${chunk.substring(0,20)}..."\` });
                
                // Simulate fractal processing by breaking it down
                let processedData = '';
                let subChunks = chunk.split('').map(c => c + agentId.split('-')[1]); // Simple transformation
                
                for (const sub of subChunks) {
                    // Simulate complex math/logic
                    await new Promise(resolve => setTimeout(resolve, 10 + Math.random() * 20));
                    processedData += sub;
                }
                
                // Enhance script logic - a simple heuristic
                if (processedData.includes('function') || processedData.includes('=>') || processedData.includes('const') || processedData.includes('let')) {
                    processedData = \`// Agent \${agentId} Enhancement\\n\${processedData.trim()}\\n\`;
                } else {
                    processedData = \`// Agent \${agentId} Analysis\\n// Data: \${processedData.trim()}\\n\`;
                }

                const rehashedState = await rehashState(processedData);
                const entropy = calculateEntropy(processedData);
                const validatedHash = await sha256(processedData);

                postMessage({ type: 'log', agentId, message: \`Chunk entropy: \${entropy.toFixed(4)}\` });
                
                // Randomly decide if this agent found "the" answer
                if (Math.random() > 0.95 && !sharedAnswer) {
                     postMessage({
                        type: 'final_answer_found',
                        payload: {
                            finderId: agentId,
                            finalHash: rehashedState,
                            answer: "A pivotal discovery was made, converging all reasoning.",
                            contributingChunks: [], // In a real scenario, this would be populated
                        }
                    });
                }

                return {
                    id: 'chunk-' + Date.now() + '-' + Math.random(),
                    data: processedData,
                    originHash: originHash,
                    rehash: rehashedState,
                    entropy: entropy,
                    sha256: validatedHash,
                    agentId: agentId
                };
            }
            
            self.onmessage = async (e) => {
                const { type, payload } = e.data;
                switch (type) {
                    case 'init':
                        agentId = payload.agentId;
                        originHash = payload.originHash;
                        genesisHash = payload.genesisHash;
                        postMessage({ type: 'log', agentId, message: 'Initialized and ready.' });
                        break;
                    case 'start_reasoning':
                        postMessage({ type: 'status_update', agentId, status: 'thinking' });
                        const processedChunks = [];
                        for (const chunk of payload.tokenPool) {
                             if(sharedAnswer) { // Acceleration
                                postMessage({ type: 'log', agentId, message: 'Accelerating due to shared answer.' });
                                await new Promise(r => setTimeout(r, 50)); // Shorter delay
                             }
                            const result = await processChunk(chunk);
                            processedChunks.push(result);
                        }
                        postMessage({ type: 'chunks_processed', agentId, payload: processedChunks });
                        postMessage({ type: 'status_update', agentId, status: 'idle' });
                        break;
                    case 'share_answer':
                        if(!sharedAnswer) {
                            sharedAnswer = payload.answer;
                            postMessage({ type: 'log', agentId, message: \`Received shared answer from \${payload.finderId}. Adapting...\` });
                        }
                        break;
                }
            };
        `;

        class Orchestrator {
            constructor() {
                this.promptInput = document.getElementById('natural-prompt');
                this.startButton = document.getElementById('start-button');
                this.agentStatusList = document.getElementById('agent-status-list');
                this.thinkingStream = document.getElementById('thinking-stream');
                this.finalAnswerContainer = document.getElementById('final-answer-container');
                
                this.agents = [];
                this.genesisHash = null;
                this.eventStack = [];
                this.collectedChunks = [];
                this.finalAnswerFound = false;
                this.workerBlob = new Blob([workerScript], { type: 'application/javascript' });

                this.startButton.addEventListener('click', () => this.start());
            }

            logToStream(message) {
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                entry.textContent = `[${new Date().toISOString()}] ${message}`;
                this.thinkingStream.prepend(entry);
                // Step 8: Store in browser-storage (sessionStorage for simplicity)
                const currentStream = sessionStorage.getItem('realstream-thinking') || '';
                sessionStorage.setItem('realstream-thinking', `${entry.textContent}\\n${currentStream}`);
            }

            updateAgentStatus(agentId, status, originHash = null) {
                let agentItem = document.getElementById(`agent-${agentId}`);
                if (!agentItem) {
                    agentItem = document.createElement('li');
                    agentItem.id = `agent-${agentId}`;
                    agentItem.className = 'agent-item';
                    agentItem.innerHTML = `<span class="agent-id">${agentId}</span><span class="agent-hash">Origin: ${originHash.substring(0, 16)}...</span>`;
                    this.agentStatusList.appendChild(agentItem);
                }
                agentItem.classList.remove('thinking', 'success');
                if (status === 'thinking') {
                    agentItem.classList.add('thinking');
                } else if (status === 'success') {
                    agentItem.classList.add('success');
                }
            }

            async init() {
                this.resetState();
                
                // 1. Generate and share genesis-hash
                this.genesisHash = await this.sha256(`genesis-${Date.now()}`);
                this.logToStream(`Genesis Hash generated: ${this.genesisHash}`);
                
                for (let i = 0; i < AGENT_COUNT; i++) {
                    const agentId = `${AGENT_KEYWORDS[i]}-${i}`;
                    
                    // 2. Generate a genesis-based origin-hash for each agent
                    const originHash = await this.sha256(`${this.genesisHash}-${agentId}`);
                    
                    const worker = new Worker(URL.createObjectURL(this.workerBlob));
                    worker.onmessage = (e) => this.handleWorkerMessage(e);
                    
                    worker.postMessage({ 
                        type: 'init', 
                        payload: { agentId, originHash, genesisHash: this.genesisHash }
                    });
                    
                    this.agents.push({ id: agentId, worker, originHash });
                    this.updateAgentStatus(agentId, 'idle', originHash);
                }
            }
            
            resetState() {
                this.agents.forEach(agent => agent.worker.terminate());
                this.agents = [];
                this.collectedChunks = [];
                this.eventStack = [];
                this.finalAnswerFound = false;
                this.agentStatusList.innerHTML = '';
                this.thinkingStream.innerHTML = '';
                this.finalAnswerContainer.innerHTML = '<code>Waiting for solution...</code>';
                sessionStorage.removeItem('realstream-thinking');
            }

            async start() {
                const prompt = this.promptInput.value.trim();
                if (!prompt) {
                    alert('Please enter a prompt.');
                    return;
                }
                this.startButton.disabled = true;
                await this.init();

                // 3. Parse prompt and setup timestamp-indexer
                this.logToStream(`Processing prompt: "${prompt}"`);
                const timestamp = Date.now();
                this.eventStack.push({ timestamp, type: 'start_process', prompt });

                const tokenPool = prompt.split(/\s+/).filter(Boolean);
                
                this.agents.forEach(agent => {
                    agent.worker.postMessage({
                        type: 'start_reasoning',
                        payload: { tokenPool }
                    });
                });
            }

            handleWorkerMessage(event) {
                const { type, agentId, message, payload, status } = event.data;
                switch (type) {
                    case 'log':
                        this.logToStream(`[${agentId}]: ${message}`);
                        break;
                    case 'status_update':
                        this.updateAgentStatus(agentId, status);
                        break;
                    case 'chunks_processed':
                        this.collectedChunks.push(...payload);
                        this.checkForCompletion();
                        break;
                    case 'final_answer_found':
                        if (!this.finalAnswerFound) {
                            this.finalAnswerFound = true;
                            this.logToStream(`>>> FINAL ANSWER FOUND by ${payload.finderId} <<<`);
                            this.updateAgentStatus(payload.finderId, 'success');
                            // 7. Adapt collected hashes and accelerate thinking
                            this.agents.forEach(agent => {
                                if (agent.id !== payload.finderId) {
                                    agent.worker.postMessage({ type: 'share_answer', payload: { finderId: payload.finderId, answer: payload }});
                                }
                            });
                        }
                        break;
                }
            }

            checkForCompletion() {
                // Consider complete when all agents have submitted their chunks.
                const totalAgents = this.agents.length;
                const contributingAgents = new Set(this.collectedChunks.map(c => c.agentId));
                if (contributingAgents.size === totalAgents) {
                    this.assembleFinalAnswer();
                }
            }
            
            // 9 & 10. Source final-answer by assembling chunks based on entropy
            assembleFinalAnswer() {
                this.logToStream('All agents completed reasoning. Assembling final answer...');
                
                if (this.collectedChunks.length === 0) {
                    this.finalAnswerContainer.innerHTML = '<code>No valid logic chunks were generated.</code>';
                    this.startButton.disabled = false;
                    return;
                }
                
                // Use highest entropy to sort chunks
                this.collectedChunks.sort((a, b) => b.entropy - a.entropy);
                
                // Cyclic method: ensure at least one chunk from each agent is near the top if possible
                let assembledCode = `// Genesis Hash: ${this.genesisHash}\n// Assembled from ${this.collectedChunks.length} logic chunks with highest entropy.\n\n`;
                const seenAgents = new Set();
                let finalChunks = [];

                // Prioritize unique agents first
                for(const chunk of this.collectedChunks){
                    if(!seenAgents.has(chunk.agentId)){
                        finalChunks.push(chunk);
                        seenAgents.add(chunk.agentId);
                    }
                }
                // Add remaining chunks
                for(const chunk of this.collectedChunks){
                    if(!finalChunks.find(c => c.id === chunk.id)){
                        finalChunks.push(chunk);
                    }
                }

                finalChunks.forEach(chunk => {
                    // Simple SHA256 validation simulation
                    this.sha256(chunk.data).then(hash => {
                        if (hash === chunk.sha256) {
                            assembledCode += `/* --- Chunk from ${chunk.agentId} | Entropy: ${chunk.entropy.toFixed(4)} --- */\n`;
                            assembledCode += chunk.data + '\n';
                        } else {
                            assembledCode += `/* --- INVALID CHUNK from ${chunk.agentId} (hash mismatch) --- */\n`;
                        }
                    });
                });

                // Final injection into editor
                this.finalAnswerContainer.innerHTML = `<code>${assembledCode}</code>`;
                this.logToStream('Final answer assembled and injected.');
                this.startButton.disabled = false;
                
                // Terminate workers after completion
                this.agents.forEach(agent => agent.worker.terminate());
            }

            async sha256(str) {
                const buffer = new TextEncoder().encode(str);
                const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new Orchestrator();
        });
    </script>
</body>
</html>
