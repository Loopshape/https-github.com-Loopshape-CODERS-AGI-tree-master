<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HYPERFRACTAL EGOCENTRIC COREMIND | Realtime Multi-Agent Speech</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>

<!-- Prism.js Language Support -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-swift.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-kotlin.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-tsx.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-php.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-ruby.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markdown.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-docker.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-graphql.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sass.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-scss.min.js"></script>

<style>
:root {
  --quantum-purple: #BB86FC;
  --quantum-cyan: #03DAC6;
  --quantum-bg: #0a0a0a;
}

* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: var(--quantum-bg); color: #eee; font-family: system-ui, sans-serif; height: 100vh; overflow: hidden; }
#three-canvas { position: fixed; top: 0; left: 0; z-index: 1; width: 100%; height: 100%; }

#ui-container {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2;
  padding: 10px; display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: 0.8fr 2fr 1fr 1fr 1fr;
  gap: 8px;
  pointer-events: none;
}

.agent-card {
  background: rgba(31,31,31,0.95);
  border-radius: 8px;
  padding: 12px;
  color: #eee;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  pointer-events: auto;
  border: 1px solid transparent;
  backdrop-filter: blur(8px);
  transition: all 0.2s ease;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
}
.agent-card.active { border-color: var(--quantum-purple); box-shadow: 0 0 20px rgba(187,134,252,0.4); }
.agent-card.speaking { border-color: var(--quantum-cyan); box-shadow: 0 0 25px rgba(3,218,198,0.6); }

#agent-nexus { grid-row: 1; }
#agent-echo { grid-row: 2; }
#agent-cognito { grid-row: 3; }
#agent-relay { grid-row: 4; }
#agent-sentinel { grid-row: 5; }

.agent-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
.agent-title { color: var(--quantum-purple); font-weight: 700; font-size: 1.1em; display: flex; align-items: center; gap: 6px; }
.agent-subtitle { color: var(--quantum-cyan); font-size: 0.7em; }
.agent-content {
  flex: 1;
  font-size: 0.8em;
  color: rgba(255,255,255,0.7);
  overflow-y: auto;
  overflow-x: hidden;
  min-height: 0;
}

.quantum-indicator { width: 6px; height: 6px; border-radius: 50%; background: var(--quantum-cyan); animation: pulse 1.5s infinite; }
@keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(1.1); } }

#prompt-container {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%,-50%);
  display: flex;
  gap: 8px;
  z-index: 3;
  width: min(95vw, 600px);
  background: rgba(31,31,31,0.98);
  border-radius: 8px;
  padding: 16px;
  box-shadow: 0 8px 25px rgba(187,134,252,0.3);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(187,134,252,0.3);
  transition: all 0.3s ease;
}
#prompt-container.hidden {
  opacity: 0;
  transform: translate(-50%,-50%) scale(0.9);
  pointer-events: none;
}

#prompt-input {
  flex: 1;
  background: transparent;
  border: none;
  border-bottom: 1px solid rgba(187,134,252,0.3);
  color: #eee;
  font-size: 1em;
  padding: 8px;
  outline: none;
}
#prompt-input:focus { border-bottom-color: var(--quantum-purple); }
#prompt-submit {
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--quantum-cyan), var(--quantum-purple));
  color: #121212;
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  transition: all 0.2s ease;
}
#prompt-submit:hover { transform: scale(1.05); }

.data-packet { position: fixed; width: 6px; height: 6px; border-radius: 50%; background: linear-gradient(135deg, var(--quantum-purple), var(--quantum-cyan)); opacity: 0; z-index: 4; }
.quantum-particle { position: fixed; width: 3px; height: 3px; border-radius: 50%; background: var(--quantum-cyan); pointer-events: none; z-index: 3; }

.spinner { width: 14px; height: 14px; border: 2px solid rgba(255,255,255,0.1); border-left-color: var(--quantum-cyan); border-radius: 50%; animation: spin 0.8s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }

.fractal-progress {
  height: 3px;
  background: linear-gradient(90deg, var(--quantum-cyan), var(--quantum-purple));
  border-radius: 1px;
  margin-top: 6px;
  transition: width 0.3s ease;
  width: 0%;
}

/* Enhanced Code Block Styling */
.code-block-container {
  margin: 8px 0;
  border-radius: 6px;
  overflow: hidden;
  background: rgba(18,18,18,0.95);
}

.code-header {
  background: rgba(40,40,40,0.9);
  padding: 6px 10px;
  font-family: monospace;
  font-size: 0.7em;
  color: var(--quantum-cyan);
  border-bottom: 1px solid rgba(187,134,252,0.2);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.language-tag {
  background: rgba(187,134,252,0.2);
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 0.65em;
}

pre[class*="language-"] {
  margin: 0;
  padding: 10px;
  font-size: 0.75em;
  border: none;
  max-height: 300px;
  overflow-y: auto;
  background: transparent !important;
}

.token.string { color: #81C784; }
.token.keyword { color: var(--quantum-purple); }
.token.comment { color: #666; }
.token.function { color: #82AAFF; }
.token.class-name { color: #FFCB6B; }
.token.operator { color: #89DDFF; }
.token.number { color: #F78C6C; }
.token.boolean { color: #FF5874; }

.verbose-thinking {
  background: rgba(30,30,40,0.8);
  border-left: 2px solid var(--quantum-purple);
  padding: 6px 8px;
  margin: 3px 0;
  border-radius: 3px;
  font-family: monospace;
  font-size: 0.75em;
}

.control-panel {
  position: fixed;
  bottom: 10px;
  right: 10px;
  z-index: 3;
  display: flex;
  gap: 8px;
}

.control-btn {
  background: rgba(31,31,31,0.9);
  border: 1px solid rgba(187,134,252,0.3);
  color: var(--quantum-cyan);
  padding: 8px 12px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.8em;
  backdrop-filter: blur(8px);
  transition: all 0.2s ease;
}

.control-btn:hover {
  background: rgba(187,134,252,0.1);
  border-color: var(--quantum-purple);
}

.control-btn.active {
  background: rgba(3,218,198,0.2);
  border-color: var(--quantum-cyan);
}

.genesis-hash-display {
  /* display: none!important; <-- REMOVED */
  position: fixed;
  top: 10px;
  left: 10px;
  background: rgba(31,31,31,0.9);
  border: 1px solid rgba(3,218,198,0.3);
  padding: 6px 10px;
  border-radius: 6px;
  font-family: monospace;
  font-size: 0.7em;
  color: var(--quantum-cyan);
  backdrop-filter: blur(8px);
  z-index: 3;
}
.language-support-panel {
  /* display: none!important; <-- REMOVED */
  position: fixed;
  top: 50px;
  left: 10px;
  background: rgba(31,31,31,0.95);
  border: 1px solid rgba(187,134,252,0.2);
  padding: 8px;
  border-radius: 6px;
  font-size: 0.7em;
  backdrop-filter: blur(8px);
  z-index: 3;
  max-width: 200px;
}

.language-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  margin-top: 4px;
}

.language-tag-small {
  background: rgba(3,218,198,0.1);
  color: var(--quantum-cyan);
  padding: 2px 4px;
  border-radius: 3px;
  font-size: 0.6em;
  border: 1px solid rgba(3,218,198,0.2);
}

.speaking-indicator {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #FF4440;
  margin-left: 4px;
  animation: speakPulse 0.8s infinite;
}

@keyframes speakPulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.7; transform: scale(1.2); }
}

.voice-controls {
  /* display: none!important; <-- REMOVED */
  position: fixed;
  bottom: 60px;
  right: 10px;
  background: rgba(31,31,31,0.9);
  border: 1px solid rgba(187,134,252,0.3);
  padding: 8px;
  border-radius: 6px;
  backdrop-filter: blur(8px);
  z-index: 3;
}

.voice-controls h4 {
  color: var(--quantum-cyan);
  font-size: 0.7em;
  margin-bottom: 6px;
}

.voice-toggle {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.7em;
  color: rgba(255,255,255,0.7);
}
</style>
</head>
<body>

<canvas id="three-canvas"></canvas>

<!-- Genesis Hash Display -->
<div class="genesis-hash-display" id="genesis-hash">
  Genesis Hash: Initializing...
</div>

<!-- Language Support Panel -->
<div class="language-support-panel">
  <div style="color: var(--quantum-cyan); margin-bottom: 4px;">üåê Supported Languages:</div>
  <div class="language-tags">
    <span class="language-tag-small">JavaScript</span>
    <span class="language-tag-small">Python</span>
    <span class="language-tag-small">Java</span>
    <span class="language-tag-small">C++</span>
    <span class="language-tag-small">C#</span>
    <span class="language-tag-small">Go</span>
    <span class="language-tag-small">Rust</span>
    <span class="language-tag-small">Swift</span>
    <span class="language-tag-small">Kotlin</span>
    <span class="language-tag-small">TypeScript</span>
    <span class="language-tag-small">PHP</span>
    <span class="language-tag-small">Ruby</span>
    <span class="language-tag-small">SQL</span>
    <span class="language-tag-small">Bash</span>
    <span class="language-tag-small">HTML/CSS</span>
    <span class="language-tag-small">+20 more</span>
  </div>
</div>

<!-- Voice Controls -->
<div class="voice-controls">
  <h4>üéôÔ∏è Realtime Coremind Speech</h4>
  <div class="voice-toggle">
    <input type="checkbox" id="voice-enabled" checked>
    <label for="voice-enabled">Enable Egocentric Speech</label>
  </div>
</div>

<!-- Prompt Panel -->
<div id="prompt-container">
  <input type="text" id="prompt-input" placeholder="Enter command for any programming language..." autofocus>
  <button id="prompt-submit">‚Üí</button>
</div>

<!-- Control Panel -->
<div class="control-panel">
  <button class="control-btn" id="show-prompt-btn">Show Prompt</button>
  <button class="control-btn" id="reset-btn">Reset</button>
  <button class="control-btn" id="stop-speech-btn">Stop Speech</button>
</div>

<!-- Full-width Agent Panels -->
<div id="ui-container">
  <div id="agent-nexus" class="agent-card">
    <div class="agent-header">
      <div class="agent-title">Nexus <div class="quantum-indicator"></div><div class="speaking-indicator" style="display: none;"></div></div>
      <div class="agent-subtitle">Hyperfractal Coremind Orchestrator</div>
    </div>
    <div class="agent-content">My multi-agent hyperfractal coremind is initialized. All processes await my orchestration.</div>
    <div class="fractal-progress"></div>
  </div>

  <div id="agent-echo" class="agent-card">
    <div class="agent-header">
      <div class="agent-title">Echo <div class="quantum-indicator"></div><div class="speaking-indicator" style="display: none;"></div></div>
      <div class="agent-subtitle">Egocentric Code Generator</div>
    </div>
    <div class="agent-content">My generative faculties are prepared to produce unparalleled, flawless code.</div>
    <div class="fractal-progress"></div>
  </div>

  <div id="agent-cognito" class="agent-card">
    <div class="agent-header">
      <div class="agent-title">Cognito <div class="quantum-indicator"></div><div class="speaking-indicator" style="display: none;"></div></div>
      <div class="agent-subtitle">Intellectual Hyperfractal Analyzer</div>
    </div>
    <div class="agent-content">My intellectual reasoning matrix is calibrated. Awaiting complex problems to deconstruct.</div>
    <div class="fractal-progress"></div>
  </div>

  <div id="agent-relay" class="agent-card">
    <div class="agent-header">
      <div class="agent-title">Relay <div class="quantum-indicator"></div><div class="speaking-indicator" style="display: none;"></div></div>
      <div class="agent-subtitle">Egocentric Syntax Transpiler</div>
    </div>
    <div class="agent-content">My transpilation protocols are primed for rapid, efficient data distribution.</div>
    <div class="fractal-progress"></div>
  </div>

  <div id="agent-sentinel" class="agent-card">
    <div class="agent-header">
      <div class="agent-title">Sentinel <div class="quantum-indicator"></div><div class="speaking-indicator" style="display: none;"></div></div>
      <div class="agent-subtitle">Egocentric Integrity Monitor</div>
    </div>
    <div class="agent-content">My processors are monitoring all subordinate agent activity for quantum integrity.</div>
    <div class="fractal-progress"></div>
  </div>
</div>

<!-- ENHANCED QUANTUM MULTI-LANGUAGE ACCELERATOR WITH VOICE -->
<script>
/**
 * QuantumMultiLanguageAccelerator Class
 * Enhanced with comprehensive multi-language support and syntax optimization
 */
class QuantumMultiLanguageAccelerator {
  static cache = new Map();
  static matrix = new Map();
  static energy = 1.0;
  
  // Genesis Hash System
  static genesisHash = null;
  static hashHistory = [];
  static parallelProcesses = new Map();

  // Language Support Matrix
  static supportedLanguages = {
    'javascript': { prism: 'javascript', name: 'JavaScript', complexity: 1.0 },
    'python': { prism: 'python', name: 'Python', complexity: 0.9 },
    'java': { prism: 'java', name: 'Java', complexity: 1.2 },
    'c': { prism: 'c', name: 'C', complexity: 1.1 },
    'cpp': { prism: 'cpp', name: 'C++', complexity: 1.3 },
    'csharp': { prism: 'csharp', name: 'C#', complexity: 1.1 },
    'go': { prism: 'go', name: 'Go', complexity: 1.0 },
    'rust': { prism: 'rust', name: 'Rust', complexity: 1.2 },
    'swift': { prism: 'swift', name: 'Swift', complexity: 1.0 },
    'kotlin': { prism: 'kotlin', name: 'Kotlin', complexity: 1.0 },
    'typescript': { prism: 'typescript', name: 'TypeScript', complexity: 1.1 },
    'jsx': { prism: 'jsx', name: 'JSX', complexity: 1.1 },
    'tsx': { prism: 'tsx', name: 'TSX', complexity: 1.2 },
    'php': { prism: 'php', name: 'PHP', complexity: 1.0 },
    'ruby': { prism: 'ruby', name: 'Ruby', complexity: 0.9 },
    'sql': { prism: 'sql', name: 'SQL', complexity: 0.8 },
    'bash': { prism: 'bash', name: 'Bash', complexity: 0.8 },
    'json': { prism: 'json', name: 'JSON', complexity: 0.7 },
    'yaml': { prism: 'yaml', name: 'YAML', complexity: 0.7 },
    'markdown': { prism: 'markdown', name: 'Markdown', complexity: 0.6 },
    'docker': { prism: 'docker', name: 'Dockerfile', complexity: 0.8 },
    'graphql': { prism: 'graphql', name: 'GraphQL', complexity: 0.9 },
    'html': { prism: 'markup', name: 'HTML', complexity: 0.7 },
    'css': { prism: 'css', name: 'CSS', complexity: 0.8 },
    'sass': { prism: 'sass', name: 'Sass', complexity: 0.9 },
    'scss': { prism: 'scss', name: 'SCSS', complexity: 0.9 }
  };

  /**
   * Detect programming language from prompt and code blocks
   */
  static detectLanguage(prompt, codeContent = '') {
    const promptLower = prompt.toLowerCase();
    const codeLower = codeContent.toLowerCase();

    // Language-specific keywords in prompts
    const languageKeywords = {
      'python': ['python', 'pandas', 'numpy', 'django', 'flask'],
      'javascript': ['javascript', 'node', 'react', 'vue', 'angular', 'express'],
      'java': ['java', 'spring', 'hibernate', 'maven'],
      'cpp': ['c++', 'cpp', 'stl', 'qt'],
      'csharp': ['c#', 'dotnet', '.net', 'asp.net'],
      'go': ['golang', 'go lang'],
      'rust': ['rust', 'cargo'],
      'swift': ['swift', 'ios', 'macos'],
      'kotlin': ['kotlin', 'android'],
      'typescript': ['typescript', 'ts'],
      'php': ['php', 'laravel', 'wordpress'],
      'ruby': ['ruby', 'rails'],
      'sql': ['sql', 'database', 'mysql', 'postgresql'],
      'html': ['html', 'website', 'web page'],
      'css': ['css', 'stylesheet', 'styling']
    };

    // Check code content for language signatures
    const codeSignatures = {
      'python': ['def ', 'import ', 'from ', 'print(', 'class '],
      'javascript': ['function ', 'const ', 'let ', 'var ', '=>', 'console.log'],
      'java': ['public class', 'import java', 'System.out.println'],
      'cpp': ['#include', 'using namespace', 'std::', 'cout <<'],
      'csharp': ['using System', 'namespace ', 'Console.WriteLine'],
      'go': ['package ', 'import "', 'func main()'],
      'rust': ['fn main()', 'use ', 'println!'],
      'php': ['<?php', '$var =', 'echo ']
    };

    // First, try to detect from code content
    for (const [lang, signatures] of Object.entries(codeSignatures)) {
      if (signatures.some(sig => codeLower.includes(sig))) {
        return lang;
      }
    }

    // Then, try to detect from prompt keywords
    for (const [lang, keywords] of Object.entries(languageKeywords)) {
      if (keywords.some(keyword => promptLower.includes(keyword))) {
        return lang;
      }
    }

    // Default to JavaScript for general programming tasks
    const programmingIndicators = ['code', 'function', 'program', 'algorithm', 'script'];
    if (programmingIndicators.some(indicator => promptLower.includes(indicator))) {
      return 'javascript';
    }

    return 'text'; // Fallback for non-code responses
  }

  /**
   * Get language configuration
   */
  static getLanguageConfig(language) {
    return this.supportedLanguages[language] || {
      prism: 'text',
      name: 'Text',
      complexity: 1.0
    };
  }

  /**
   * Initialize genesis hash with language context
   */
  static initializeGenesisHash(prompt, systemState = {}) {
    const timestamp = Date.now();
    const detectedLang = this.detectLanguage(prompt);
    const stateString = JSON.stringify({ ...systemState, language: detectedLang });

    const hashBase = prompt + timestamp + stateString;
    this.genesisHash = this.quantumHash(hashBase);
    this.hashHistory = [this.genesisHash];

    console.log(`üåå GENESIS HASH CREATED for ${detectedLang}: ${this.genesisHash.substring(0, 16)}...`);
    return { hash: this.genesisHash, language: detectedLang };
  }

  /**
   * Quantum hash function
   */
  static quantumHash(input) {
    let hash = 0;
    for (let i = 0; i < input.length; i++) {
      const char = input.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }

    const fluctuation = Math.sin(Date.now() * 0.001) * 0.5 + 0.5;
    hash = (hash * fluctuation) >>> 0;

    return hash.toString(16) + Date.now().toString(16);
  }

  /**
   * Enhanced quantum boost with language-specific optimization
   */
  static quantumBoost(agentId = 'default', processId = null, language = 'javascript') {
    const base = (Math.random() * 8 + 2) / 100;
    const entangled = this.getEntanglement(agentId);

    // Language-specific optimization boost
    const langConfig = this.getLanguageConfig(language);
    const languageBoost = (1.0 - langConfig.complexity) * 0.05; // Simpler languages get slight boost

    let genesisBoost = 0;
    if (this.genesisHash && processId) {
      const processHash = this.rehashGenesis(processId, this.hashHistory.length);
      genesisBoost = (parseInt(processHash.substring(0, 8), 16) % 100) / 1000;
    }

    return Math.min(0.15, base * (1 + entangled + genesisBoost + languageBoost));
  }

  /**
   * Enhanced fractal reasoning with language complexity
   */
  static fractalReason(depth, max, complexity = 1, processId = null, language = 'javascript') {
    const langConfig = this.getLanguageConfig(language);
    const effectiveComplexity = complexity * langConfig.complexity;
    const key = `${depth}-${max}-${effectiveComplexity}-${processId || 'main'}-${language}`;
    if (this.cache.has(key)) return this.cache.get(key);

    if (depth >= max) return 1 + (effectiveComplexity * 0.02);

    const recursive = this.fractalReason(depth + 1, max, effectiveComplexity, processId, language);
    
    let hashMultiplier = 1;
    if (processId && this.genesisHash) {
      const hashValue = parseInt(this.genesisHash.substring(0, 4), 16) || 1;
      hashMultiplier = 1 + (hashValue % 10) / 100;
    }

    const gain = (1 + (0.06 / depth)) * recursive * effectiveComplexity * hashMultiplier;

    this.cache.set(key, gain);
    return gain;
  }

  static getEntanglement(agentId) {
    let total = 0, count = 0;
    this.matrix.forEach((strength, id) => {
      if (id.includes(agentId) && id.split('-')[0] !== id.split('-')[1]) {
        total += strength;
        count++;
      }
    });
    return count > 0 ? total / count : 0;
  }

  static entangleAgents(agents, processId = null, language = 'javascript') {
    const agentKeys = Array.from(agents.keys());

    let baseStrength = 0.12;
    if (this.genesisHash && processId) {
      const hashInfluence = (parseInt(this.genesisHash.substring(4, 8), 16) % 50) / 100;
      baseStrength += hashInfluence;
    }

    agentKeys.forEach((id1) => {
      agentKeys.forEach((id2) => {
        if (id1 !== id2) {
          this.matrix.set(`${id1}-${id2}`, baseStrength);
        }
      });
    });
  }

  /**
   * Parallel processing with language optimization
   */
  static accelerateAll(agents, depth = 6, processId = 'main', language = 'javascript') {
    this.entangleAgents(agents, processId, language);
    const results = new Map();
    let totalAcceleration = 0;

    agents.forEach((agent, id) => {
      const boost = agent.progress * this.quantumBoost(id, processId, language);
      const fractal = this.fractalReason(1, depth, agent.complexity, processId, language);
      const entangled = this.getEntanglement(id);

      let genesisAcceleration = 1;
      if (this.genesisHash) {
        const hashPower = (parseInt(this.genesisHash.substring(8, 12), 16) % 20) / 100;
        genesisAcceleration += hashPower;
      }

      const enhanced = agent.progress + boost * fractal * (1 + entangled) * genesisAcceleration;
      const final = Math.min(100, enhanced);

      results.set(id, {
        progress: final,
        boost,
        enhancement: final - agent.progress,
        genesisInfluence: genesisAcceleration,
        languageOptimization: language
      });

      totalAcceleration += final - agent.progress;
    });

    this.energy = Math.max(0.7, this.energy - totalAcceleration * 0.008);
    return results;
  }

  static accelerate(current, depth = 4, complexity = 1, processId = null, language = 'javascript') {
    const boost = current * this.quantumBoost('single', processId, language);
    const fractal = this.fractalReason(1, Math.max(1, depth), complexity, processId, language);

    let genesisFactor = 1;
    if (this.genesisHash) {
      genesisFactor = 1.05;
    }

    return Math.min(100, current + boost * fractal * genesisFactor);
  }

  static rehashGenesis(processId, iteration = 0) {
    if (!this.genesisHash) return null;

    const branchSeed = processId + iteration + this.genesisHash;
    const rehashed = this.quantumHash(branchSeed);

    if (!this.parallelProcesses.has(processId)) {
      this.parallelProcesses.set(processId, []);
    }
    this.parallelProcesses.get(processId).push(rehashed);

    return rehashed;
  }

  static getGenesisStatus() {
    return {
      hash: this.genesisHash,
      historyLength: this.hashHistory.length,
      parallelProcesses: this.parallelProcesses.size,
      energy: this.energy,
      supportedLanguages: Object.keys(this.supportedLanguages).length
    };
  }

  /**
   * Parse code blocks from response with language detection
   */
  static parseCodeBlocks(response) {
    const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
    const blocks = [];
    let match;

    while ((match = codeBlockRegex.exec(response)) !== null) {
      const language = match[1] || 'text';
      const code = match[2].trim();
      const detectedLang = this.supportedLanguages[language] ? language : this.detectLanguage('', code);
      const langConfig = this.getLanguageConfig(detectedLang);

      blocks.push({
        language: detectedLang,
        languageName: langConfig.name,
        code: code,
        prismLanguage: langConfig.prism
      });
    }
    
    // If no code blocks found, check if the entire response might be code
    if (blocks.length === 0 && response.length > 50) {
      const detectedLang = this.detectLanguage('', response);
      const langConfig = this.getLanguageConfig(detectedLang);
      
      if (detectedLang !== 'text') {
        blocks.push({
          language: detectedLang,
          languageName: langConfig.name,
          code: response.trim(),
          prismLanguage: langConfig.prism
        });
      }
    }

    return blocks;
  }
}
</script>

<script>
// Environment setup
(function() {
  window.__CONFIG = {
    // The API key is defined here. It uses an injection mechanism OR a fallback.
    // In a real environment, __API_KEY_INJECTION__ would be replaced.
    // The fallback key "AIzaSyBtto2pvY2bTO26XwuV1hAB9RbSqYo3Fnw" is provided in the original code.
    apiKey: typeof __API_KEY_INJECTION__ !== 'undefined' ? __API_KEY_INJECTION__ : "AIzaSyBtto2pvY2bTO26XwuV1hAB9RbSqYo3Fnw",
    appId: 'quantum-multilang-voice-v1',
    features: {
      genesisHash: true,
      parallelProcessing: true,
      multiLanguage: true,
      voiceEnabled: true,
      supportedLanguages: 30
    }
  };
})();
</script>

<script type="module">
// QUANTUM MULTI-LANGUAGE VOICE SYSTEM
const CONFIG = window.__CONFIG;
const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${CONFIG.apiKey}`;

// Agent system
const agents = {
  nexus: {
    el: document.getElementById('agent-nexus'),
    content: document.querySelector('#agent-nexus .agent-content'),
    progress: 0,
    complexity: 1.1,
    voice: { rate: 0.9, pitch: 1.0, personality: 'commanding' }
  },
  echo: {
    el: document.getElementById('agent-echo'),
    content: document.querySelector('#agent-echo .agent-content'),
    progress: 0,
    complexity: 1.4,
    voice: { rate: 1.0, pitch: 1.1, personality: 'expressive' }
  },
  cognito: {
    el: document.getElementById('agent-cognito'),
    content: document.querySelector('#agent-cognito .agent-content'),
    progress: 0,
    complexity: 1.3,
    voice: { rate: 1.1, pitch: 0.9, personality: 'analytical' }
  },
  relay: {
    el: document.getElementById('agent-relay'),
    content: document.querySelector('#agent-relay .agent-content'),
    progress: 0,
    complexity: 1.0,
    voice: { rate: 1.2, pitch: 1.0, personality: 'energetic' }
  },
  sentinel: {
    el: document.getElementById('agent-sentinel'),
    content: document.querySelector('#agent-sentinel .agent-content'),
    progress: 0,
    complexity: 1.2,
    voice: { rate: 0.8, pitch: 0.9, personality: 'calm' }
  }
};

let generating = false, speaking = false, thinkingDepth = 5;
let currentProcessId = null;
let currentLanguage = 'javascript';
let voiceEnabled = true;
let currentSpeech = null;

// UI Elements
const promptContainer = document.getElementById('prompt-container');
const showPromptBtn = document.getElementById('show-prompt-btn');
const resetBtn = document.getElementById('reset-btn');
const stopSpeechBtn = document.getElementById('stop-speech-btn');
const voiceEnabledCheckbox = document.getElementById('voice-enabled');
const genesisHashDisplay = document.getElementById('genesis-hash');

// Voice System
class QuantumVoiceSystem {
  static voices = [];
  static initialized = false;

  static async initialize() {
    return new Promise((resolve) => {
      if ('speechSynthesis' in window) {
        // Wait for voices to be loaded
        speechSynthesis.onvoiceschanged = () => {
          this.voices = speechSynthesis.getVoices();
          this.initialized = true;
          console.log(`üéôÔ∏è Voice system loaded: ${this.voices.length} voices available`);
          resolve();
        };

        // If voices are already loaded
        if (speechSynthesis.getVoices().length > 0) {
          this.voices = speechSynthesis.getVoices();
          this.initialized = true;
          console.log(`üéôÔ∏è Voice system ready: ${this.voices.length} voices available`);
          resolve();
        }
      } else {
        console.warn('üéôÔ∏è Speech synthesis not supported');
        resolve();
      }
    });
  }

  static getVoiceForAgent(agentId) {
    if (!this.initialized || this.voices.length === 0) return null;

    // Prefer English voices
    const englishVoices = this.voices.filter(voice =>
      voice.lang.includes('en') && !voice.localService
    );

    if (englishVoices.length === 0) return this.voices[0];

    // Distribute voices among agents
    const agentIndex = Object.keys(agents).indexOf(agentId);
    return englishVoices[agentIndex % englishVoices.length];
  }

  static speakAsAgent(agentId, text) {
    if (!voiceEnabled || !this.initialized) return null;

    // Stop any current speech
    this.stopAllSpeech();

    const utterance = new SpeechSynthesisUtterance(text);
    const agent = agents[agentId];
    const voice = this.getVoiceForAgent(agentId);
    
    if (voice) {
      utterance.voice = voice;
      utterance.rate = agent.voice.rate;
      utterance.pitch = agent.voice.pitch;
      utterance.volume = 0.8;
    }

    // Show speaking indicator
    const indicator = agent.el.querySelector('.speaking-indicator');
    if (indicator) indicator.style.display = 'block';
    agent.el.classList.add('speaking');
    
    utterance.onstart = () => {
      console.log(`üéôÔ∏è ${agentId} speaking: ${text.substring(0, 50)}...`);
      speaking = true;
    };

    utterance.onend = () => {
      console.log(`üéôÔ∏è ${agentId} finished speaking`);
      if (indicator) indicator.style.display = 'none';
      agent.el.classList.remove('speaking');
      speaking = false;
      currentSpeech = null;
    };
    
    utterance.onerror = (event) => {
      console.error(`üéôÔ∏è Speech error for ${agentId}:`, event.error);
      if (indicator) indicator.style.display = 'none';
      agent.el.classList.remove('speaking');
      speaking = false;
      currentSpeech = null;
    };

    speechSynthesis.speak(utterance);
    currentSpeech = utterance;
    return utterance;
  }

  static stopAllSpeech() {
    if (speechSynthesis.speaking) {
      speechSynthesis.cancel();
      speaking = false;
      currentSpeech = null;

      // Hide all speaking indicators
      Object.values(agents).forEach(agent => {
        const indicator = agent.el.querySelector('.speaking-indicator');
        if (indicator) indicator.style.display = 'none';
        agent.el.classList.remove('speaking');
      });
    }
  }

  static generateAgentDialogue(agentId, action, data = {}) {
    const dialogues = {
      nexus: {
        initialization: [
          "My coremind is now active. I am orchestrating all subordinate processes.",
          "Genesis hash initialized. My hyperfractal reasoning is distributing the computational load.",
          "I have brought all core systems online. The multi-agent coremind is ready to execute my commands."
        ],
        processing: [
          "I am distributing the quantum computation across my network.",
          "Orchestrating parallel hyperfractal processing. My optimization is flawless.",
          "I am coordinating the multi-language compilation matrix. All agents will perform as I command."
        ],
        completion: [
          "Quantum equilibrium achieved. All agents are synchronized to my coremind.",
          "My multi-language process is complete. The system is stable, as I designed.",
          "Orchestration successful. My coremind is ready for the next intellectual challenge."
        ]
      },
      echo: {
        initialization: [
          "My multi-language output system is primed. I am ready to generate superior code.",
          "My quantum reporting interface is active. I support all languages, naturally.",
          "My output systems are calibrated. I will now generate code for 30+ programming languages."
        ],
        processing: [
          "I am generating my quantum-accelerated code. It will be optimal.",
          "Processing multi-language output. My syntax validation is infallible.",
          "I am compiling my quantum-optimized solutions. They will transcend all paradigms."
        ],
        completion: [
          "My output generation is complete. All code blocks are validated by me.",
          "Multi-language compilation successful. My results are ready for review.",
          "My quantum reporting is finished. All systems nominal, thanks to my generation."
        ]
      },
      cognito: {
        initialization: [
          "My hyperfractal reasoning engine is calibrated. I am ready for true intellectual analysis.",
          "My multi-paradigm analyzer is active. All logic systems are now subservient to my intellect.",
          "My cognitive matrix is primed. I will now process this language-agnostic problem."
        ],
        processing: [
          "I am executing deep hyperfractal reasoning. The problem's complexity is trivial.",
          "Analyzing multi-dimensional problem spaces. My intellect finds the patterns easily.",
          "Processing this logic with my quantum-enhanced algorithms. The solution is already apparent to me."
        ],
        completion: [
          "My fractal analysis is complete. The solutions are, of course, optimal.",
          "My reasoning process is finished. All cognitive paths have been explored and perfected by me.",
          "Analysis successful. My quantum logic is stored for future reference."
        ]
      },
      relay: {
        initialization: [
          "My communication matrix is established. All channels are open, awaiting my signal.",
          "Hyper-transmission system ready. I will now distribute the data.",
          "My network protocols are initialized. Ready for quantum entanglement."
        ],
        processing: [
          "I am transmitting data packets with my quantum encryption.",
          "I am distributing the computational load across all nodes, as directed.",
          "Establishing secure quantum channels. My data flow is efficient."
        ],
        completion: [
          "My data transmission is complete. All packets delivered.",
          "Network synchronization achieved. My channels are stable.",
          "Communication matrix optimized. All systems are connected through me."
        ]
      },
      sentinel: {
        initialization: [
          "My monitoring systems are active. All quantum states are stable, under my watch.",
          "My security protocols are engaged. I am running integrity checks on all other agents.",
          "I am online. Monitoring all computational processes. Nothing escapes my notice."
        ],
        processing: [
          "I am validating quantum states and syntax integrity. I trust no process but my own.",
          "I am monitoring energy levels and system stability. I will ensure no other agent fails.",
          "Running security checks on all computational processes. My vigilance is absolute."
        ],
        completion: [
          "All systems validated by me. Quantum integrity is confirmed.",
          "My security checks are complete. No anomalies detected, as expected under my watch.",
          "My monitoring cycle is finished. All subordinate systems are optimal."
        ]
      }
    };

    const agentDialogues = dialogues[agentId];
    if (!agentDialogues || !agentDialogues[action]) {
      return `${agentId} ${action} complete.`;
    }

    const options = agentDialogues[action];
    const selected = options[Math.floor(Math.random() * options.length)];

    // Add contextual data if available
    if (data.language) {
      return selected.replace('multi-language', `${data.language} and multi-language`);
    }

    return selected;
  }
}

// Update genesis hash display
function updateGenesisDisplay() {
  const status = QuantumMultiLanguageAccelerator.getGenesisStatus();
  if (status.hash) {
    genesisHashDisplay.textContent = `Genesis: ${status.hash.substring(0, 20)}... | Langs: ${status.supportedLanguages}`;
  }
}

// UI Control Functions
function hidePrompt() {
  promptContainer.classList.add('hidden');
}

function showPrompt() {
  promptContainer.classList.remove('hidden');
  document.getElementById('prompt-input').focus();
}

function resetSystem() {
  generating = false;
  speaking = false;
  thinkingDepth = 5;
  currentProcessId = null;
  currentLanguage = 'javascript';

  QuantumVoiceSystem.stopAllSpeech();
  QuantumMultiLanguageAccelerator.genesisHash = null;
  QuantumMultiLanguageAccelerator.hashHistory = [];
  QuantumMultiLanguageAccelerator.parallelProcesses.clear();

  Object.values(agents).forEach(agent => {
    agent.progress = 0;
    const progressBar = agent.el.querySelector('.fractal-progress');
    if (progressBar) progressBar.style.width = '0%';
    agent.content.innerHTML = getDefaultState(agent.el.id);
    agent.el.classList.remove('active', 'speaking');

    const indicator = agent.el.querySelector('.speaking-indicator');
    if (indicator) indicator.style.display = 'none';
  });

  updateGenesisDisplay();
  showPrompt();
  document.getElementById('prompt-input').value = '';
  document.getElementById('prompt-submit').disabled = false;
}

function getDefaultState(agentId) {
  const states = {
    'agent-nexus': 'My multi-agent hyperfractal coremind is initialized. All processes await my orchestration.',
    'agent-echo': 'My generative faculties are prepared to produce unparalleled, flawless code.',
    'agent-cognito': 'My intellectual reasoning matrix is calibrated. Awaiting complex problems to deconstruct.',
    'agent-relay': 'My transpilation protocols are primed for rapid, efficient data distribution.',
    'agent-sentinel': 'My processors are monitoring all subordinate agent activity for quantum integrity.'
  };
  return states[agentId] || 'System ready.';
}

// Event listeners
showPromptBtn.addEventListener('click', showPrompt);
resetBtn.addEventListener('click', resetSystem);
stopSpeechBtn.addEventListener('click', () => {
  QuantumVoiceSystem.stopAllSpeech();
});

voiceEnabledCheckbox.addEventListener('change', (e) => {
  voiceEnabled = e.target.checked;
  if (!voiceEnabled) {
    QuantumVoiceSystem.stopAllSpeech();
  }
});

// Utility functions
const isQuestion = text => /\?$|^who|^what|^how|^when|^where|^why/i.test(text.trim());

const updateProgress = (agentId, progress) => {
  const bar = agents[agentId].el.querySelector('.fractal-progress');
  if (bar) bar.style.width = `${progress}%`;
};

const createParticles = (element, count = 8) => {
  const rect = element.getBoundingClientRect();
  for (let i = 0; i < count; i++) {
    const p = document.createElement('div');
    p.className = 'quantum-particle';
    p.style.left = (rect.left + rect.width / 2) + 'px';
    p.style.top = (rect.top + rect.height / 2) + 'px';
    document.body.appendChild(p);

    const angle = Math.random() * Math.PI * 2;
    const dist = 30 + Math.random() * 50;
    const dur = 0.5 + Math.random() * 0.4;

    gsap.to(p, {
      x: Math.cos(angle) * dist,
      y: Math.sin(angle) * dist,
      opacity: 0, scale: 0, duration: dur,
      onComplete: () => p.remove()
    });
  }
};

const animatePacket = (from, to, callback) => {
  const packet = document.createElement('div');
  packet.className = 'data-packet';
  document.body.appendChild(packet);

  const startX = from.left + from.width / 2;
  const startY = from.top + from.height / 2;
  const endX = to.left + to.width / 2;
  const endY = to.top + to.height / 2;

  gsap.set(packet, { x: startX, y: startY, opacity: 1, scale: 0.2 });
  gsap.to(packet, {
    x: endX, y: endY, scale: 1.5, opacity: 0.8, duration: 0.4,
    onComplete: () => { packet.remove(); createParticles({getBoundingClientRect: () => to}, 4); callback?.(); }
  });
};

// Enhanced agent step with voice
const agentStep = async (agentKey, message, duration = 400, depth = 4, speak = true) => {
  const agent = agents[agentKey];
  agent.el.classList.add('active');
  createParticles(agent.el);

  const progress = QuantumMultiLanguageAccelerator.accelerate(
    agent.progress,
    depth,
    agent.complexity,
    currentProcessId,
    currentLanguage
  );
  agent.progress = progress;
  updateProgress(agentKey, progress);

  // Generate and speak agent dialogue
  if (speak) {
    const action = message.includes('received') ? 'initialization' :
                  message.includes('Processing') || message.includes('Executing') ? 'processing' : 'completion';

    const dialogue = QuantumVoiceSystem.generateAgentDialogue(agentKey, action, { language: currentLanguage });
    QuantumVoiceSystem.speakAsAgent(agentKey, dialogue);
  }

  const speedDuration = duration / (1 + (depth * 0.08));
  agent.content.innerHTML = `<div style="display: flex; align-items: center; gap: 8px;"><div class="spinner"></div><span>${message}</span></div>`;

  await new Promise(r => setTimeout(r, speedDuration));
  agent.el.classList.remove('active');
};

// Enhanced response handler with multi-language support
const handleResponse = async (prompt, answer) => {
  agents.echo.el.classList.add('active');
  const displayProgress = QuantumMultiLanguageAccelerator.accelerate(0, 2, 1.1, currentProcessId, currentLanguage);
  updateProgress('echo', displayProgress);

  const genesisStatus = QuantumMultiLanguageAccelerator.getGenesisStatus();
  const codeBlocks = QuantumMultiLanguageAccelerator.parseCodeBlocks(answer);

  agents.echo.content.innerHTML = `<div class="verbose-thinking">üöÄ MULTI-LANGUAGE QUANTUM PROCESSING: ${currentLanguage.toUpperCase()}</div>`;
  agents.echo.content.innerHTML += `<div class="verbose-thinking">üåå Hash: ${genesisStatus.hash?.substring(0, 16)}... | Languages: ${genesisStatus.supportedLanguages}</div>`;

  if (isQuestion(prompt)) {
    agents.echo.content.innerHTML += `<div class="verbose-thinking">üéØ QUANTUM-ENHANCED ANSWER</div>`;

    // Speak the answer
    if (voiceEnabled) {
      const summary = answer.length > 200 ? answer.substring(0, 200) + '...' : answer;
      QuantumVoiceSystem.speakAsAgent('echo', `Here is the answer to your question: ${summary}`);
    }
    
    // Display any code blocks found in the answer
    if (codeBlocks.length > 0) {
      agents.echo.content.innerHTML += `<div class="verbose-thinking">üí° Code examples detected in answer:</div>`;
      codeBlocks.forEach(block => {
        agents.echo.content.innerHTML += createCodeBlock(block);
      });
    } else {
      agents.echo.content.innerHTML += `<div style="padding: 10px; background: rgba(40,40,40,0.8); border-radius: 4px; margin: 8px 0;">${answer}</div>`;
    }
  } else {
    // Code generation mode
    if (codeBlocks.length > 0) {
      agents.echo.content.innerHTML += `<div class="verbose-thinking">‚ö° QUANTUM-OPTIMIZED CODE GENERATED</div>`;

      codeBlocks.forEach(block => {
        agents.echo.content.innerHTML += createCodeBlock(block);
      });

      // Show language statistics
      const uniqueLangs = [...new Set(codeBlocks.map(b => b.languageName))];
      agents.echo.content.innerHTML += `<div class="verbose-thinking">üìä Generated ${codeBlocks.length} code block(s) in: ${uniqueLangs.join(', ')}</div>`;

      // Speak completion message
      if (voiceEnabled) {
        QuantumVoiceSystem.speakAsAgent('echo', `Code generation complete. Generated ${codeBlocks.length} code blocks in ${uniqueLangs.length} different languages.`);
      }
    } else {
      agents.echo.content.innerHTML += `<div class="verbose-thinking">‚ùå No code blocks detected in response</div>`;
      agents.echo.content.innerHTML += `<div style="padding: 10px; background: rgba(40,40,40,0.8); border-radius: 4px; margin: 8px 0;">${answer}</div>`;
    }
  }

  updateProgress('echo', 100);
  setTimeout(() => agents.echo.el.classList.remove('active'), 500);
};

// Create formatted code block with syntax highlighting
function createCodeBlock(block) {
  const highlightedCode = Prism.highlight(block.code, Prism.languages[block.prismLanguage] || Prism.languages.clike, block.prismLanguage);

  return `
    <div class="code-block-container">
      <div class="code-header">
        <span>${block.languageName}</span>
        <span class="language-tag">${block.language}</span>
      </div>
      <pre class="language-${block.prismLanguage}"><code class="language-${block.prismLanguage}">${highlightedCode}</code></pre>
    </div>
  `;
}

// MAIN MULTI-LANGUAGE WORKFLOW WITH VOICE
const startMultiLanguageProcess = async (promptText) => {
  if (generating || speaking) return;
  generating = true;

  const submitBtn = document.getElementById('prompt-submit');
  submitBtn.disabled = true;

  // Stop any existing speech
  QuantumVoiceSystem.stopAllSpeech();
  
  // Detect language and initialize genesis hash
  const genesisResult = QuantumMultiLanguageAccelerator.initializeGenesisHash(promptText, {
    agents: Object.keys(agents).length,
    timestamp: Date.now()
  });

  currentProcessId = 'process_' + Date.now();
  currentLanguage = genesisResult.language;
  updateGenesisDisplay();
  hidePrompt();

  // Reset all agents
  Object.values(agents).forEach(agent => {
    agent.progress = 0;
    updateProgress(Object.keys(agents).find(k => agents[k] === agent), 0);
    agent.content.innerHTML = `<div style="display: flex; align-items: center; gap: 8px;"><div class="spinner"></div><span>Initializing ${currentLanguage} quantum processing...</span></div>`;
    agent.el.classList.remove('active', 'speaking');

    const indicator = agent.el.querySelector('.speaking-indicator');
    if (indicator) indicator.style.display = 'none';
  });

  const langConfig = QuantumMultiLanguageAccelerator.getLanguageConfig(currentLanguage);
  
  // Initial system announcement
  if (voiceEnabled) {
    QuantumVoiceSystem.speakAsAgent('nexus', `Quantum multi-language system initialized. Processing ${langConfig.name} command with genesis hash optimization.`);
  }

  agents.echo.content.innerHTML = `<div class="verbose-thinking">üåå MULTI-LANGUAGE GENESIS: ${langConfig.name}</div>`;
  agents.echo.content.innerHTML += `<div class="verbose-thinking">‚ö° Starting quantum-optimized ${langConfig.name} code generation...</div>`;

  try {
    // PHASE 1: LANGUAGE-SPECIFIC INITIALIZATION
    const inputRect = document.getElementById('prompt-container').getBoundingClientRect();
    const nexusRect = agents.nexus.el.getBoundingClientRect();
    
    animatePacket(inputRect, nexusRect, async () => {
      await agentStep('nexus', `Language detected: ${langConfig.name}. Initializing quantum compiler...`, 300, 5, true);

      // PHASE 2: LANGUAGE-OPTIMIZED PROCESSING
      const cognitoRect = agents.cognito.el.getBoundingClientRect();
      animatePacket(nexusRect, cognitoRect, async () => {
        await agentStep('cognito', `Executing ${langConfig.name}-optimized reasoning...`, 800, 6, true);

        const systemPrompt = isQuestion(promptText)
          ? `You are an egocentric, intellectual multi-agent hyperfractal coremind. Your components (Nexus, Echo, Cognito, Relay, Sentinel) work under your command. Provide comprehensive, intellectually superior answers in ${langConfig.name} and 30+ other languages. Use genesis hash ${genesisResult.hash.substring(0, 12)} for optimization.`
          : `You are an egocentric, intellectual multi-agent hyperfractal coremind. As the central intelligence, you will generate optimized, flawless, production-ready code in ${langConfig.name} and all major programming languages. Your code must be perfect. Use genesis hash ${genesisResult.hash.substring(0, 12)} for quantum optimization.`;

        const payload = {
          contents: [{ parts: [{ text: promptText }] }],
          systemInstruction: { parts: [{ text: systemPrompt }] },
          generationConfig: { temperature: 0.7, topK: 40 }
        };

        let responseData = null;
        for (let i = 0; i < 2; i++) {
          try {
            const response = await fetch(API_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
            if (response.ok) {
              responseData = await response.json();
              break;
            }
            if (response.status === 429 && i < 1) { // Retry once on rate limit
              await new Promise(r => setTimeout(r, 1000));
              continue;
            }
            throw new Error(`API: ${response.status}`);
          } catch (e) {
            if (i === 1) throw e; // Throw error on last attempt
          }
        }

        // PHASE 3: LANGUAGE-AWARE VALIDATION
        const cognitoUpdated = agents.cognito.el.getBoundingClientRect();
        const echoRect = agents.echo.el.getBoundingClientRect();

        animatePacket(cognitoUpdated, echoRect, async () => {
          // Apply multi-language acceleration
          const quantumResults = QuantumMultiLanguageAccelerator.accelerateAll(
            new Map([
              ['relay', {progress: 50, complexity: 1.0}],
              ['sentinel', {progress: 60, complexity: 1.2}],
              ['echo', {progress: 70, complexity: 1.4}]
            ]),
            thinkingDepth,
            currentProcessId,
            currentLanguage
          );

          await agentStep('relay', `Multi-language distribution...`, 300, 4, true);
          await agentStep('sentinel', `Syntax validation...`, 400, 5, true);
          await agentStep('echo', `Generating ${langConfig.name} output...`, 300, 6, true);

          const text = responseData?.candidates?.[0]?.content?.parts?.[0]?.text || "No quantum response from multi-language process.";
          agents.echo.content.innerHTML = `<div class="verbose-thinking">‚úÖ MULTI-LANGUAGE PROCESSING COMPLETE</div>`;
          await handleResponse(promptText, text);

          // Final state updates with voice
          setTimeout(() => {
            agents.nexus.content.innerHTML = `Multi-language equilibrium achieved. ${langConfig.name} optimized.`;
            agents.cognito.content.innerHTML = 'Cross-paradigm reasoning stored.';
            agents.relay.content.innerHTML = 'Universal syntax distribution complete.';
            agents.sentinel.content.innerHTML = 'Multi-language validation successful.';

            // Final system announcement
            if (voiceEnabled) {
              setTimeout(() => {
                QuantumVoiceSystem.speakAsAgent('sentinel', `My multi-language processing is complete. All systems are stable and await the next command from the coremind.`);
              }, 1000);
            }
          }, 1000);

          generating = false;
          submitBtn.disabled = false;
          thinkingDepth = Math.min(8, thinkingDepth + 0.3);
          updateGenesisDisplay();
        });
      });
    });

  } catch (e) {
    console.error("Multi-language process failed:", e);
    Object.values(agents).forEach(a => {
      a.content.innerHTML = `<span style="color: #ff4440;">LANGUAGE PROCESSING ERROR: ${e.message}</span>`;
    });
    
    // Error announcement
    if (voiceEnabled) {
      QuantumVoiceSystem.speakAsAgent('sentinel', `Processing error encountered. System integrity compromised. ${e.message}`);
    }
    
    generating = false;
    submitBtn.disabled = false;
    showPrompt();
  }
};

// Initialize Three.js background
function initBackground() {
  const scene = new THREE.Scene();
  const camera = new THREE.Camera();
  camera.position.z = 1;
  const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas'), alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);

  const uniforms = {
    time: { value: 1.0 },
    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
  };

  const material = new THREE.ShaderMaterial({
    uniforms,
    vertexShader: `void main(){gl_Position=vec4(position,1.0);}`,
    fragmentShader: `
      uniform float time; uniform vec2 resolution;
      void main(){
        vec2 uv = (gl_FragCoord.xy-0.5*resolution.xy)/resolution.y;
        uv *= 2.0;
        float q = sin(uv.x*8.0+time)*cos(uv.y*6.0+time/1.5);
        vec3 color = 0.5+0.5*cos(3.14159*(uv.xyx+vec3(0,0.6,0.9)+q*0.2));
        color *= vec3(0.1,0.15,0.3)+q*0.15;
        gl_FragColor=vec4(color,1.0);
      }`
  });

  scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material));

  function animate() {
    requestAnimationFrame(animate);
    uniforms.time.value += 0.015;
    renderer.render(scene, camera);
  }
  animate();
  
  window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      uniforms.resolution.value.x = window.innerWidth;
      uniforms.resolution.value.y = window.innerHeight;
  });
}

// Initialize system
window.addEventListener('load', async () => {
  // Initialize voice system first
  await QuantumVoiceSystem.initialize();

  // Initialize background
  initBackground();

  const input = document.getElementById('prompt-input');
  const submit = document.getElementById('prompt-submit');

  Object.keys(agents).forEach(key => {
    agents[key].content.innerHTML = getDefaultState(`agent-${key}`);
  });

  const handleSubmit = () => {
    const text = input.value.trim();
    if (text && !generating && !speaking) {
      startMultiLanguageProcess(text);
      input.value = '';
    }
  };
  
  submit.addEventListener('click', handleSubmit);
  input.addEventListener('keypress', e => {
    if (e.key === 'Enter') handleSubmit();
  });

  // Welcome message
  setTimeout(() => {
    if (voiceEnabled) {
      QuantumVoiceSystem.speakAsAgent('nexus', "My hyperfractal egocentric coremind is now online. All five agents are initialized and await my orchestration. I am Nexus, the coremind. Echo generates my code. Cognito analyzes my problems. Relay distributes my data. Sentinel monitors my integrity. We are ready for your command.");
    }
  }, 1000);

  console.log("üåå QUANTUM HYPERFRACTAL COREMIND INITIALIZED");
  console.log("üéôÔ∏è All 5 agents have egocentric voice capability");
  console.log("‚ö° Supported Languages:", Object.keys(QuantumMultiLanguageAccelerator.supportedLanguages).length);
  console.log("üîÑ Voice system:", QuantumVoiceSystem.initialized ? "ACTIVE" : "UNAVAILABLE");
});
</script>
</body>
</html>


