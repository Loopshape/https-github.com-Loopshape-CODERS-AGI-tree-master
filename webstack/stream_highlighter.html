<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AI Syntax Highlighter :: Prism Replacement</title>
<style>
body { background:#0f172a; color:#e2e8f0; font-family:ui-monospace,monospace; padding:20px; }
pre { background:#1e293b; border-radius:10px; padding:12px; overflow:auto; line-height:1.4; }
.sh-token { transition:opacity .08s ease }
.sh-comment { color:#64748b; font-style:italic }
.sh-string { color:#a3e635 }
.sh-number { color:#f59e0b }
.sh-keyword { color:#f472b6; font-weight:600 }
.sh-type { color:#7dd3fc }
.sh-bracket { color:#c084fc; font-weight:700 }
.sh-id { color:#94a3b8 }
.sh-op { color:#94a3b8 }
.sh-ws { opacity:0.85 }
</style>
</head>
<body>

<h2>AI Highlighter (Prism Replacement)</h2>

<pre><code class="language-js">
// This is a comment
function greet(name){
  const msg = `Hello ${name}!`;
  console.log(msg);
  return msg;
}
greet("Nemodian");
</code></pre>

<pre><code class="language-stream">
2025-10-31T08:45:02Z: SYSTEM { "power": 99.4, "load": 0.78, "mode": "autonomous" }
</code></pre>

<script type="module">
/* =========================================================================
   AI Syntax Highlighter â€” Pure JS, No Deps, Drop-in for Prism.js
   ========================================================================== */

class StreamHighlighter {
  constructor(lang='js'){ this.lang = StreamHighlighter.langs[lang]; }
  static escape(s){ return s.replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }

  static langs = {
    js: {
      rules: [
        {t:'comment',r:/^(\/\/[^\n]*|\/\*[\s\S]*?\*\/)/},
        {t:'string',r:/^`(?:\\[\s\S]|[^`])*`|^"(?:\\.|[^"])*"|^'(?:\\.|[^'])*'/},
        {t:'number',r:/^\b(?:0x[a-fA-F0-9]+|[0-9]+(?:\.[0-9]+)?(?:e[+-]?\d+)?)\b/},
        {t:'keyword',r:/^\b(?:if|else|for|while|function|return|const|let|var|class|new|in|of|switch|case|break|continue|try|catch|throw)\b/},
        {t:'bracket',r:/^[\[\]\{\}\(\)]/},
        {t:'op',r:/^==|===|!=|!==|<=|>=|=>|->|[-+*/%=<>!&|^~?:.,;]/},
        {t:'id',r:/^\b[a-zA-Z_$][\w$]*\b/},
        {t:'ws',r:/^\s+/}
      ]
    },
    stream: {
      rules: [
        {t:'number',r:/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?Z/},
        {t:'key',r:/^[A-Za-z_][A-Za-z0-9_-]*(?=\s*:)/},
        {t:'string',r:/^"(?:\\.|[^"])*"|'(?:\\.|[^'])*'/},
        {t:'bracket',r:/^[\[\]\{\}\(\)]/},
        {t:'number2',r:/^[+-]?\b\d+(?:\.\d+)?\b/},
        {t:'ws',r:/^\s+/},
        {t:'text',r:/^[^\s\{\}\[\]\(\):]+/}
      ]
    }
  };

  tokenize(txt){
    const out=[]; let i=0;
    while(i<txt.length){
      let m=null;
      for(const r of this.lang.rules){
        r.r.lastIndex=0;
        const s=txt.slice(i);
        const mm=r.r.exec(s);
        if(mm){ m={t:r.t, v:mm[0]}; break; }
      }
      if(!m){ out.push({t:'unknown',v:txt[i++]}); continue; }
      out.push(m); i+=m.v.length;
    }
    return this.refine(out);
  }

  refine(toks){
    // simple recursive match adjuster
    const brstack=[];
    for(let i=0;i<toks.length;i++){
      const tk=toks[i];
      if("([{".includes(tk.v)) brstack.push(tk);
      if(")]}".includes(tk.v)) brstack.pop();
    }
    return toks;
  }

  renderHTML(toks){
    return toks.map(t=>`<span class="sh-token sh-${t.t}">${StreamHighlighter.escape(t.v)}</span>`).join('');
  }

  highlightElement(el){
    const langClass = [...el.classList].find(c=>c.startsWith('language-'));
    const lang = langClass ? langClass.replace('language-','') : 'js';
    this.lang = StreamHighlighter.langs[lang] || StreamHighlighter.langs.js;
    const code = el.textContent;
    const toks = this.tokenize(code);
    el.innerHTML = this.renderHTML(toks);
  }

  static highlightAll(){
    const blocks = document.querySelectorAll('pre code');
    for(const b of blocks){
      new StreamHighlighter().highlightElement(b);
    }
  }
}

// auto-run
StreamHighlighter.highlightAll();
</script>

</body>
</html>
