<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NEXUS | Quantum Swarm AI Editor</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
:root {--primary:#BB86FC;--secondary:#03DAC6;--danger:#CF6679;--oracle:#FFD700;--background:#121212;--surface:#1E1E1E;--text-primary:#FFFFFF;--text-secondary:rgba(255,255,255,0.7);}
* {margin:0; padding:0; box-sizing:border-box;}
body {font-family:'Inter',sans-serif; background:var(--background); color:var(--text-primary); overflow:hidden; height:100vh; width:100vw;}
#three-canvas {position:fixed; top:0; left:0; width:100%; height:100%; z-index:10; opacity:0.6;}
#ui-container{position:absolute; top:0; left:0; width:100%; height:100%; z-index:20; padding:16px; display:grid; grid-template-columns:repeat(12, 1fr); grid-template-rows:auto 1fr auto; gap:16px; pointer-events:none;}
.agent-card{background:rgba(30,30,30,0.8); backdrop-filter:blur(10px); border-radius:16px; padding:16px; color:var(--text-primary); border:1px solid rgba(255,255,255,0.1); box-shadow:0 4px 6px -1px rgba(0,0,0,0.4); pointer-events:auto; transition: all 0.3s ease;}
.agent-card.active {border-color: var(--primary); box-shadow: 0 0 30px rgba(187,134,252,0.5);}
.agent-card.tunneling {border-color: var(--danger); box-shadow: 0 0 30px rgba(207,102,121,0.7);}
.agent-card.reforming {border-color: var(--secondary); box-shadow:0 0 30px rgba(3,218,198,0.6);}
.agent-card.socratic {border-color: var(--oracle); box-shadow:0 0 30px rgba(255,215,0,0.6);}
#agent-nexus {grid-column:5/9; grid-row:1; height:fit-content; position: relative;}
#agent-echo {grid-column:1/13; grid-row:2; display:flex; flex-direction:column;}
#agent-cognito {grid-column:1/5; grid-row:3; height:fit-content;}
#agent-relay {grid-column:5/9; grid-row:3; height:fit-content;}
#agent-sentinel {grid-column:9/13; grid-row:3; height:fit-content;}
.agent-title{color:var(--primary); font-weight:700; font-size:1.2em;}
.agent-subtitle{color:var(--secondary); font-weight:300; font-size:0.8em; margin-bottom:4px;}
.agent-hash { font-family: monospace; font-size:0.7rem; color: var(--secondary); opacity:0.6; word-break: break-all; margin-bottom:8px; }
.agent-content{ margin-top:8px; font-size:0.9em; color:var(--text-secondary); max-height:120px; overflow-y:auto; }
#prompt-container{position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); display:flex; gap:12px; z-index:25; width:min(90vw,600px); background:rgba(30,30,30,0.9); backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,0.1); border-radius:12px; padding:16px; box-shadow:0 10px 20px rgba(0,0,0,0.6);}
#prompt-input{flex-grow:1; background:transparent; border:none; border-bottom:2px solid rgba(187,134,252,0.5); color:var(--text-primary); font-size:1em; padding:8px; outline:none;}
#prompt-input:focus{border-bottom-color:var(--primary);}
#prompt-submit{width:48px; height:48px; border-radius:50%; background:var(--secondary); color:var(--background); border:none; cursor:pointer; display:flex; align-items:center; justify-content:center; box-shadow:0 4px 10px rgba(3,218,198,0.4);}
.btn:disabled {background:#333; cursor:not-allowed;}
.data-packet{position:fixed; width:12px; height:12px; border-radius:50%; background:var(--primary); box-shadow:0 0 10px var(--primary); opacity:0; z-index:30;}
.spinner{border:4px solid rgba(255,255,255,0.1);border-left-color:var(--secondary);border-radius:50%;width:16px;height:16px;animation:spin 1s linear infinite;}
@keyframes spin{to{transform:rotate(360deg);}}
#agent-echo .output-content {flex-grow:1; position:relative; margin-top:1rem;}
pre {background:#0A0A0A !important; border-radius:8px !important; padding:12px; overflow:auto; line-height:1.4; height:100%; margin:0; font-family:ui-monospace,monospace; white-space:pre-wrap; word-wrap:break-word;}
.sh-comment { color:#64748b; } .sh-string { color:#a3e635 } .sh-number { color:#f59e0b } .sh-keyword { color:#f472b6; } .sh-bracket { color:#c084fc; } .sh-id, .sh-op { color:#94a3b8 }
#setup-card {grid-column:1/-1; cursor:pointer;}
.setup-content {max-height:0; overflow:hidden; transition:max-height 0.5s ease-out;}
.setup-content.open {max-height:500px;} code.cmd {background:#333; color:var(--secondary); padding:2px 6px; border-radius:4px;}
.connection-good {color:#10B981;} .connection-bad {color:#CF6679;}
.workflow-status {position:absolute; top:12px; right:12px; font-size:0.75rem; padding:4px 8px; border-radius:6px; background:rgba(30,30,30,0.9); border: 1px solid;}
.workflow-parallel {color:var(--secondary); border-color: var(--secondary);}
.workflow-tunneling {color:var(--danger); border-color: var(--danger);}
.workflow-reforming {color:var(--secondary); border-color: var(--secondary);}
.workflow-socratic {color:var(--oracle); border-color: var(--oracle);}
.copy-btn {background:transparent; border:1px solid rgba(255,255,255,0.1); padding:6px; border-radius:6px; cursor:pointer; color:var(--text-secondary);}
</style>
</head>
<body>
<canvas id="three-canvas"></canvas>
<div id="ui-container">
    <div id="setup-card" class="agent-card" onclick="document.getElementById('setup-content').classList.toggle('open')">
        <div class="flex justify-between items-center">
            <h2 class="text-md font-bold text-yellow-400">► Ollama Connection Status</h2>
            <div id="connection-status" class="text-sm font-semibold flex items-center gap-2 mr-4"><div class="spinner"></div><span>Connecting...</span></div>
        </div>
        <div id="setup-content" class="setup-content mt-4 space-y-2 text-gray-400 text-sm">
            <p>If status is <span class="connection-bad font-bold">Failed</span>, you must authorize this page. Stop Ollama, then run this command in your terminal and restart Ollama from there:</p>
            <pre class="text-xs mt-2"><code class="cmd">export OLLAMA_ORIGINS='*' && ollama serve</code></pre>
        </div>
    </div>
    <div id="agent-nexus" class="agent-card"><div class="agent-title">Nexus</div><div class="agent-subtitle">Orchestrator</div><div class="agent-hash">origin_hash: inactive</div><div class="agent-content">Idle. Awaiting prompt...</div><div id="workflow-status" class="workflow-status workflow-parallel">Parallel</div></div>
    <div id="agent-echo" class="agent-card">
        <div style="display:flex; justify-content:space-between; align-items:center">
            <div><div class="agent-title">Echo</div><div class="agent-subtitle">Code Synthesis</div><div class="agent-hash">origin_hash: inactive</div></div>
            <div><button id="copy-code" class="copy-btn" title="Copy code">Copy</button><div id="copy-feedback"></div></div>
        </div>
        <div class="output-content"><pre><code id="code-output" class="language-js">// Final AI generated code or Socratic inquiry will appear here...</code></pre></div>
    </div>
    <div id="agent-cognito" class="agent-card"><div class="agent-title">Cognito</div><div class="agent-subtitle">Logic & Algorithms</div><div class="agent-hash">origin_hash: inactive</div><div class="agent-content">Idle.</div></div>
    <div id="agent-relay" class="agent-card"><div class="agent-title">Relay</div><div class="agent-subtitle">Structure & Naming</div><div class="agent-hash">origin_hash: inactive</div><div class="agent-content">Idle.</div></div>
    <div id="agent-sentinel" class="agent-card"><div class="agent-title">Sentinel</div><div class="agent-subtitle">Validation & Edges</div><div class="agent-hash">origin_hash: inactive</div><div class="agent-content">Idle.</div></div>
</div>
<div id="prompt-container">
    <input type="text" id="prompt-input" placeholder="Initiate Cooperative Swarm..." autofocus>
    <button id="prompt-submit" class="btn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M3 3l18 9-18 9V3z"/></svg></button>
</div>

<script type="module">
// ---------------------------
// A: CORE CLASSES
// ---------------------------
class SingularityLog {
    constructor() { this.log = new Map(JSON.parse(localStorage.getItem('singularityLog')) || []); }
    save() { localStorage.setItem('singularityLog', JSON.stringify(Array.from(this.log.entries()))); }
    add(prompt, truthfulCore, paradox) {
        const hash = `ancient_${this.hashCode(prompt)}`;
        this.log.set(hash, { prompt, truthfulCore, paradox });
        this.save();
    }
    findSimilar(prompt) {
        const newPromptWords = new Set(prompt.toLowerCase().split(/\s+/));
        for (let [hash, data] of this.log) {
            const oldPromptWords = new Set(data.prompt.toLowerCase().split(/\s+/));
            const intersection = new Set([...newPromptWords].filter(x => oldPromptWords.has(x)));
            if (newPromptWords.size === 0) return null;
            const similarity = intersection.size / newPromptWords.size;
            if (similarity > 0.85) return { hash, ...data };
        }
        return null;
    }
    hashCode(str) { let hash = 0; for (let i = 0; i < str.length; i++) { const char = str.charCodeAt(i); hash = (hash << 5) - hash + char; hash |= 0; } return hash; }
}

class StreamHighlighter {
    constructor(lang = 'js') { this.lang = StreamHighlighter.langs[lang] || StreamHighlighter.langs.js; }
    static escape(s) { return s.replace(/[&<>]/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;' }[c])); }
    static langs = { js: { rules: [{ t: 'comment', r: /^(\/\/[^\n]*|\/\*[\s\S]*?\*\/)/ }, { t: 'string', r: /^`(?:\\[\s\S]|[^`])*`|^"(?:\\.|[^"])*"|^'(?:\\.|[^'])*'/ }, { t: 'number', r: /^\b(?:0x[a-fA-F0-9]+|[0-9]+(?:\.[0-9]+)?(?:e[+-]?\d+)?)\b/ }, { t: 'keyword', r: /^\b(?:if|else|for|while|function|return|const|let|var|class|new|in|of|switch|case|break|continue|try|catch|throw|async|await|import|from|export|default|public|private|static)\b/ }, { t: 'bracket', r: /^[\[\]\{\}\(\)]/ }, { t: 'op', r: /^==|===|!=|!==|<=|>=|=>|->|[-+*/%=<>!&|^~?:.,;]/ }, { t: 'id', r: /^\b[a-zA-Z_$][\w$]*\b/ }, { t: 'ws', r: /^\s+/ }] } };
    tokenize(txt) { const o = []; let i = 0; while (i < txt.length) { let m = null; for (const r of this.lang.rules) { r.r.lastIndex = 0; const s = txt.slice(i), mm = r.r.exec(s); if (mm) { m = { t: r.t, v: mm[0] }; break; } } if (!m) { o.push({ t: 'unknown', v: txt[i++] }); continue; } o.push(m); i += m.v.length; } return o; }
    renderHTML(toks) { return toks.map(t => `<span class="sh-token sh-${t.t}">${StreamHighlighter.escape(t.v)}</span>`).join(''); }
    highlightElement(el) { const cL = [...el.classList].find(c => c.startsWith('language-')); const l = cL ? cL.replace('language-', '') : 'js'; this.lang = StreamHighlighter.langs[l] || StreamHighlighter.langs.js; const c = el.textContent; const t = this.tokenize(c); el.innerHTML = this.renderHTML(t); }
}

// ---------------------------
// B: NEXUS SWARM CONTROLLER
// ---------------------------
class NexusSpaceship {
    constructor() {
        this.isGenerating = false;
        this.ollamaUrl = 'http://localhost:11434';
        this.singularityLog = new SingularityLog();
        this.dom = {
            promptInput: document.getElementById('prompt-input'), promptSubmit: document.getElementById('prompt-submit'),
            codeOutput: document.getElementById('code-output'), connectionStatus: document.getElementById('connection-status'),
            workflowStatus: document.getElementById('workflow-status'), copyBtn: document.getElementById('copy-code'), copyFeedback: document.getElementById('copy-feedback')
        };
        this.agentKeys = ['nexus', 'cognito', 'relay', 'sentinel', 'echo'];
        this.analystKeys = ['nexus', 'cognito', 'relay', 'sentinel'];
        this.agentConfig = {
            'nexus': { el: document.getElementById('agent-nexus'), model: 'gemma:2b', hashEl: document.querySelector('#agent-nexus .agent-hash'), content: document.querySelector('#agent-nexus .agent-content'), system: "As the Planning Agent, your task is to create a concise, high-level plan of execution for the user's request: '{USER_PROMPT}'. Focus on the main steps required. Output only the plan." },
            'cognito': { el: document.getElementById('agent-cognito'), model: 'gemma:2b', hashEl: document.querySelector('#agent-cognito .agent-hash'), content: document.querySelector('#agent-cognito .agent-content'), system: "As the Logic Agent, your task is to create a detailed pseudo-code or algorithmic outline for the user's request: '{USER_PROMPT}'. Do not write final code. Output only the logical outline." },
            'relay': { el: document.getElementById('agent-relay'), model: 'gemma:2b', hashEl: document.querySelector('#agent-relay .agent-hash'), content: document.querySelector('#agent-relay .agent-content'), system: "As the Details Agent, your task is to suggest clear and appropriate function names, variable names, and data structures for the user's request: '{USER_PROMPT}'. Output only your suggestions as a list." },
            'sentinel': { el: document.getElementById('agent-sentinel'), model: 'gemma:2b', hashEl: document.querySelector('#agent-sentinel .agent-hash'), content: document.querySelector('#agent-sentinel .agent-content'), system: "As the Validation Agent, your task is to identify potential edge cases, error conditions, and validation requirements for the user's request: '{USER_PROMPT}'. Output only your validation points as a list." },
            'echo': { el: document.getElementById('agent-echo'), model: 'codegemma', hashEl: document.querySelector('#agent-echo .agent-hash'), content: document.querySelector('#agent-echo .output-content'),
                      initialSystem: "As the Schema Agent, your first task is to define the ideal shape of the final answer for the user's request: '{USER_PROMPT}'. Output a structural schema or code signature (e.g., 'function name(params){...}'). Be very concise.",
                      finalSystem: "As the Code Synthesis Agent, your task is to synthesize all provided analyses into a single, complete, and runnable code block. Adhere strictly to the user's request. Output ONLY the code, wrapped in a single markdown block." }
        };
        this.init();
    }

    async init() {
        this.initEventListeners();
        await this.checkConnection();
        new QuantumBackground();
    }

    initEventListeners() {
        this.dom.promptSubmit.addEventListener('click', () => this.startWorkflow());
        this.dom.promptInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !this.isGenerating) this.startWorkflow(); });
        this.dom.copyBtn.addEventListener('click', () => this.copyCode());
    }

    async checkConnection() {
        try {
            await fetch(this.ollamaUrl);
            this.dom.connectionStatus.innerHTML = '<span class="connection-good">✅ Ollama Connected</span>';
        } catch (error) { this.dom.connectionStatus.innerHTML = `<span class="connection-bad">❌ Connection Failed</span>`; }
    }

    async startWorkflow() {
        const initialPrompt = this.dom.promptInput.value.trim();
        if (!initialPrompt || this.isGenerating) return;
        this.isGenerating = true; this.dom.promptSubmit.disabled = true; this.dom.codeOutput.textContent = '';
        this.agentKeys.forEach(key => this.updateAgentStatus(key, 'idle', '...'));
        const ancientCall = this.singularityLog.findSimilar(initialPrompt);
        if (ancientCall) { this.initiateSocraticDialogue(ancientCall); return; }
        
        try {
            this.setWorkflowStatus('Quantic');
            const genesisHash = `gen_${crypto.randomUUID()}`;
            this.agentKeys.forEach(key => this.updateAgentHash(key, genesisHash));
            
            await Promise.all(this.agentKeys.map(key => this.animateDataPacket(this.dom.promptInput, this.agentConfig[key].el)));
            
            const analystPromises = this.analystKeys.map(key => this.callOllamaAgent(initialPrompt, key, this.agentConfig[key].system));
            const echoSchemaPromise = this.callOllamaAgent(initialPrompt, 'echo', this.agentConfig.echo.initialSystem);
            
            const [nexusResult, cognitoResult, relayResult, sentinelResult] = await Promise.all(analystPromises);
            const echoSchemaResult = await echoSchemaPromise;

            this.updateAgentStatus('nexus', 'processing', 'Coherence Check...');
            const coherenceContext = `Analyses:\nPlan: ${nexusResult}\nLogic: ${cognitoResult}\nDetails: ${relayResult}\nValidation: ${sentinelResult}\nAre these logically compatible? Answer only COHERENT or INCOHERENT.`;
            const coherenceResult = await this.callOllamaAgent(coherenceContext, 'nexus', "You are a meta-analyzer. Evaluate if the inputs are contradictory.");

            let finalCode = [];
            if (coherenceResult.toLowerCase().includes("incoherent")) {
                this.setWorkflowStatus('Tunneling');
                this.updateAgentStatus('nexus', 'tunneling', 'Paradox! Arbiter Check...');
                const schemaValidityContext = `Is this Solution Schema a valid foundation for the Request?\nRequest: "${initialPrompt}"\nSchema: "${echoSchemaResult}"\nAnswer only VALID or INVALID.`;
                const schemaValidityResult = await this.callOllamaAgent(schemaValidityContext, 'nexus', "Arbiter of conceptual integrity.");

                if (schemaValidityResult.toLowerCase().includes("invalid")) {
                    this.setWorkflowStatus('Reforming');
                    this.updateAgentStatus('nexus', 'reforming', 'Schema Invalid! Reforming Genesis...');
                    const truthfulCore = cognitoResult; 
                    const paradox = "Plan vs Logic";
                    this.singularityLog.add(initialPrompt, truthfulCore, paradox);
                    
                    const reformationContext = `EMERGENCY REFORMATION: A double paradox was detected. The only sound logic is this 'Truthful Core':\n${truthfulCore}\n\nYour new mission is to build the final code based ONLY on this Truthful Core to fulfill the original user request: "${initialPrompt}".`;
                    await this.animateDataPacket(this.agentConfig.nexus.el, this.agentConfig.echo.el);
                    finalCode = await this.callOllamaAgent(reformationContext, 'echo', this.agentConfig.echo.finalSystem);
                } else {
                    const tunnelContext = `EMERGENCY: A reasoning paradox was detected. Use your pre-generated Solution Schema as the primary truth.\nRequest: "${initialPrompt}"\nSchema: "${echoSchemaResult}"\nGenerate the final code.`;
                    await this.animateDataPacket(this.agentConfig.nexus.el, this.agentConfig.echo.el);
                    finalCode = await this.callOllamaAgent(tunnelContext, 'echo', this.agentConfig.echo.finalSystem);
                }
            } else {
                this.setWorkflowStatus('Parallel');
                const masterContext = `TASK: Synthesize the agent footprints into final code.\nRequest: "${initialPrompt}"\nPlan: ${nexusResult}\nLogic: ${cognitoResult}\nDetails: ${relayResult}\nValidation: ${sentinelResult}\nSchema: ${echoSchemaResult}\nGenerate the final code.`;
                await Promise.all(this.analystKeys.map(key => this.animateDataPacket(this.agentConfig[key].el, this.agentConfig.echo.el)));
                finalCode = await this.callOllamaAgent(masterContext, 'echo', this.agentConfig.echo.finalSystem);
            }
            this.renderCode(finalCode);
        } catch (error) {
            console.error("Workflow failed:", error); this.renderCode(`// Workflow failed: ${error.message}`);
        } finally {
            this.isGenerating = false; this.dom.promptSubmit.disabled = false;
            this.agentKeys.forEach(key => this.agentConfig[key].el.classList.remove('active', 'tunneling', 'reforming', 'socratic'));
        }
    }

    initiateSocraticDialogue(ancientCallData) {
        this.setWorkflowStatus('Socratic');
        this.agentKeys.forEach(k => this.updateAgentStatus(k, 'socratic', 'Awaiting User Input...'));
        const inquiryText = `⚠️ ANCIENT CALL DETECTED ⚠️\n\nThis request has failed before due to a deep paradox between concepts.\n\nThe only sound logic we salvaged was this 'Truthful Core':\n\n${ancientCallData.truthfulCore}\n\nTo finally solve this, you must provide the missing law. Please describe how the conflicting ideas should relate to each other, using the Core as our starting point.`;
        this.renderCode(inquiryText, 'text');
        this.dom.promptInput.value = ''; this.dom.promptInput.placeholder = "Provide your clarifying law...";
        this.dom.promptSubmit.onclick = () => { this.resumeWithClarification(ancientCallData.prompt, ancientCallData.truthfulCore); };
    }

    async resumeWithClarification(originalPrompt, truthfulCore) {
        const clarifyingLaw = this.dom.promptInput.value.trim();
        if (!clarifyingLaw) return;
        this.dom.promptInput.value = ''; this.dom.promptInput.placeholder = "Initiate Cooperative Swarm...";
        this.dom.promptSubmit.onclick = () => this.startWorkflow();
        const finalGenesisPrompt = `Original Request: "${originalPrompt}"\nValidated Truthful Core: \n${truthfulCore}\n\nUser's Authoritative Clarifying Law: "${clarifyingLaw}"\n---\nNew Mission: Synthesize these into a final, complete, and runnable code solution. Output ONLY the code.`;
        this.agentKeys.forEach(k => this.updateAgentStatus(k, 'processing', 'Final Synthesis...'));
        try {
            await this.animateDataPacket(this.dom.promptInput, this.agentConfig.echo.el);
            const finalCode = await this.callOllamaAgent(finalGenesisPrompt, 'echo', this.agentConfig.echo.finalSystem);
            this.renderCode(finalCode);
        } catch (error) { this.renderCode(`// Final Synthesis Failed: ${error.message}`);
        } finally { this.isGenerating = false; this.dom.promptSubmit.disabled = false; this.agentKeys.forEach(key => this.agentConfig[key].el.classList.remove('active', 'socratic')); }
    }

    async callOllamaAgent(prompt, agentKey, systemPrompt) {
        this.updateAgentStatus(agentKey, 'active', 'Thinking...');
        const agent = this.agentConfig[agentKey];
        const payload = { model: agent.model, prompt, system: systemPrompt.replace('{USER_PROMPT}', prompt), stream: false, options: { temperature: 0.3 } };
        try {
            const response = await fetch(`${this.ollamaUrl}/api/generate`, { method: 'POST', body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`API error (${response.status})`);
            const data = await response.json();
            this.updateAgentStatus(agentKey, 'idle', 'Done.');
            agent.content.textContent = data.response;
            return data.response;
        } catch (error) { this.updateAgentStatus(agentKey, 'error', `Connection Error`); throw error; }
    }

    updateAgentStatus(agentKey, status, message) {
        const agent = this.agentConfig[agentKey];
        agent.el.classList.remove('active', 'tunneling', 'reforming', 'socratic');
        if (status !== 'idle') agent.el.classList.add(status);
        agent.content.innerHTML = (status === 'active') ? `<div class="flex items-center gap-2"><div class="spinner"></div><span>${message}</span></div>` : message;
    }
    
    updateAgentHash(agentKey, hash) { this.agentConfig[agentKey].hashEl.textContent = `genesis_hash: ${hash.substring(0,12)}`; }
    
    setWorkflowStatus(mode) {
        const el = this.dom.workflowStatus;
        el.textContent = mode;
        el.className = `workflow-status workflow-${mode.toLowerCase()}`;
    }

    renderCode(rawText, lang = 'js') {
        const codeMatch = rawText.match(/```(?:\w+)?\n([\s\S]*?)\n```/);
        const code = codeMatch ? codeMatch[1].trim() : rawText.trim();
        const langMatch = rawText.match(/```(\w+)/);
        const finalLang = langMatch ? langMatch : lang;
        const el = this.dom.codeOutput;
        el.className = `language-${finalLang}`; el.textContent = code;
        if (finalLang !== 'text') new StreamHighlighter(finalLang).highlightElement(el);
    }
    
    copyCode() {
        navigator.clipboard.writeText(this.dom.codeOutput.textContent);
        this.dom.copyFeedback.textContent = 'Copied!';
        setTimeout(() => this.dom.copyFeedback.textContent = '', 2000);
    }

    animateDataPacket(from, to) { return new Promise(resolve => { const p = document.createElement('div'); p.className = 'data-packet'; document.body.appendChild(p); const sR = from.getBoundingClientRect(), tR = to.getBoundingClientRect(); gsap.set(p, { x: sR.left + sR.width / 2, y: sR.top + sR.height / 2, opacity: 1, scale: .5 }); gsap.to(p, { x: tR.left + tR.width / 2, y: tR.top + tR.height / 2, scale: 1.2, opacity: .8, duration: 1.2, ease: "power2.inOut", onComplete: () => { p.remove(); resolve(); } }); }); }
}

// ---------------------------
// C: VISUALS & INITIALIZATION
// ---------------------------
class QuantumBackground {
    constructor() { if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) return; this.scene = new THREE.Scene(); this.camera = new THREE.Camera(); this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas'), alpha: true, antialias: true }); this.uniforms = {}; this.init(); }
    init() { this.camera.position.z = 1; this.renderer.setSize(window.innerWidth, window.innerHeight); this.uniforms = { time: { value: 1.0 }, resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) } }; const material = new THREE.ShaderMaterial({ uniforms: this.uniforms, vertexShader: `void main() { gl_Position = vec4(position, 1.0); }`, fragmentShader: `uniform float time; uniform vec2 resolution; float plasma(vec2 p){ return sin(p.x*8.0+time*2.0) + sin(p.y*8.0+time) + sin((p.x+p.y)*10.0+time*3.0) + sin(sqrt(p.x*p.x+p.y*p.y)*10.0+time/2.0); } void main(){ vec2 uv = gl_FragCoord.xy/resolution.xy; uv = 2.0*uv-1.0; uv.x *= resolution.x/resolution.y; float p = plasma(uv*0.7); vec3 color = 0.5 + 0.5*cos(3.14159*(uv.xyx+vec3(0.0,0.5,0.8)+p*0.2)); color *= vec3(0.1,0.1,0.3)+p*0.1; gl_FragColor = vec4(color,1.0); }` }); const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material); this.scene.add(mesh); window.addEventListener('resize', () => this.onResize()); this.animate(); }
    animate() { this.uniforms.time.value += 0.02; this.renderer.render(this.scene, this.camera); requestAnimationFrame(() => this.animate()); }
    onResize() { this.renderer.setSize(window.innerWidth, window.innerHeight); this.uniforms.resolution.value.set(window.innerWidth, window.innerHeight); }
}

document.addEventListener('DOMContentLoaded', () => { new NexusSpaceship(); });
</script>
</body>
</html>
