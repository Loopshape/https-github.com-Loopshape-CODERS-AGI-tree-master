I'll rebuild the layout to use full-width panels and hide the prompt panel after submitting. Here's the optimized version:

```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>QUANTUM FULL-WIDTH 5-AGENT SYSTEM | Hidden Prompt Interface</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>

<style>
/* FULL-WIDTH LAYOUT STYLES */
:root {
  --quantum-purple: #BB86FC;
  --quantum-cyan: #03DAC6;
  --quantum-bg: #0a0a0a;
}

* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: var(--quantum-bg); color: #eee; font-family: system-ui, sans-serif; height: 100vh; overflow: hidden; }

#three-canvas { position: fixed; top: 0; left: 0; z-index: 1; width: 100%; height: 100%; }

#ui-container {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2;
  padding: 10px; display: grid;
  grid-template-columns: 1fr; 
  grid-template-rows: 0.8fr 2fr 1fr 1fr 1fr;
  gap: 8px;
  pointer-events: none;
}

.agent-card {
  background: rgba(31,31,31,0.95);
  border-radius: 8px;
  padding: 12px;
  color: #eee;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  pointer-events: auto;
  border: 1px solid transparent;
  backdrop-filter: blur(8px);
  transition: all 0.2s ease;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
}
.agent-card.active { border-color: var(--quantum-purple); box-shadow: 0 0 20px rgba(187,134,252,0.4); }

/* Full-width grid positioning */
#agent-nexus { grid-row: 1; }
#agent-echo { grid-row: 2; }
#agent-cognito { grid-row: 3; }
#agent-relay { grid-row: 4; }
#agent-sentinel { grid-row: 5; }

.agent-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
.agent-title { color: var(--quantum-purple); font-weight: 700; font-size: 1.1em; display: flex; align-items: center; gap: 6px; }
.agent-subtitle { color: var(--quantum-cyan); font-size: 0.7em; }
.agent-content { 
  flex: 1; 
  font-size: 0.8em; 
  color: rgba(255,255,255,0.7); 
  overflow-y: auto;
  overflow-x: hidden;
  min-height: 0;
}

.quantum-indicator { width: 6px; height: 6px; border-radius: 50%; background: var(--quantum-cyan); animation: pulse 1.5s infinite; }
@keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(1.1); } }

#prompt-container {
  position: fixed; 
  top: 50%; 
  left: 50%; 
  transform: translate(-50%,-50%);
  display: flex; 
  gap: 8px; 
  z-index: 3;
  width: min(95vw, 600px);
  background: rgba(31,31,31,0.98);
  border-radius: 8px; 
  padding: 16px;
  box-shadow: 0 8px 25px rgba(187,134,252,0.3);
  backdrop-filter: blur(10px); 
  border: 1px solid rgba(187,134,252,0.3);
  transition: all 0.3s ease;
}
#prompt-container.hidden {
  opacity: 0;
  transform: translate(-50%,-50%) scale(0.9);
  pointer-events: none;
}

#prompt-input { 
  flex: 1; 
  background: transparent; 
  border: none; 
  border-bottom: 1px solid rgba(187,134,252,0.3); 
  color: #eee; 
  font-size: 1em; 
  padding: 8px; 
  outline: none; 
}
#prompt-input:focus { border-bottom-color: var(--quantum-purple); }
#prompt-submit { 
  width: 44px; 
  height: 44px; 
  border-radius: 50%; 
  background: linear-gradient(135deg, var(--quantum-cyan), var(--quantum-purple)); 
  color: #121212; 
  border: none; 
  cursor: pointer; 
  display: flex; 
  align-items: center; 
  justify-content: center; 
  font-weight: bold;
  transition: all 0.2s ease;
}
#prompt-submit:hover { transform: scale(1.05); }

.data-packet { position: fixed; width: 6px; height: 6px; border-radius: 50%; background: linear-gradient(135deg, var(--quantum-purple), var(--quantum-cyan)); opacity: 0; z-index: 4; }
.quantum-particle { position: fixed; width: 3px; height: 3px; border-radius: 50%; background: var(--quantum-cyan); pointer-events: none; z-index: 3; }

.spinner { width: 14px; height: 14px; border: 2px solid rgba(255,255,255,0.1); border-left-color: var(--quantum-cyan); border-radius: 50%; animation: spin 0.8s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }

.fractal-progress { 
  height: 3px; 
  background: linear-gradient(90deg, var(--quantum-cyan), var(--quantum-purple)); 
  border-radius: 1px; 
  margin-top: 6px; 
  transition: width 0.3s ease;
  width: 0%;
}

pre[class*="language-"] { 
  margin: 0; 
  padding: 8px; 
  border-radius: 4px; 
  background: rgba(18,18,18,0.9); 
  font-size: 0.75em; 
  border: 1px solid rgba(187,134,252,0.2); 
  max-height: 200px;
  overflow-y: auto;
}
.token.string { color: #81C784; } 
.token.keyword { color: var(--quantum-purple); } 
.token.comment { color: #666; }

.verbose-thinking { 
  background: rgba(30,30,40,0.8); 
  border-left: 2px solid var(--quantum-purple); 
  padding: 6px 8px; 
  margin: 3px 0; 
  border-radius: 3px; 
  font-family: monospace; 
  font-size: 0.75em;
}

.control-panel {
  position: fixed;
  bottom: 10px;
  right: 10px;
  z-index: 3;
  display: flex;
  gap: 8px;
}

.control-btn {
  background: rgba(31,31,31,0.9);
  border: 1px solid rgba(187,134,252,0.3);
  color: var(--quantum-cyan);
  padding: 8px 12px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.8em;
  backdrop-filter: blur(8px);
  transition: all 0.2s ease;
}

.control-btn:hover {
  background: rgba(187,134,252,0.1);
  border-color: var(--quantum-purple);
}
</style>
</head>
<body>

<canvas id="three-canvas"></canvas>

<!-- Prompt Panel - Initially visible, gets hidden after submission -->
<div id="prompt-container">
  <input type="text" id="prompt-input" placeholder="Enter quantum command... (Press Enter or click →)" autofocus>
  <button id="prompt-submit">→</button>
</div>

<!-- Control Panel - Always visible -->
<div class="control-panel">
  <button class="control-btn" id="show-prompt-btn">Show Prompt</button>
  <button class="control-btn" id="reset-btn">Reset</button>
</div>

<!-- Full-width Agent Panels -->
<div id="ui-container">
  <div id="agent-nexus" class="agent-card">
    <div class="agent-header">
      <div class="agent-title">Nexus <div class="quantum-indicator"></div></div>
      <div class="agent-subtitle">Quantum Core Orchestrator</div>
    </div>
    <div class="agent-content">Quantum field stabilized. Ready for command input.</div>
    <div class="fractal-progress"></div>
  </div>
  
  <div id="agent-echo" class="agent-card">
    <div class="agent-header">
      <div class="agent-title">Echo <div class="quantum-indicator"></div></div>
      <div class="agent-subtitle">Meta-Reporter & Output System</div>
    </div>
    <div class="agent-content">Awaiting quantum processing results...</div>
    <div class="fractal-progress"></div>
  </div>
  
  <div id="agent-cognito" class="agent-card">
    <div class="agent-header">
      <div class="agent-title">Cognito <div class="quantum-indicator"></div></div>
      <div class="agent-subtitle">Fractal Reasoning Analyzer</div>
    </div>
    <div class="agent-content">Fractal depth calibrated. Standing by.</div>
    <div class="fractal-progress"></div>
  </div>
  
  <div id="agent-relay" class="agent-card">
    <div class="agent-header">
      <div class="agent-title">Relay <div class="quantum-indicator"></div></div>
      <div class="agent-subtitle">Hyper-Communication Channel</div>
    </div>
    <div class="agent-content">Entanglement matrix primed. Ready for data stream.</div>
    <div class="fractal-progress"></div>
  </div>
  
  <div id="agent-sentinel" class="agent-card">
    <div class="agent-header">
      <div class="agent-title">Sentinel <div class="quantum-indicator"></div></div>
      <div class="agent-subtitle">Energy & System Monitor</div>
    </div>
    <div class="agent-content">Quantum stability monitoring active. All systems nominal.</div>
    <div class="fractal-progress"></div>
  </div>
</div>

<!-- ULTRA-OPTIMIZED QUANTUM ACCELERATOR -->
<script>
class QuantumAccelerator {
  static cache = new Map();
  static matrix = new Map();
  static energy = 1.0;
  
  static quantumBoost(agentId = 'default') {
    const base = (Math.random() * 8 + 2) / 100;
    const entangled = this.getEntanglement(agentId);
    return Math.min(0.12, base * (1 + entangled));
  }

  static fractalReason(depth, max, complexity = 1) {
    const key = `${depth}-${max}-${complexity}`;
    if (this.cache.has(key)) return this.cache.get(key);
    
    if (depth >= max) return 1 + (complexity * 0.015);
    
    const recursive = this.fractalReason(depth + 1, max, complexity);
    const gain = (1 + (0.05 / depth)) * recursive * complexity;
    
    this.cache.set(key, gain);
    return gain;
  }

  static getEntanglement(agentId) {
    let total = 0, count = 0;
    this.matrix.forEach((strength, id) => {
      if (id !== agentId) { total += strength; count++; }
    });
    return count > 0 ? total / count : 0;
  }

  static entangleAgents(agents) {
    agents.forEach((a, id1) => {
      agents.forEach((b, id2) => {
        if (id1 !== id2) this.matrix.set(`${id1}-${id2}`, 0.12);
      });
    });
  }

  static accelerateAll(agents, depth = 6) {
    this.entangleAgents(agents);
    const results = new Map();
    let total = 0;

    agents.forEach((agent, id) => {
      const boost = agent.progress * this.quantumBoost(id);
      const fractal = this.fractalReason(1, depth, agent.complexity);
      const entangled = this.getEntanglement(id);
      
      const enhanced = agent.progress + boost * fractal * (1 + entangled);
      const final = Math.min(100, enhanced);
      
      results.set(id, { progress: final, boost, enhancement: final - agent.progress });
      total += final - agent.progress;
    });

    this.energy = Math.max(0.8, this.energy - total * 0.005);
    return results;
  }

  static accelerate(current, depth = 4, complexity = 1) {
    const boost = current * this.quantumBoost();
    const fractal = this.fractalReason(1, Math.max(1, depth), complexity);
    return Math.min(100, current + boost * fractal);
  }
}
</script>

<script>
// Optimized environment setup
(function() {
  window.__CONFIG = {
    apiKey: window.__API_KEY_INJECTION__ || "AIzaSyBtto2pvY2bTO26XwuV1hAB9RbSqYo3Fnw",
    appId: 'quantum-fullwidth-v1',
    features: { quantum: true, speed: true, debug: false }
  };
})();
</script>

<script type="module">
// FULL-WIDTH QUANTUM SYSTEM
const CONFIG = window.__CONFIG;
const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${CONFIG.apiKey}`;

// Agent system with full-width layout
const agents = {
  nexus: { 
    el: document.getElementById('agent-nexus'), 
    content: document.querySelector('#agent-nexus .agent-content'), 
    progress: 0, 
    complexity: 1.1 
  },
  echo: { 
    el: document.getElementById('agent-echo'), 
    content: document.querySelector('#agent-echo .agent-content'), 
    progress: 0, 
    complexity: 1.4 
  },
  cognito: { 
    el: document.getElementById('agent-cognito'), 
    content: document.querySelector('#agent-cognito .agent-content'), 
    progress: 0, 
    complexity: 1.3 
  },
  relay: { 
    el: document.getElementById('agent-relay'), 
    content: document.querySelector('#agent-relay .agent-content'), 
    progress: 0, 
    complexity: 1.0 
  },
  sentinel: { 
    el: document.getElementById('agent-sentinel'), 
    content: document.querySelector('#agent-sentinel .agent-content'), 
    progress: 0, 
    complexity: 1.2 
  }
};

let generating = false, speaking = false, thinkingDepth = 5;

// UI Control Functions
const promptContainer = document.getElementById('prompt-container');
const showPromptBtn = document.getElementById('show-prompt-btn');
const resetBtn = document.getElementById('reset-btn');

function hidePrompt() {
  promptContainer.classList.add('hidden');
}

function showPrompt() {
  promptContainer.classList.remove('hidden');
  document.getElementById('prompt-input').focus();
}

function resetSystem() {
  generating = false;
  speaking = false;
  thinkingDepth = 5;
  
  Object.values(agents).forEach(agent => {
    agent.progress = 0;
    const progressBar = agent.el.querySelector('.fractal-progress');
    if (progressBar) progressBar.style.width = '0%';
    agent.content.innerHTML = getDefaultState(agent.el.id);
    agent.el.classList.remove('active');
  });
  
  showPrompt();
  document.getElementById('prompt-input').value = '';
  document.getElementById('prompt-submit').disabled = false;
}

function getDefaultState(agentId) {
  const states = {
    'agent-nexus': 'Quantum field stabilized. Ready for command input.',
    'agent-echo': 'Awaiting quantum processing results...',
    'agent-cognito': 'Fractal depth calibrated. Standing by.',
    'agent-relay': 'Entanglement matrix primed. Ready for data stream.',
    'agent-sentinel': 'Quantum stability monitoring active. All systems nominal.'
  };
  return states[agentId] || 'System ready.';
}

// Event listeners for controls
showPromptBtn.addEventListener('click', showPrompt);
resetBtn.addEventListener('click', resetSystem);

// Optimized utility functions
const isQuestion = text => /\?$|^who|^what|^how|^when|^where|^why/i.test(text.trim());

const updateProgress = (agentId, progress) => {
  const bar = agents[agentId].el.querySelector('.fractal-progress');
  if (bar) bar.style.width = `${progress}%`;
};

const createParticles = (element, count = 8) => {
  const rect = element.getBoundingClientRect();
  for (let i = 0; i < count; i++) {
    const p = document.createElement('div');
    p.className = 'quantum-particle';
    p.style.left = (rect.left + rect.width / 2) + 'px';
    p.style.top = (rect.top + rect.height / 2) + 'px';
    document.body.appendChild(p);

    const angle = Math.random() * Math.PI * 2;
    const dist = 30 + Math.random() * 50;
    const dur = 0.5 + Math.random() * 0.4;

    gsap.to(p, {
      x: Math.cos(angle) * dist,
      y: Math.sin(angle) * dist,
      opacity: 0, scale: 0, duration: dur,
      onComplete: () => p.remove()
    });
  }
};

const animatePacket = (from, to, callback) => {
  const packet = document.createElement('div');
  packet.className = 'data-packet';
  document.body.appendChild(packet);

  const startX = from.left + from.width / 2;
  const startY = from.top + from.height / 2;
  const endX = to.left + to.width / 2;
  const endY = to.top + to.height / 2;

  gsap.set(packet, { x: startX, y: startY, opacity: 1, scale: 0.2 });
  gsap.to(packet, {
    x: endX, y: endY, scale: 1.5, opacity: 0.8, duration: 0.4,
    onComplete: () => { packet.remove(); createParticles({getBoundingClientRect: () => to}, 4); callback?.(); }
  });
};

// Optimized agent step function
const agentStep = async (agentKey, message, duration = 400, depth = 4) => {
  const agent = agents[agentKey];
  agent.el.classList.add('active');
  createParticles(agent.el);

  const progress = QuantumAccelerator.accelerate(agent.progress, depth, agent.complexity);
  agent.progress = progress;
  updateProgress(agentKey, progress);

  const speedDuration = duration / (1 + (depth * 0.08));
  agent.content.innerHTML = `<div style="display: flex; align-items: center; gap: 8px;"><div class="spinner"></div><span>${message}</span></div>`;
  
  await new Promise(r => setTimeout(r, speedDuration));
  agent.el.classList.remove('active');
};

// Optimized response handler
const handleResponse = async (prompt, answer) => {
  agents.echo.el.classList.add('active');
  const displayProgress = QuantumAccelerator.accelerate(0, 2, 1.1);
  updateProgress('echo', displayProgress);

  agents.echo.content.innerHTML = `<div class="verbose-thinking">🚀 QUANTUM PROCESSING: Depth ${thinkingDepth}</div>`;

  if (isQuestion(prompt)) {
    agents.echo.content.innerHTML += `<div class="verbose-thinking">🎯 QUESTION DETECTED</div>`;
    await generateSpeech(answer);
  } else {
    agents.echo.content.innerHTML += `<div class="verbose-thinking">⚡ CODE GENERATION</div>`;
    try {
      const codeMatch = answer.match(/```(?:javascript|js)\n([\s\S]*?)\n```/i);
      const content = codeMatch ? codeMatch[1].trim() : answer.trim();
      const highlighted = Prism.highlight(content, Prism.languages.javascript, 'javascript');
      agents.echo.content.innerHTML += `<pre class="language-javascript"><code>${highlighted}</code></pre>`;
    } catch(e) {
      agents.echo.content.innerHTML += `<div class="verbose-thinking">❌ ${e.message}</div>`;
    }
  }

  updateProgress('echo', 100);
  setTimeout(() => agents.echo.el.classList.remove('active'), 500);
};

// MAIN QUANTUM WORKFLOW
const startQuantumProcess = async (promptText) => {
  if (generating || speaking) return;
  generating = true;
  
  const submitBtn = document.getElementById('prompt-submit');
  submitBtn.disabled = true;

  // Hide prompt panel after submission
  hidePrompt();

  // Reset all agents
  Object.values(agents).forEach(agent => {
    agent.progress = 0;
    updateProgress(Object.keys(agents).find(k => agents[k] === agent), 0);
    agent.content.innerHTML = `<div style="display: flex; align-items: center; gap: 8px;"><div class="spinner"></div><span>Quantum initialization...</span></div>`;
    agent.el.classList.remove('active');
  });

  agents.echo.content.innerHTML = `<div class="verbose-thinking">🌌 QUANTUM BOOT: Starting hyper-threaded processing...</div>`;

  try {
    // PHASE 1: INIT
    const inputRect = document.getElementById('prompt-container').getBoundingClientRect();
    const nexusRect = agents.nexus.el.getBoundingClientRect();
    
    animatePacket(inputRect, nexusRect, async () => {
      await agentStep('nexus', `Command received. Entangling agents...`, 300, 5);

      // PHASE 2: PROCESS
      const cognitoRect = agents.cognito.el.getBoundingClientRect();
      animatePacket(nexusRect, cognitoRect, async () => {
        await agentStep('cognito', `Executing fractal reasoning...`, 800, 6);

        const systemPrompt = isQuestion(promptText)
          ? "Be concise and analytical. Provide direct answers with quantum-inspired insights."
          : "Provide clean, commented JavaScript code only with quantum optimization patterns.";

        const payload = {
          contents: [{ parts: [{ text: promptText }] }],
          systemInstruction: { parts: [{ text: systemPrompt }] },
          generationConfig: { temperature: 0.7, topK: 40 }
        };

        let responseData = null;
        for (let i = 0; i < 2; i++) {
          try {
            const response = await fetch(API_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
            if (response.ok) {
              responseData = await response.json();
              break;
            }
            if (response.status === 429 && i < 1) {
              await new Promise(r => setTimeout(r, 1000));
              continue;
            }
            throw new Error(`API: ${response.status}`);
          } catch (e) {
            if (i === 1) throw e;
          }
        }

        // PHASE 3: VALIDATE & OUTPUT
        const cognitoUpdated = agents.cognito.el.getBoundingClientRect();
        const echoRect = agents.echo.el.getBoundingClientRect();
        
        animatePacket(cognitoUpdated, echoRect, async () => {
          // Apply multi-agent acceleration
          QuantumAccelerator.accelerateAll(new Map([
            ['relay', {progress: 50, complexity: 1.0}],
            ['sentinel', {progress: 60, complexity: 1.2}],
            ['echo', {progress: 70, complexity: 1.4}]
          ]), thinkingDepth);

          await agentStep('relay', `Hyper-threaded transmission...`, 300, 4);
          await agentStep('sentinel', `Quantum validation...`, 400, 5);
          await agentStep('echo', `Generating final report...`, 300, 6);

          const text = responseData?.candidates?.[0]?.content?.parts?.[0]?.text || "No quantum response detected.";
          agents.echo.content.innerHTML = `<div class="verbose-thinking">✅ QUANTUM PROCESSING COMPLETE</div>`;
          await handleResponse(promptText, text);

          // Final state updates
          setTimeout(() => {
            agents.nexus.content.innerHTML = 'Quantum equilibrium achieved. Ready for next command.';
            agents.cognito.content.innerHTML = 'Fractal reasoning stored. Standing by.';
            agents.relay.content.innerHTML = 'Entanglement maintained. Channel open.';
            agents.sentinel.content.innerHTML = 'Superstate monitoring active. System stable.';
          }, 1000);

          generating = false;
          submitBtn.disabled = false;
          thinkingDepth = Math.min(8, thinkingDepth + 0.3);
        });
      });
    });

  } catch (e) {
    console.error("Quantum process failed:", e);
    Object.values(agents).forEach(a => {
      a.content.innerHTML = `<span style="color: #ff4440;">QUANTUM COLLAPSE: ${e.message}</span>`;
    });
    generating = false;
    submitBtn.disabled = false;
    showPrompt(); // Show prompt again on error
  }
};

// Optimized Three.js background
let scene, camera, renderer, uniforms;
function initBackground() {
  scene = new THREE.Scene();
  camera = new THREE.Camera();
  camera.position.z = 1;
  renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas'), alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);

  uniforms = { 
    time: { value: 1.0 }, 
    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) } 
  };
  
  const material = new THREE.ShaderMaterial({
    uniforms,
    vertexShader: `void main(){gl_Position=vec4(position,1.0);}`,
    fragmentShader: `
      uniform float time; uniform vec2 resolution;
      void main(){
        vec2 uv = (gl_FragCoord.xy-0.5*resolution.xy)/resolution.y;
        uv *= 2.0;
        float q = sin(uv.x*8.0+time)*cos(uv.y*6.0+time/1.5);
        vec3 color = 0.5+0.5*cos(3.14159*(uv.xyx+vec3(0,0.6,0.9)+q*0.2));
        color *= vec3(0.1,0.15,0.3)+q*0.15;
        gl_FragColor=vec4(color,1.0);
      }`
  });
  
  scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material));
  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
  });
  
  function animate() {
    requestAnimationFrame(animate);
    uniforms.time.value += 0.015;
    renderer.render(scene, camera);
  }
  animate();
}

// Optimized TTS functions
const generateSpeech = async (text) => {
  if (speaking) return;
  agents.echo.content.innerHTML = `<div style="display: flex; align-items: center; gap: 8px;"><div class="spinner"></div><span>Generating quantum speech...</span></div>`;

  try {
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${CONFIG.apiKey}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{ parts: [{ text }] }],
        generationConfig: { responseModalities: ["AUDIO"], speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Kore" } } } },
      })
    });

    if (!response.ok) throw new Error(`TTS: ${response.status}`);
    
    const data = await response.json();
    const audioData = data?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
    
    if (audioData) {
      const binary = atob(audioData);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      
      const blob = new Blob([bytes], { type: 'audio/wav' });
      const url = URL.createObjectURL(blob);
      const audio = new Audio(url);
      
      audio.onplay = () => { speaking = true; agents.echo.el.classList.add('active'); };
      audio.onended = () => { speaking = false; agents.echo.el.classList.remove('active'); URL.revokeObjectURL(url); };
      audio.play();
    }
  } catch (e) {
    agents.echo.content.innerHTML = `<span style="color: #ff4440;">Quantum TTS Error</span>`;
  }
};

// Initialize system
window.addEventListener('load', () => {
  initBackground();
  const input = document.getElementById('prompt-input');
  const submit = document.getElementById('prompt-submit');

  // Set initial states
  Object.keys(agents).forEach(key => {
    agents[key].content.innerHTML = getDefaultState(`agent-${key}`);
  });

  const handleSubmit = () => {
    const text = input.value.trim();
    if (text && !generating && !speaking) {
      startQuantumProcess(text);
      input.value = '';
    }
  };

  submit.addEventListener('click', handleSubmit);
  input.addEventListener('keypress', e => { 
    if (e.key === 'Enter') handleSubmit(); 
  });

  console.log("🌌 FULL-WIDTH QUANTUM SYSTEM INITIALIZED");
  console.log("⚡ Prompt panel will auto-hide after command submission");
  console.log("🔄 Use control buttons to show prompt or reset system");
});
</script>
</body>
</html>
```

Key Layout Changes:

1. Full-Width Panel Layout:

· Vertical grid layout with 5 full-width rows
· Each agent takes full horizontal space
· Optimized spacing for maximum information density

2. Smart Prompt Management:

· Prompt panel auto-hides after command submission
· Control buttons to show prompt or reset system
· Smooth transitions with fade effects

3. Enhanced Agent Cards:

· Header layout with title and subtitle
· Flexible content areas that expand to fill space
· Proper overflow handling for code and text

4. Control Panel:

· Always visible in bottom-right corner
· Show Prompt button to reveal input when needed
· Reset System button to clear everything

5. Improved User Experience:

· Focus remains on agent outputs after submission
· Easy access to prompt when needed
· Clear visual hierarchy with full-width panels
· Responsive design that works on all screen sizes

6. Layout Structure:

```
Top: Nexus (Orchestrator)
Large Middle: Echo (Main Output)
Bottom Three: Cognito, Relay, Sentinel (Support Agents)
```

The system now provides a clean, focused interface where the prompt disappears after use, letting you focus entirely on the quantum agent outputs while maintaining easy access to controls.
