<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nemodian 2244-1 :: Quantum Fractal AI Editor</title>

    <!-- js-beautify via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.0/beautify.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.0/beautify-css.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.0/beautify-html.js"></script>
    
    <!-- Import map for Gemini -->
    <script type="importmap">
{
  "imports": {
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.2.7.0",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0"
  }
}
</script>

    <style>
        :root {
            --muted: #888;
            --info: #2196F3;
            --warn: #FF9800;
            --error: #F44336;
            --success: #4CAF50;
            --baseline: 1.5em;
            --header-h: calc(var(--baseline) * 1.6);
            --status-h: var(--baseline);
            --footer-h: calc(var(--baseline) * 2);
            --font-size: 13px;
            --ln-width: 50px;
            --theme-bg: #3a3c31;
            --panel: #313328;
            --header-bg: #2e3026;
            --status-bg: #22241e;
            --accent: #4ac94a;
            --muted-text: #999966;
            --err: #a03333;
            --warn-bg: #f0ad4e;
            --hover-blue: #3366a0;
            --info-bg: #5bc0de;
            --agent-core: #BB86FC;
            --agent-loop: #03DAC6;
            --agent-2244: #FFD54F;
            --agent-coin: #CF6679;
            --agent-code: #4ac94a;
            --quantum-glow: rgba(187, 134, 252, 0.6);
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Fira Code', monospace;
            font-size: var(--font-size);
            line-height: var(--baseline);
            background: var(--theme-bg);
            color: #f0f0e0;
            overflow: hidden;
        }

        body {
            display: grid;
            grid-template-rows: var(--header-h) var(--status-h) 1fr var(--footer-h);
        }

        header {
            grid-row: 1;
            grid-column: 1 / -1;
            background: var(--header-bg);
            border-bottom: 1px solid #22241e;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 12px;
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, var(--quantum-glow), transparent);
            animation: quantumScan 3s infinite linear;
        }

        @keyframes quantumScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .quantum-pulse {
            animation: quantumPulse 2s infinite alternate;
        }

        .typing-active {
            caret-color: lime;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { background-color: transparent; }
            51%, 100% { background-color: rgba(0,255,0,0.05); }
        }

        @keyframes quantumPulse {
            0% { opacity: 0.7; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.05); }
        }

        header .left {
            display: flex;
            gap: 12px;
            align-items: center;
            position: relative;
            z-index: 2;
        }

        header .right {
            display: flex;
            gap: 8px;
            align-items: center;
            position: relative;
            z-index: 2;
        }

        button {
            background: var(--err);
            border: 1px solid var(--err);
            color: #f0f0e0;
            padding: 6px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all .2s;
            border-radius: 3px;
        }

        button:hover {
            background: var(--hover-blue);
            border-color: var(--hover-blue);
        }
        
        button:disabled {
             background: var(--muted-text);
             border-color: var(--muted-text);
             cursor: not-allowed;
        }

        button.success {
            background: var(--accent);
            border-color: var(--accent);
        }

        button.info {
            background: var(--info-bg);
            border-color: var(--info-bg);
        }

        button.warn {
            background: var(--warn-bg);
            border-color: var(--warn-bg);
            color: #3a3c31;
        }

        #status-bar {
            grid-row: 2;
            grid-column: 1 / -1;
            background: var(--status-bg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 12px;
            font-size: 12px;
            position: relative;
        }

        .quantum-threads {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.3;
        }

        .quantum-thread {
            position: absolute;
            width: 1px;
            height: 100%;
            background: linear-gradient(to bottom, transparent, var(--agent-core), transparent);
            animation: threadFlow 2s infinite linear;
        }

        @keyframes threadFlow {
            0% { top: -100%; }
            100% { top: 100%; }
        }

        #editor-stage {
            grid-row: 3;
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: 0px 1fr;
            background: var(--theme-bg);
            overflow: hidden;
            position: relative;
            transition: grid-template-columns 0.3s ease;
        }

        #editor-stage.left-panel-open {
            grid-template-columns: 240px 1fr;
        }

        #left-panel {
            background: var(--panel);
            border-right: 1px solid #22241e;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow: auto;
            width: 240px;
        }

        .editor-container {
            position: relative;
            display: flex;
            flex: 1;
            background: var(--theme-bg);
            overflow: auto;
        }

        .line-numbers {
            width: var(--ln-width);
            padding: 10px 8px;
            background: var(--panel);
            color: var(--muted-text);
            font-variant-numeric: tabular-nums;
            text-align: right;
            user-select: none;
            line-height: var(--baseline);
            font-family: inherit;
            font-size: inherit;
            flex-shrink: 0;
            position: sticky;
            left: 0;
            z-index: 10;
        }

        .editor-content {
            flex: 1;
            position: relative;
            min-height: 100%;
            padding: 10px;
            padding-left: 12px;
            box-sizing: border-box;
            white-space: pre;
            line-height: var(--baseline);
            font-family: inherit;
            font-size: inherit;
            tab-size: 4;
            -moz-tab-size: 4;
            caret-color: var(--accent);
            outline: none;
            overflow-wrap: normal;
            word-break: normal;
            overflow: auto;
        }

        .editor-content:focus {
            outline: none;
        }

        footer {
            grid-row: 4;
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 12px;
            background: var(--header-bg);
            border-top: 1px solid #22241e;
            position: sticky;
            bottom: 0;
        }

        #prompt-input {
            flex: 1;
            margin-right: 8px;
            padding: 8px;
            background: var(--status-bg);
            border: 1px solid var(--accent);
            color: #f0f0e0;
            font-family: inherit;
            border-radius: 3px;
            font-size: 16px;
        }

        .small {
            font-size: 12px;
            padding: 6px 8px;
        }

        .agent-card {
            background: var(--panel);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border-left: 4px solid var(--muted-text);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .agent-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s ease;
        }

        .agent-card.active::before {
            left: 100%;
        }

        .agent-card.active {
            box-shadow: 0 0 20px var(--quantum-glow);
            transform: translateY(-2px);
        }

        .agent-card.core { border-left-color: var(--agent-core); }
        .agent-card.loop { border-left-color: var(--agent-loop); }
        .agent-card.t2244 { border-left-color: var(--agent-2244); }
        .agent-card.coin { border-left-color: var(--agent-coin); }
        .agent-card.code { border-left-color: var(--agent-code); }

        .agent-title {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .agent-core .agent-title { color: var(--agent-core); }
        .agent-loop .agent-title { color: var(--agent-loop); }
        .agent-t2244 .agent-title { color: var(--agent-2244); }
        .agent-coin .agent-title { color: var(--agent-coin); }
        .agent-code .agent-title { color: var(--agent-code); }

        .agent-subtitle {
            font-size: 11px;
            color: var(--muted-text);
            margin-bottom: 6px;
        }

        .agent-content {
            font-size: 12px;
            line-height: 1.4;
            min-height: 20px;
        }

        .quantum-spinner {
            width: 16px;
            height: 16px;
            display: inline-block;
            margin-right: 6px;
            position: relative;
        }

        .quantum-spinner::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid transparent;
            border-top: 2px solid var(--agent-loop);
            border-radius: 50%;
            animation: quantumSpin 1s linear infinite;
        }

        .quantum-spinner::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid transparent;
            border-bottom: 2px solid var(--agent-core);
            border-radius: 50%;
            animation: quantumSpin 0.5s linear infinite;
        }

        @keyframes quantumSpin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .quantum-packet {
            position: fixed;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--agent-core);
            box-shadow: 0 0 10px var(--agent-core);
            opacity: 0;
            z-index: 100;
            pointer-events: none;
        }

        .quantum-trail {
            position: absolute;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--agent-core), transparent);
            opacity: 0;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--muted-text);
        }

        .action-buttons button {
            flex: 1;
            padding: 6px;
            font-size: 11px;
        }

        .quantum-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            margin-top: 5px;
        }

        .quantum-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--muted-text);
            position: relative;
        }

        .quantum-dot::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 50%;
            border: 1px solid var(--agent-core);
            animation: quantumPulseDot 2s infinite;
        }

        .quantum-dot.connected {
            background: var(--accent);
        }

        @keyframes quantumPulseDot {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }

        /* ========== SYNTAX HIGHLIGHTING STYLES ========== */
        .sh-token { transition: opacity 0.08s ease; pointer-events: none; }
        .sh-comment { color: #64748b; font-style: italic; opacity: 0.8; }
        .sh-string { color: #a3e635; font-weight: 500; }
        .sh-number { color: #f59e0b; font-weight: 600; }
        .sh-keyword { color: #f472b6; font-weight: 600; }
        .sh-type { color: #7dd3fc; font-weight: 500; }
        .sh-bracket { color: #c084fc; font-weight: 700; }
        .sh-id { color: #94a3b8; }
        .sh-op { color: #94a3b8; font-weight: 500; }
        .sh-ws { opacity: 0.3; }
        .sh-key { color: #7dd3fc; font-weight: 500; }
        .sh-number2 { color: #f59e0b; font-weight: 600; }
        .sh-text { color: #e2e8f0; }
        .sh-unknown { color: #f87171; }
        .sh-tag { color: #f472b6; font-weight: 600; }
        .sh-property { color: #7dd3fc; font-weight: 500; }
        .sh-function { color: #4ac94a; font-weight: 500; }
        .sh-operator { color: #93c5fd; font-weight: 600; }
        .sh-regex { color: #fbbf24; }
        .sh-html-entity { color: #f59e0b; }
        .sh-css-selector { color: #c084fc; }
        .sh-css-property { color: #60a5fa; }
        .sh-css-value { color: #34d399; }
        .sh-jsx-tag { color: #f472b6; }
        .sh-jsx-attribute { color: #7dd3fc; }
        .sh-template-string { color: #a3e635; font-weight: 500; }
        .sh-variable { color: #67e8f9; }

        .editor-content::selection {
            background: rgba(74, 201, 74, 0.3);
        }

        .editor-container::-webkit-scrollbar {
            width: 12px;
        }

        .editor-container::-webkit-scrollbar-track {
            background: var(--panel);
        }

        .editor-container::-webkit-scrollbar-thumb {
            background: var(--muted-text);
            border-radius: 6px;
        }

        .editor-container::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        #preview-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            background: white;
            border: 2px solid var(--accent);
            border-radius: 5px;
            z-index: 1000;
            display: none;
            flex-direction: column;
            box-shadow: 0 0 30px rgba(0,0,0,.7);
        }

        #preview-header {
            background: var(--header-bg);
            color: #f0f0e0;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--accent);
        }

        #preview-content {
            width: 100%;
            height: calc(100% - 40px);
            border: none;
            background: white;
        }

        #close-preview {
            background: transparent;
            border: none;
            color: #f0f0e0;
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #ai-response-panel {
            position: fixed;
            bottom: 60px;
            right: 20px;
            width: 500px;
            max-height: 600px;
            background: var(--panel);
            border: 1px solid var(--accent);
            border-radius: 5px;
            padding: 15px;
            overflow-y: auto;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,.3);
        }

        #ai-response-content {
            font-size: 12px;
            line-height: 1.4;
        }

        #close-ai-panel {
            position: absolute;
            top: 5px;
            right: 5px;
            background: transparent;
            border: none;
            color: var(--muted-text);
            font-size: 14px;
            cursor: pointer;
        }

        #file-input {
            display: none;
        }

        .ai-status {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .ai-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--err);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .ai-dot.connected {
            background: var(--accent);
            animation: none;
        }

        .quantum-thinking {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .fractal-node {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: var(--agent-loop);
            animation: fractalPulse 1.5s infinite alternate;
        }

        @keyframes fractalPulse {
            0% { transform: scale(1); opacity: 0.3; }
            100% { transform: scale(1.5); opacity: 0.8; }
        }

        @media (max-width: 768px) {
            #editor-stage {
                grid-template-columns: 1fr !important;
            }

            #left-panel {
                position: absolute;
                height: 100%;
                z-index: 30;
                transform: translateX(-240px);
            }

            #editor-stage.left-panel-open #left-panel {
                transform: translateX(0);
            }

            #ai-response-panel {
                width: calc(100% - 40px);
                right: 20px;
                left: 20px;
            }

            #preview-panel {
                width: 95%;
                height: 85%;
            }

            body {
                grid-template-rows: var(--header-h) var(--status-h) 1fr auto;
            }

            footer {
                position: relative;
            }
        }

        .consensus-panel {
            background: var(--panel);
            border: 1px solid var(--agent-core);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .consensus-header {
            font-weight: bold;
            color: var(--agent-core);
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .candidate-item {
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 8px;
            border-left: 3px solid var(--agent-loop);
        }

        .candidate-meta {
            font-size: 10px;
            color: var(--muted-text);
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .candidate-content {
            font-size: 11px;
            font-family: 'Fira Code', monospace;
            white-space: pre-wrap;
            max-height: 80px;
            overflow: hidden;
        }

        .entropy-badge {
            background: var(--agent-core);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
        }

        .selected-candidate {
            border-left-color: var(--accent);
            background: rgba(74, 201, 74, 0.1);
        }

        .orchestration-log {
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            padding: 8px;
            margin-top: 10px;
            max-height: 120px;
            overflow-y: auto;
            font-size: 10px;
            font-family: 'Fira Code', monospace;
        }

        .orchestration-log .log-entry {
            margin-bottom: 4px;
            padding-left: 10px;
            border-left: 2px solid var(--agent-core);
        }

        .orchestration-log .log-entry.genesis {
            border-left-color: var(--agent-core);
            color: var(--agent-core);
        }

        .orchestration-log .log-entry.origin {
            border-left-color: var(--agent-loop);
            color: var(--agent-loop);
        }

        .orchestration-log .log-entry.event {
            border-left-color: var(--agent-2244);
            color: var(--agent-2244);
        }

        .orchestration-log .log-entry.fragment {
            border-left-color: var(--agent-coin);
            color: var(--agent-coin);
        }

        .orchestration-log .log-entry.consensus {
            border-left-color: var(--agent-code);
            color: var(--agent-code);
        }

        .memory-status {
            font-size: 10px;
            color: var(--muted-text);
            padding: 2px 6px;
            border-radius: 3px;
            background: rgba(0,0,0,0.3);
        }

        .memory-status.low {
            color: #f87171;
            background: rgba(248, 113, 113, 0.1);
        }

        .memory-status.warning {
            color: #f59e0b;
            background: rgba(245, 158, 11, 0.1);
        }

        .memory-status.good {
            color: #4ac94a;
        }

        .suggestion-item {
            padding: 8px;
            border-bottom: 1px solid var(--muted-text);
            cursor: pointer;
            transition: background 0.2s;
        }

        .suggestion-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        #suggestions-panel {
            position: absolute;
            background: var(--panel);
            border: 1px solid var(--accent);
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
<header>
    <div class="left">
        <button id="left-toggle" class="small">☰</button>
        <div style="font-weight:800;" class="quantum-pulse">Nemodian 2244-1 :: Quantum Fractal AI</div>
    </div>
    <div class="right">
        <div class="ai-status">
            <div id="ai-dot" class="ai-dot"></div>
            <div id="ai-indicator" style="font-size:12px;color:#cfcfbd;">Quantum AI: Probing...</div>
        </div>
        <button id="open-file" class="small">Open</button>
        <button id="save-file" class="small">Save</button>
        <button id="save-as" class="small">Save As</button>
        <button id="render-html" class="small warn">Render HTML</button>
        <button id="run-local-ai" class="small info">Quantum AI</button>
        <button id="run-orchestrator" class="small success">Orchestrator</button>
    </div>
</header>
<div id="status-bar" class="info">
    <div class="quantum-threads" id="quantum-threads"></div>
    <div id="file-meta">No File Loaded</div>
    <div id="editor-meta">Cursor: 0:0 | Lines: 0 | Chars: 0 | History: 0</div>
    <div id="memory-status" class="memory-status good">RAM: OK</div>
</div>
<div id="editor-stage">
    <aside id="left-panel" class="closed">
        <button id="btn-undo" class="small">UNDO</button>
        <button id="btn-redo" class="small">REDO</button>
        <button id="btn-beautify" class="small">Beautify</button>
        <button id="btn-render" class="small warn">Render HTML</button>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Quantum AI Commands:</strong></p>
            <ul style="padding-left: 15px;">
                <li>Rewrite this function</li>
                <li>Optimize performance</li>
                <li>Add error handling</li>
                <li>Convert to TypeScript</li>
                <li>Explain this code</li>
            </ul>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Quantum Actions:</strong></p>
            <button id="btn-optimize" class="small" style="width:100%;margin-bottom:5px;">Quantum Optimize</button>
            <button id="btn-document" class="small" style="width:100%;margin-bottom:5px;">Fractal Document</button>
            <button id="btn-refactor" class="small" style="width:100%;">Hyper Refactor</button>
            <button id="btn-orchestrate" class="small success" style="width:100%;margin-top:5px;">Multi-Agent Consensus</button>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Memory Management:</strong></p>
            <button id="btn-clear-cache" class="small" style="width:100%;margin-bottom:5px;">Clear Cache</button>
            <button id="btn-optimize-memory" class="small info" style="width:100%;margin-bottom:5px;">Optimize Memory</button>
            <button id="btn-export-session" class="small" style="width:100%;">Export Session</button>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Quantum Settings:</strong></p>
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                <input type="checkbox" id="quantum-mode" checked>
                <label for="quantum-mode">Quantum Fractal Mode</label>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
                <input type="checkbox" id="hyperthreading" checked>
                <label for="hyperthreading">Hyperthreading</label>
            </div>
            <div style="display: flex; align-items: center; gap: 8px; margin-top: 5px;">
                <input type="checkbox" id="multi-agent-mode" checked>
                <label for="multi-agent-mode">Multi-Agent Consensus</label>
            </div>
            <div style="display: flex; align-items: center; gap: 8px; margin-top: 5px;">
                <input type="checkbox" id="auto-save" checked>
                <label for="auto-save">Auto Save</label>
            </div>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Orchestrator Settings:</strong></p>
            <div style="margin-bottom: 5px;">
                <label for="agent-count">Agent Count:</label>
                <input type="number" id="agent-count" min="2" max="8" value="5" style="width: 60px; background: var(--status-bg); color: white; border: 1px solid var(--muted-text); padding: 2px; border-radius: 3px;">
            </div>
            <div style="margin-bottom: 5px;">
                <label for="max-rounds">Max Rounds:</label>
                <input type="number" id="max-rounds" min="1" max="10" value="3" style="width: 60px; background: var(--status-bg); color: white; border: 1px solid var(--muted-text); padding: 2px; border-radius: 3px;">
            </div>
            <div style="margin-bottom: 5px;">
                <label for="reasoning-depth">Reasoning Depth:</label>
                <input type="number" id="reasoning-depth" min="1" max="5" value="3" style="width: 60px; background: var(--status-bg); color: white; border: 1px solid var(--muted-text); padding: 2px; border-radius: 3px;">
            </div>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Recent Files:</strong></p>
            <div id="recent-files" style="max-height: 100px; overflow-y: auto;">
                <!-- Recent files will be populated here -->
            </div>
        </div>
    </aside>

    <!-- Quantum Editor Container -->
    <div class="editor-container">
        <div class="quantum-thinking" id="quantum-thinking"></div>
        <div class="line-numbers" id="line-numbers"></div>
        <div
            class="editor-content"
            id="editor"
            contenteditable="true"
            spellcheck="false"
            data-gramm="false"
            data-gramm_editor="false"
            data-enable-grammarly="false"
        >// Quantum Fractal AI Editor - Ready
// Start coding or use the prompt below for AI assistance

function welcome() {
    return "Welcome to the Quantum Fractal AI Editor!";
}</div>
    </div>
</div>
<footer>
    <input id="prompt-input" placeholder="Enter quantum command (e.g., 'create a function to sort arrays')">
    <button id="send-button" class="success">QUANTUM PROCESS</button>
</footer>

<!-- Hidden elements -->
<input type="file" id="file-input" accept=".js,.html,.css,.txt,.json,.ts,.jsx,.tsx,.py,.php,.sql,.md,.xml,.yaml,.yml">
<div id="suggestions-panel"></div>

<!-- Panels -->
<div id="preview-panel">
    <div id="preview-header">
        <span>Quantum Preview</span>
        <button id="close-preview">×</button>
    </div>
    <iframe id="preview-content"></iframe>
</div>

<div id="ai-response-panel">
    <button id="close-ai-panel">×</button>
    <div id="ai-response-content">
        <div class="agent-card core agent-core">
            <div class="agent-title">Core</div>
            <div class="agent-subtitle">Quantum Orchestrator (Fractal Core)</div>
            <div class="agent-content">Idle. Awaiting quantum command.</div>
            <div class="orchestration-log" id="core-log"></div>
            <div class="quantum-status">
                <div class="quantum-dot connected"></div>
                <span>Quantum State: Entangled</span>
            </div>
        </div>
        <div class="agent-card loop agent-loop">
            <div class="agent-title">Loop</div>
            <div class="agent-subtitle">Fractal Analyzer (Quantum Loop)</div>
            <div class="agent-content">Ready</div>
            <div class="orchestration-log" id="loop-log"></div>
        </div>
        <div class="agent-card t2244 agent-t2244">
            <div class="agent-title">2244</div>
            <div class="agent-subtitle">Quantum Communicator (Temporal)</div>
            <div class="agent-content">Ready</div>
            <div class="orchestration-log" id="2244-log"></div>
        </div>
        <div class="agent-card coin agent-coin">
            <div class="agent-title">Coin</div>
            <div class="agent-subtitle">Quantum Monitor (Entropy Coin)</div>
            <div class="agent-content">Ready</div>
            <div class="orchestration-log" id="coin-log"></div>
        </div>
        <div class="agent-card code agent-code">
            <div class="agent-title">Code</div>
            <div class="agent-subtitle">Quantum Assembler (Final Code)</div>
            <div class="agent-content">Awaiting assembly instructions...</div>
            <div class="orchestration-log" id="code-log" style="border-left-color: var(--accent);"></div>
        </div>
        <div class="consensus-panel" id="consensus-panel" style="display: none;">
            <div class="consensus-header">
                <span>Multi-Agent Consensus Results</span>
                <span class="entropy-badge" id="consensus-score">Score: 0</span>
            </div>
            <div id="candidates-list"></div>
        </div>
    </div>
</div>

<!-- GSAP for animations -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

<script type="module">
    import { GoogleGenAI } from "@google/genai";
    /* =========================================================================
       QUANTUM FRACTAL AI EDITOR - FULL FUNCTIONALITY
       ========================================================================== */

    // Global state
    window.quantumState = {
        isGenerating: false,
        isSpeaking: false,
        currentSession: null,
        recentFiles: [],
        settings: {
            quantumMode: true,
            hyperthreading: true,
            multiAgentMode: true,
            autoSave: true,
            agentCount: 5,
            maxRounds: 3,
            reasoningDepth: 3
        }
    };

    /* =========================================================================
       MEMORY MANAGER - Enhanced with Full Features
       ========================================================================== */

    class QuantumMemoryManager {
        constructor() {
            this.storageKey = 'quantum_editor_cache';
            this.settingsKey = 'quantum_editor_settings';
            this.recentFilesKey = 'quantum_recent_files';
            this.maxMemoryThreshold = 50 * 1024 * 1024;
            this.cacheLimit = 100;
            this.memoryStatus = document.getElementById('memory-status');
            this.cleanupInterval = null;
            
            this.init();
        }

        init() {
            this.loadSettings();
            this.loadRecentFiles();
            this.startMemoryMonitoring();
            this.cleanupOldCache();
        }

        startMemoryMonitoring() {
            this.cleanupInterval = setInterval(() => {
                this.checkMemoryUsage();
            }, 30000);

            window.addEventListener('beforeunload', () => this.cleanup());
        }

        async checkMemoryUsage() {
            try {
                if ('memory' in performance) {
                    const memory = performance.memory;
                    const used = memory.usedJSHeapSize;
                    const limit = memory.jsHeapSizeLimit;
                    
                    const usagePercent = (used / limit) * 100;
                    
                    if (usagePercent > 80) {
                        this.memoryStatus.textContent = 'RAM: CRITICAL';
                        this.memoryStatus.className = 'memory-status low';
                        this.emergencyCleanup();
                    } else if (usagePercent > 60) {
                        this.memoryStatus.textContent = 'RAM: WARNING';
                        this.memoryStatus.className = 'memory-status warning';
                        this.aggressiveCleanup();
                    } else {
                        this.memoryStatus.textContent = 'RAM: OK';
                        this.memoryStatus.className = 'memory-status good';
                    }
                }
            } catch (error) {
                console.warn('Memory monitoring unavailable:', error);
            }
        }

        // Settings management
        loadSettings() {
            try {
                const stored = localStorage.getItem(this.settingsKey);
                if (stored) {
                    const settings = JSON.parse(stored);
                    window.quantumState.settings = { ...window.quantumState.settings, ...settings };
                    this.applySettings();
                }
            } catch (error) {
                console.warn('Settings load failed:', error);
            }
        }

        saveSettings() {
            try {
                localStorage.setItem(this.settingsKey, JSON.stringify(window.quantumState.settings));
            } catch (error) {
                console.warn('Settings save failed:', error);
            }
        }

        applySettings() {
            const settings = window.quantumState.settings;
            document.getElementById('quantum-mode').checked = settings.quantumMode;
            document.getElementById('hyperthreading').checked = settings.hyperthreading;
            document.getElementById('multi-agent-mode').checked = settings.multiAgentMode;
            document.getElementById('auto-save').checked = settings.autoSave;
            document.getElementById('agent-count').value = settings.agentCount;
            document.getElementById('max-rounds').value = settings.maxRounds;
            document.getElementById('reasoning-depth').value = settings.reasoningDepth;
        }

        // Recent files management
        loadRecentFiles() {
            try {
                const stored = localStorage.getItem(this.recentFilesKey);
                if (stored) {
                    window.quantumState.recentFiles = JSON.parse(stored);
                    this.updateRecentFilesUI();
                }
            } catch (error) {
                console.warn('Recent files load failed:', error);
            }
        }

        saveRecentFiles() {
            try {
                localStorage.setItem(this.recentFilesKey, JSON.stringify(window.quantumState.recentFiles));
            } catch (error) {
                console.warn('Recent files save failed:', error);
            }
        }

        addRecentFile(filename, content) {
            // Remove if already exists
            window.quantumState.recentFiles = window.quantumState.recentFiles.filter(f => f.filename !== filename);
            
            // Add to beginning
            window.quantumState.recentFiles.unshift({
                filename,
                content: content.substring(0, 1000), // Store only preview
                timestamp: Date.now()
            });

            // Keep only last 10 files
            window.quantumState.recentFiles = window.quantumState.recentFiles.slice(0, 10);
            
            this.saveRecentFiles();
            this.updateRecentFilesUI();
        }

        updateRecentFilesUI() {
            const container = document.getElementById('recent-files');
            container.innerHTML = '';

            window.quantumState.recentFiles.forEach(file => {
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.innerHTML = `
                    <div style="font-weight: bold;">${file.filename}</div>
                    <div style="font-size: 9px; color: var(--muted-text);">${new Date(file.timestamp).toLocaleDateString()}</div>
                `;
                item.addEventListener('click', () => {
                    quantumEditor.setContent(file.content, quantumEditor.highlighter.detectLanguage(file.filename));
                    document.getElementById('file-meta').textContent = file.filename;
                    quantumEditor.currentFileName = file.filename;
                });
                container.appendChild(item);
            });

            if (window.quantumState.recentFiles.length === 0) {
                container.innerHTML = '<div style="padding: 8px; color: var(--muted-text); font-size: 10px;">No recent files</div>';
            }
        }

        async store(key, data, priority = 'medium') {
            try {
                const cache = this.getCache();
                const dataSize = new Blob([JSON.stringify(data)]).size;
                if (dataSize > this.maxMemoryThreshold) {
                    throw new Error('Data too large for storage');
                }

                cache[key] = {
                    data: data,
                    timestamp: Date.now(),
                    priority: priority,
                    size: dataSize
                };

                if (Object.keys(cache).length > this.cacheLimit) {
                    this.cleanupCache();
                }

                await this.saveCache(cache);
                return true;
            } catch (error) {
                console.warn('Storage failed, falling back to memory:', error);
                if (!window.quantumMemoryCache) {
                    window.quantumMemoryCache = new Map();
                }
                window.quantumMemoryCache.set(key, data);
                return false;
            }
        }

        async retrieve(key) {
            try {
                const cache = this.getCache();
                if (cache[key]) {
                    return cache[key].data;
                }
                
                if (window.quantumMemoryCache && window.quantumMemoryCache.has(key)) {
                    return window.quantumMemoryCache.get(key);
                }
                
                return null;
            } catch (error) {
                console.warn('Retrieval failed:', error);
                return null;
            }
        }

        cleanupCache() {
            try {
                const cache = this.getCache();
                const entries = Object.entries(cache);
                
                if (entries.length > this.cacheLimit) {
                    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
                    const toRemove = entries.slice(0, Math.floor(entries.length * 0.3));
                    toRemove.forEach(([key]) => delete cache[key]);
                    this.saveCache(cache);
                }
            } catch (error) {
                console.warn('Cache cleanup failed:', error);
            }
        }

        emergencyCleanup() {
            try {
                localStorage.removeItem(this.storageKey);
                sessionStorage.clear();
                
                if (window.quantumMemoryCache) {
                    window.quantumMemoryCache.clear();
                }
                
                if (window.gc) window.gc();
                this.clearLargeArrays();
                console.log('Emergency memory cleanup completed');
            } catch (error) {
                console.error('Emergency cleanup failed:', error);
            }
        }

        aggressiveCleanup() {
            try {
                const cache = this.getCache();
                const entries = Object.entries(cache);
                const toKeep = entries.filter(([key, entry]) => 
                    entry.priority === 'high' && entry.size < 1024 * 1024
                );
                this.saveCache(Object.fromEntries(toKeep));
                
                if (window.quantumMemoryCache) {
                    const keys = Array.from(window.quantumMemoryCache.keys());
                    keys.slice(0, Math.floor(keys.length * 0.5)).forEach(key => 
                        window.quantumMemoryCache.delete(key)
                    );
                }
                console.log('Aggressive memory cleanup completed');
            } catch (error) {
                console.warn('Aggressive cleanup failed:', error);
            }
        }

        clearLargeArrays() {
            if (window.largeArrays) {
                window.largeArrays.clear();
            }
        }

        cleanupOldCache() {
            const cache = this.getCache();
            const now = Date.now();
            const oneHour = 60 * 60 * 1000;
            
            Object.keys(cache).forEach(key => {
                if (now - cache[key].timestamp > oneHour) {
                    delete cache[key];
                }
            });
            this.saveCache(cache);
        }

        getCache() {
            try {
                const stored = localStorage.getItem(this.storageKey);
                return stored ? JSON.parse(stored) : {};
            } catch (error) {
                console.warn('Cache retrieval failed:', error);
                return {};
            }
        }

        async saveCache(cache) {
            try {
                localStorage.setItem(this.storageKey, JSON.stringify(cache));
            } catch (error) {
                console.warn('Cache save failed:', error);
            }
        }

        cleanup() {
            if (this.cleanupInterval) {
                clearInterval(this.cleanupInterval);
            }
        }

        async exportSession() {
            try {
                const sessionData = {
                    timestamp: Date.now(),
                    cache: this.getCache(),
                    memoryCache: window.quantumMemoryCache ? 
                        Array.from(window.quantumMemoryCache.entries()) : [],
                    recentFiles: window.quantumState.recentFiles,
                    settings: window.quantumState.settings
                };
                
                const blob = new Blob([JSON.stringify(sessionData, null, 2)], 
                    { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `quantum_session_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                return true;
            } catch (error) {
                console.error('Session export failed:', error);
                return false;
            }
        }

        async clearAllCache() {
            try {
                localStorage.removeItem(this.storageKey);
                localStorage.removeItem(this.settingsKey);
                localStorage.removeItem(this.recentFilesKey);
                if (window.quantumMemoryCache) {
                    window.quantumMemoryCache.clear();
                }
                sessionStorage.clear();
                return true;
            } catch (error) {
                console.error('Cache clearance failed:', error);
                return false;
            }
        }
    }

    /* =========================================================================
       ENHANCED QUANTUM SYNTAX HIGHLIGHTER
       ========================================================================== */

    class QuantumSyntaxHighlighter {
        constructor() {
            this.languagePatterns = {
                javascript: this.getJavaScriptPatterns(),
                typescript: this.getTypeScriptPatterns(),
                html: this.getHTMLPatterns(),
                css: this.getCSSPatterns(),
                python: this.getPythonPatterns(),
                php: this.getPHPPatterns(),
                sql: this.getSQLPatterns(),
                markdown: this.getMarkdownPatterns(),
                json: this.getJSONPatterns(),
                jsx: this.getJSXPatterns(),
                tsx: this.getTSXPatterns(),
                xml: this.getXMLPatterns(),
                yaml: this.getYAMLPatterns()
            };
            
            this.currentLanguage = 'javascript';
            this.debounceTimer = null;
            this.debounceDelay = 50;
        }

        getJavaScriptPatterns() {
            return [
                { pattern: /\/\/.*$/gm, type: 'comment' },
                { pattern: /\/\*[\s\S]*?\*\//g, type: 'comment' },
                { pattern: /`(?:\\.|[^`\\])*`/g, type: 'template-string' },
                { pattern: /'(?:\\.|[^'\\])*'/g, type: 'string' },
                { pattern: /"(?:\\.|[^"\\])*"/g, type: 'string' },
                { pattern: /\/(?![*\/])(?:\\.|[^\/\\\n])+\/[gimuy]*/g, type: 'regex' },
                { pattern: /\b\d+(\.\d+)?\b/g, type: 'number' },
                { pattern: /\b0x[a-fA-F0-9]+\b/g, type: 'number' },
                { pattern: /\b(?:function|class|const|let|var|if|else|for|while|do|switch|case|break|continue|return|try|catch|finally|throw|new|this|super|extends|implements|import|export|from|default|async|await|yield|static|public|private|protected|readonly|abstract|interface|type|namespace|module|declare|get|set|of|in|instanceof|typeof|void|delete)\b/g, type: 'keyword' },
                { pattern: /\b(?:console|Math|Date|Array|Object|String|Number|Boolean|Symbol|Map|Set|Promise|JSON|RegExp|Error|Function|Proxy|Reflect)\b/g, type: 'type' },
                { pattern: /\b[a-zA-Z_$][\w$]*(?=\s*\()/g, type: 'function' },
                { pattern: /[+\-*/%=<>!&|^~?:.,;]/g, type: 'operator' },
                { pattern: /[{}()[\]<>]/g, type: 'bracket' }
            ];
        }

        getTypeScriptPatterns() {
            const jsPatterns = this.getJavaScriptPatterns();
            jsPatterns.push(
                { pattern: /\b(?:interface|type|implements|namespace|module|declare|readonly|abstract|public|private|protected)\b/g, type: 'keyword' },
                { pattern: /:\s*\w+/g, type: 'type' }
            );
            return jsPatterns;
        }

        getHTMLPatterns() {
            return [
                { pattern: /<!--[\s\S]*?-->/g, type: 'comment' },
                { pattern: /<\/?[\w][\w-]*/g, type: 'tag' },
                { pattern: /(?<=<\/?[\w][\w-]*\s+)[\w-]+(?=\s*=)/g, type: 'property' },
                { pattern: /"(?:\\.|[^"\\])*"/g, type: 'string' },
                { pattern: /'(?:\\.|[^'\\])*'/g, type: 'string' },
                { pattern: /<!DOCTYPE\s+[^>]+>/gi, type: 'keyword' }
            ];
        }

        getCSSPatterns() {
            return [
                { pattern: /\/\*[\s\S]*?\*\//g, type: 'comment' },
                { pattern: /[.#]?[\w-]+\s*(?={)/g, type: 'css-selector' },
                { pattern: /[\w-]+(?=\s*:)/g, type: 'css-property' },
                { pattern: /:\s*[^;]+/g, type: 'css-value' },
                { pattern: /!important/gi, type: 'keyword' },
                { pattern: /@\w+/g, type: 'keyword' }
            ];
        }

        getPythonPatterns() {
            return [
                { pattern: /#.*$/gm, type: 'comment' },
                { pattern: /"""(?:.|\n)*?"""/g, type: 'string' },
                { pattern: /'''(?:.|\n)*?'''/g, type: 'string' },
                { pattern: /"(?:\\.|[^"\\])*"/g, type: 'string' },
                { pattern: /'(?:\\.|[^'\\])*'/g, type: 'string' },
                { pattern: /\b\d+(\.\d+)?\b/g, type: 'number' },
                { pattern: /\b(?:def|class|if|elif|else|for|while|try|except|finally|with|import|from|as|return|yield|async|await|lambda|None|True|False|and|or|not|in|is|global|nonlocal|del|pass|break|continue|raise)\b/g, type: 'keyword' },
                { pattern: /\b[a-zA-Z_][\w]*(?=\s*\()/g, type: 'function' },
                { pattern: /@\w+/g, type: 'function' }
            ];
        }

        getPHPPatterns() {
            return [
                { pattern: /\/\/.*$/gm, type: 'comment' },
                { pattern: /#.*$/gm, type: 'comment' },
                { pattern: /\/\*[\s\S]*?\*\//g, type: 'comment' },
                { pattern: /<\?php|\?>/g, type: 'tag' },
                { pattern: /'(?:\\.|[^'\\])*'/g, type: 'string' },
                { pattern: /"(?:\\.|[^"\\])*"/g, type: 'string' },
                { pattern: /\$\w+/g, type: 'variable' },
                { pattern: /\b(?:function|class|interface|trait|namespace|use|public|private|protected|static|final|abstract|const|if|else|elseif|for|foreach|while|do|switch|case|break|continue|return|try|catch|finally|throw|new|clone|instanceof|echo|print|die|exit|isset|unset|empty)\b/g, type: 'keyword' }
            ];
        }

        getSQLPatterns() {
            return [
                { pattern: /--.*$/gm, type: 'comment' },
                { pattern: /\/\*[\s\S]*?\*\//g, type: 'comment' },
                { pattern: /'(?:\\.|[^'\\])*'/g, type: 'string' },
                { pattern: /"(?:\\.|[^"\\])*"/g, type: 'string' },
                { pattern: /\b(?:SELECT|INSERT|UPDATE|DELETE|FROM|WHERE|JOIN|INNER|LEFT|RIGHT|OUTER|ON|AND|OR|NOT|IN|BETWEEN|LIKE|IS|NULL|ORDER BY|GROUP BY|HAVING|LIMIT|OFFSET|UNION|CREATE|ALTER|DROP|TABLE|INDEX|VIEW|DATABASE|TRIGGER|PROCEDURE|FUNCTION|VALUES|SET|DEFAULT|PRIMARY KEY|FOREIGN KEY|REFERENCES|CASCADE|UNIQUE|CHECK|EXISTS|CASE|WHEN|THEN|ELSE|END|DISTINCT|COUNT|SUM|AVG|MIN|MAX)\b/gi, type: 'keyword' },
                { pattern: /\b\d+(\.\d+)?\b/g, type: 'number' }
            ];
        }

        getMarkdownPatterns() {
            return [
                { pattern: /^#{1,6}\s+.+$/gm, type: 'keyword' },
                { pattern: /\*\*(.*?)\*\*/g, type: 'keyword' },
                { pattern: /\*(.*?)\*/g, type: 'comment' },
                { pattern: /`[^`]*`/g, type: 'string' },
                { pattern: /```[\s\S]*?```/g, type: 'template-string' },
                { pattern: /\[([^\]]+)\]\(([^)]+)\)/g, type: 'function' },
                { pattern: /^\s*[\-\*\+]\s+/gm, type: 'operator' },
                { pattern: /^\s*\d+\.\s+/gm, type: 'number' }
            ];
        }

        getJSONPatterns() {
            return [
                { pattern: /"(?:\\.|[^"\\])*"(?=\s*:)/g, type: 'key' },
                { pattern: /"(?:\\.|[^"\\])*"/g, type: 'string' },
                { pattern: /\b\d+(\.\d+)?\b/g, type: 'number' },
                { pattern: /\b(?:true|false|null)\b/g, type: 'keyword' }
            ];
        }

        getJSXPatterns() {
            const jsPatterns = this.getJavaScriptPatterns();
            jsPatterns.push(
                { pattern: /<\/?[A-Z][\w]*|<\/?[a-z][\w-]*/g, type: 'jsx-tag' },
                { pattern: /(?<=<[A-Z][\w]*\s+)[\w-]+(?=\s*=)/g, type: 'jsx-attribute' }
            );
            return jsPatterns;
        }

        getTSXPatterns() {
            const tsPatterns = this.getTypeScriptPatterns();
            tsPatterns.push(
                { pattern: /<\/?[A-Z][\w]*|<\/?[a-z][\w-]*/g, type: 'jsx-tag' },
                { pattern: /(?<=<[A-Z][\w]*\s+)[\w-]+(?=\s*=)/g, type: 'jsx-attribute' }
            );
            return tsPatterns;
        }

        getXMLPatterns() {
            return [
                { pattern: /<!--[\s\S]*?-->/g, type: 'comment' },
                { pattern: /<\/?[\w][\w-]*/g, type: 'tag' },
                { pattern: /(?<=<\/?[\w][\w-]*\s+)[\w-]+(?=\s*=)/g, type: 'property' },
                { pattern: /"(?:\\.|[^"\\])*"/g, type: 'string' },
                { pattern: /'(?:\\.|[^'\\])*'/g, type: 'string' }
            ];
        }

        getYAMLPatterns() {
            return [
                { pattern: /#.*$/gm, type: 'comment' },
                { pattern: /"(?:\\.|[^"\\])*"/g, type: 'string' },
                { pattern: /'(?:\\.|[^'\\])*'/g, type: 'string' },
                { pattern: /\b\d+(\.\d+)?\b/g, type: 'number' },
                { pattern: /^(?:\s*)[\w-]+(?=\s*:)/gm, type: 'key' },
                { pattern: /\b(?:true|false|null|yes|no|on|off)\b/gi, type: 'keyword' }
            ];
        }

        detectLanguage(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const languageMap = {
                'js': 'javascript', 'jsx': 'jsx', 'ts': 'typescript', 'tsx': 'tsx',
                'html': 'html', 'htm': 'html', 'css': 'css', 'py': 'python',
                'php': 'php', 'sql': 'sql', 'md': 'markdown', 'json': 'json',
                'txt': 'javascript', 'xml': 'xml', 'yaml': 'yaml', 'yml': 'yaml'
            };
            return languageMap[ext] || 'javascript';
        }

        setLanguage(language) {
            this.currentLanguage = language;
        }

        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        highlightText(text, language = null) {
            const lang = language || this.currentLanguage;
            if (!text) return '';
            
            const patterns = this.languagePatterns[lang] || this.languagePatterns.javascript;

            // Create a list of all matches
            const tokens = [];
            patterns.forEach(({ pattern, type }, priority) => {
                // Ensure all patterns are global for matchAll
                const globalPattern = new RegExp(pattern.source, pattern.flags.includes('g') ? pattern.flags : pattern.flags + 'g');
                for (const match of text.matchAll(globalPattern)) {
                    if (match[0].length === 0) continue; // Don't add empty matches
                    tokens.push({
                        start: match.index,
                        end: match.index + match[0].length,
                        type: type,
                        priority: priority,
                        length: match[0].length,
                    });
                }
            });

            // Sort tokens: by start index, then by length (longer first), then by priority
            tokens.sort((a, b) => {
                if (a.start !== b.start) return a.start - b.start;
                if (b.length !== a.length) return b.length - a.length;
                return a.priority - b.priority;
            });

            // Filter out overlapping tokens
            const filteredTokens = [];
            let lastEnd = -1;
            for (const token of tokens) {
                if (token.start >= lastEnd) {
                    filteredTokens.push(token);
                    lastEnd = token.end;
                }
            }

            // Build the final HTML
            let result = '';
            let lastIndex = 0;
            filteredTokens.forEach(token => {
                // Add text before the token
                result += this.escapeHtml(text.substring(lastIndex, token.start));
                // Add the highlighted token
                const tokenText = text.substring(token.start, token.end);
                result += `<span class="sh-token sh-${token.type}">${this.escapeHtml(tokenText)}</span>`;
                lastIndex = token.end;
            });

            // Add any remaining text
            if (lastIndex < text.length) {
                result += this.escapeHtml(text.substring(lastIndex));
            }
            
            return result;
        }

        highlightElement(element, language = null) {
            const text = element.textContent || '';
            
            // Preserve cursor position
            const selection = window.getSelection();
            const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
            let startOffset = range ? range.startOffset : 0;
            let startContainer = range ? range.startContainer : null;
            
            let path = [];
            let node = startContainer;
            while(node && node !== element) {
                let i = 0;
                let sibling = node;
                while((sibling = sibling.previousSibling) != null) i++;
                path.unshift(i);
                node = node.parentNode;
            }

            element.innerHTML = this.highlightText(text, language);
            
            // Restore cursor position
            try {
                if(startContainer) {
                    node = element;
                    path.forEach(index => { node = node.childNodes[index]; });
                    if(node) {
                        const newRange = document.createRange();
                        newRange.setStart(node, Math.min(startOffset, node.length || 0));
                        newRange.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(newRange);
                    }
                }
            } catch (e) {
                console.warn("Could not restore cursor position.", e);
            }
        }

        enableRealtimeHighlighting(editorElement, language = null) {
            let isComposing = false;
            
            const highlight = () => {
                if (isComposing) return;
                
                clearTimeout(this.debounceTimer);
                this.debounceTimer = setTimeout(() => {
                    this.highlightElement(editorElement, language);
                }, this.debounceDelay);
            };
            
            editorElement.addEventListener('input', highlight);
            editorElement.addEventListener('compositionstart', () => { isComposing = true; });
            editorElement.addEventListener('compositionend', () => { 
                isComposing = false; 
                highlight();
            });
            editorElement.addEventListener('paste', () => setTimeout(highlight, 10));
            
            highlight();
        }
    }

    /* =========================================================================
       ENHANCED QUANTUM EDITOR WITH COMPLETE FEATURES
       ========================================================================== */

    class QuantumEditor {
        constructor() {
            this.editor = document.getElementById('editor');
            this.lineNumbers = document.getElementById('line-numbers');
            this.statusEditor = document.getElementById('editor-meta');
            this.statusFile = document.getElementById('file-meta');
            this.memoryManager = new QuantumMemoryManager();
            this.highlighter = new QuantumSyntaxHighlighter();
            this.quantumThinking = document.getElementById('quantum-thinking');

            this.currentFileName = null;
            this.currentFileType = 'javascript';
            this.historyStack = [];
            this.redoStack = [];
            this.isComposing = false;
            this.quantumMode = true;
            this.hyperthreading = true;
            this.multiAgentMode = true;

            this.maxHistorySize = 50;
            this.debounceDelay = 100;
            this.chunkSize = 1000;
            this.autoSaveInterval = null;

            this.init();
        }

        init() {
            this.bindEvents();
            this.loadAutosave();
            this.pushHistory();
            this.initQuantumVisuals();
            this.enableRealtimeHighlighting();
            this.startAutoSave();
            this.updateLineNumbers();
        }

        startAutoSave() {
            if (window.quantumState.settings.autoSave) {
                this.autoSaveInterval = setInterval(() => {
                    this.saveAutosave();
                }, 30000); // Auto-save every 30 seconds
            }
        }

        stopAutoSave() {
            if (this.autoSaveInterval) {
                clearInterval(this.autoSaveInterval);
            }
        }

        async loadAutosave() {
            try {
                const autosave = await this.memoryManager.retrieve('autosave_content');
                if (autosave && !this.editor.textContent.trim()) {
                    this.render(autosave);
                    quantumNotify('Autosave restored', 'success');
                }
            } catch (error) {
                console.warn('Autosave load failed:', error);
            }
        }

        async saveAutosave() {
            if (!window.quantumState.settings.autoSave) return;
            
            try {
                const content = this.editor.textContent;
                if (content.trim()) {
                    await this.memoryManager.store('autosave_content', content, 'high');
                }
            } catch (error) {
                console.warn('Autosave failed:', error);
            }
        }

        bindEvents() {
            let inputTimeout;
            this.editor.addEventListener('input', () => {
                clearTimeout(inputTimeout);
                inputTimeout = setTimeout(() => {
                    this.handleInput();
                }, this.debounceDelay);
            });

            this.editor.addEventListener('compositionstart', () => this.isComposing = true);
            this.editor.addEventListener('compositionend', () => {
                this.isComposing = false;
                this.handleInput();
            });

            this.editor.addEventListener('keydown', this.handleKeydown.bind(this));
            this.editor.addEventListener('click', this.updateStatus.bind(this));
            this.editor.addEventListener('keyup', this.updateStatus.bind(this));
            this.editor.parentElement.addEventListener('scroll', this.syncScroll.bind(this));

            window.addEventListener('beforeunload', () => this.saveAutosave());
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    this.saveAutosave();
                }
            });

            document.getElementById('quantum-mode').addEventListener('change', (e) => {
                window.quantumState.settings.quantumMode = e.target.checked;
                this.quantumMode = e.target.checked;
                this.memoryManager.saveSettings();
                if (this.quantumMode) {
                    this.createFractalNodes();
                } else {
                    this.quantumThinking.innerHTML = '';
                }
            });

            document.getElementById('hyperthreading').addEventListener('change', (e) => {
                window.quantumState.settings.hyperthreading = e.target.checked;
                this.hyperthreading = e.target.checked;
                this.memoryManager.saveSettings();
                if (this.quantumMode) {
                    this.createFractalNodes();
                }
            });

            document.getElementById('multi-agent-mode').addEventListener('change', (e) => {
                window.quantumState.settings.multiAgentMode = e.target.checked;
                this.multiAgentMode = e.target.checked;
                this.memoryManager.saveSettings();
            });

            document.getElementById('auto-save').addEventListener('change', (e) => {
                window.quantumState.settings.autoSave = e.target.checked;
                this.memoryManager.saveSettings();
                if (e.target.checked) {
                    this.startAutoSave();
                } else {
                    this.stopAutoSave();
                }
            });

            document.getElementById('agent-count').addEventListener('change', (e) => {
                window.quantumState.settings.agentCount = parseInt(e.target.value);
                this.memoryManager.saveSettings();
            });

            document.getElementById('max-rounds').addEventListener('change', (e) => {
                window.quantumState.settings.maxRounds = parseInt(e.target.value);
                this.memoryManager.saveSettings();
            });

            document.getElementById('reasoning-depth').addEventListener('change', (e) => {
                window.quantumState.settings.reasoningDepth = parseInt(e.target.value);
                this.memoryManager.saveSettings();
            });

            document.getElementById('btn-clear-cache').addEventListener('click', () => {
                this.memoryManager.clearAllCache().then(success => {
                    quantumNotify(success ? 'Cache cleared' : 'Cache clearance failed', 
                                success ? 'success' : 'error');
                });
            });

            document.getElementById('btn-optimize-memory').addEventListener('click', () => {
                this.memoryManager.aggressiveCleanup();
                quantumNotify('Memory optimized', 'success');
            });

            document.getElementById('btn-export-session').addEventListener('click', () => {
                this.memoryManager.exportSession().then(success => {
                    quantumNotify(success ? 'Session exported' : 'Export failed', 
                                success ? 'success' : 'error');
                });
            });

            this.setupCodeSuggestions();
        }

        setupCodeSuggestions() {
            const promptInput = document.getElementById('prompt-input');
            const suggestionsPanel = document.getElementById('suggestions-panel');

            promptInput.addEventListener('input', () => {
                const value = promptInput.value;
                if (value.length < 2) {
                    suggestionsPanel.style.display = 'none';
                    return;
                }

                const suggestions = this.getSuggestions(value);
                if (suggestions.length > 0) {
                    this.showSuggestions(suggestions, promptInput);
                } else {
                    suggestionsPanel.style.display = 'none';
                }
            });

            promptInput.addEventListener('blur', () => {
                setTimeout(() => {
                    suggestionsPanel.style.display = 'none';
                }, 200);
            });
        }

        getSuggestions(input) {
            const commonCommands = [
                'create a function to sort arrays',
                'optimize this code for performance',
                'add error handling to this function',
                'convert this to TypeScript',
                'explain this code',
                'refactor this code',
                'write unit tests for this function',
                'create a React component',
                'implement a database query',
                'add comments to this code',
                'fix bugs in this code',
                'improve code readability',
                'implement authentication',
                'create API endpoints',
                'optimize database queries',
                'add input validation',
                'implement caching',
                'create documentation',
                'set up logging',
                'handle edge cases'
            ];

            return commonCommands.filter(cmd => 
                cmd.toLowerCase().includes(input.toLowerCase())
            ).slice(0, 5);
        }

        showSuggestions(suggestions, inputElement) {
            const suggestionsPanel = document.getElementById('suggestions-panel');
            suggestionsPanel.innerHTML = '';

            suggestions.forEach(suggestion => {
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.textContent = suggestion;
                item.addEventListener('click', () => {
                    inputElement.value = suggestion;
                    suggestionsPanel.style.display = 'none';
                    inputElement.focus();
                });
                suggestionsPanel.appendChild(item);
            });

            const rect = inputElement.getBoundingClientRect();
            suggestionsPanel.style.position = 'fixed';
            suggestionsPanel.style.top = (rect.top - 205) + 'px'; // Position above input
            suggestionsPanel.style.left = (rect.left) + 'px';
            suggestionsPanel.style.width = (rect.width) + 'px';
            suggestionsPanel.style.display = 'block';
        }

        handleInput() {
            if (this.isComposing) return;

            this.pushHistory();
            this.updateLineNumbers();
            this.updateStatus();
            this.saveAutosave();

            if (this.quantumMode) {
                this.createFractalNodes();
            }
        }

        handleKeydown(event) {
            if (event.key === 'Tab') {
                event.preventDefault();
                this.insertText('    ');
            }

            if (event.ctrlKey || event.metaKey) {
                if (event.key === 'z' && !event.shiftKey) {
                    event.preventDefault();
                    this.undo();
                } else if (event.key === 'z' && event.shiftKey) {
                    event.preventDefault();
                    this.redo();
                } else if (event.key === 'y') {
                    event.preventDefault();
                    this.redo();
                } else if (event.key === 's') {
                    event.preventDefault();
                    quantumSaveFile();
                } else if (event.key === 'f') {
                    event.preventDefault();
                    this.showFindDialog();
                } else if (event.key === 'd') {
                    event.preventDefault();
                    this.duplicateLine();
                }
            } else if (event.key === 'F2') {
                event.preventDefault();
                this.renameVariable();
            }
        }

        showFindDialog() {
            const findText = prompt('Find:');
            if (findText) {
                const content = this.editor.textContent;
                const regex = new RegExp(findText, 'gi');
                const matches = content.match(regex);
                if (matches) {
                    quantumNotify(`Found ${matches.length} matches`, 'info');
                    this.highlightMatches(findText);
                } else {
                    quantumNotify('No matches found', 'warn');
                }
            }
        }

        highlightMatches(text) {
            const content = this.editor.innerHTML;
            const regex = new RegExp(`(${text})`, 'gi');
            const highlighted = content.replace(regex, '<mark>$1</mark>');
            this.editor.innerHTML = highlighted;
            
            setTimeout(() => {
                this.highlighter.highlightElement(this.editor, this.currentFileType);
            }, 3000);
        }

        duplicateLine() {
             const selection = window.getSelection();
            if (!selection.rangeCount) return;
            const range = selection.getRangeAt(0);
            const lineContent = this.getLineContent(range.startContainer);
            this.insertText('\n' + lineContent);
        }

        getLineContent(node) {
            let currentNode = node;
            while(currentNode && currentNode !== this.editor) {
                if(currentNode.nodeName === 'DIV' || currentNode.nodeName === 'P' || currentNode.nodeName === 'BR') {
                   return currentNode.textContent;
                }
                currentNode = currentNode.parentNode;
            }
            return node.textContent || "";
        }

        renameVariable() {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);
            const selectedText = range.toString();
            
            if (selectedText) {
                const newName = prompt('Rename variable:', selectedText);
                if (newName && newName !== selectedText) {
                    document.execCommand('insertText', false, newName);
                    this.handleInput();
                }
            } else {
                quantumNotify('Select a variable to rename', 'warn');
            }
        }

        insertText(text) {
            document.execCommand('insertText', false, text);
            this.handleInput();
        }

        enableRealtimeHighlighting() {
            this.highlighter.enableRealtimeHighlighting(this.editor, this.currentFileType);
        }

        initQuantumVisuals() {
            const threadsContainer = document.getElementById('quantum-threads');
            threadsContainer.innerHTML = '';
            for (let i = 0; i < 5; i++) {
                const thread = document.createElement('div');
                thread.className = 'quantum-thread';
                thread.style.left = `${20 + i * 15}%`;
                thread.style.animationDelay = `${i * 0.3}s`;
                threadsContainer.appendChild(thread);
            }
        }

        createFractalNodes() {
            if (!this.quantumMode) return;

            this.quantumThinking.innerHTML = '';
            const nodeCount = this.hyperthreading ? 12 : 6;

            for (let i = 0; i < nodeCount; i++) {
                const node = document.createElement('div');
                node.className = 'fractal-node';
                node.style.left = `${Math.random() * 100}%`;
                node.style.top = `${Math.random() * 100}%`;
                node.style.animationDelay = `${Math.random() * 2}s`;
                node.style.background = i % 2 === 0 ? 'var(--agent-core)' : 'var(--agent-loop)';
                this.quantumThinking.appendChild(node);
            }
        }

        pushHistory() {
            const content = this.editor.textContent;
            if (this.historyStack.length && this.historyStack[this.historyStack.length - 1] === content) return;

            this.historyStack.push(content);
            this.redoStack = [];

            if (this.historyStack.length > this.maxHistorySize) {
                this.historyStack.shift();
            }
        }

        undo() {
            if (this.historyStack.length > 1) {
                this.redoStack.push(this.historyStack.pop());
                this.render(this.historyStack[this.historyStack.length - 1]);
            }
        }

        redo() {
            if (this.redoStack.length) {
                const content = this.redoStack.pop();
                this.historyStack.push(content);
                this.render(content);
            }
        }

        render(content) {
            try {
                this.editor.textContent = content;
                this.highlighter.highlightElement(this.editor, this.currentFileType);
                this.updateLineNumbers();
                this.updateStatus();

                if (this.quantumMode) {
                    this.createFractalNodes();
                }
            } catch (error) {
                console.error('Render failed:', error);
                this.handleMemoryError(error);
            }
        }

        updateLineNumbers() {
            try {
                const text = this.editor.textContent || '';
                const lineCount = text.split('\n').length;
                let lineNumbersHTML = '';
                for (let i = 1; i <= lineCount; i++) {
                    lineNumbersHTML += i + '<br>';
                }
                this.lineNumbers.innerHTML = lineNumbersHTML;
            } catch (error) {
                console.warn('Line number update failed:', error);
            }
        }

        syncScroll() {
            this.lineNumbers.scrollTop = this.editor.parentElement.scrollTop;
        }

        updateStatus() {
            try {
                const selection = window.getSelection();
                const text = this.editor.textContent || '';
                const lines = text.split('\n');

                let lineNum = 1;
                let colNum = 0;

                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    const preCaretRange = range.cloneRange();
                    preCaretRange.selectNodeContents(this.editor);
                    preCaretRange.setEnd(range.endContainer, range.endOffset);

                    const preCaretText = preCaretRange.toString();
                    const preCaretLines = preCaretText.split('\n');

                    lineNum = preCaretLines.length;
                    colNum = preCaretLines[preCaretLines.length - 1].length;
                }

                const quantumStatus = this.quantumMode ?
                    ` | Quantum: ${this.hyperthreading ? 'Hyperthreaded' : 'Standard'}` :
                    ' | Classical Mode';

                const agentStatus = this.multiAgentMode ? ' | Multi-Agent' : ' | Single-Agent';

                this.statusEditor.textContent =
                    `Cursor: ${lineNum}:${colNum} | Lines: ${lines.length} | Chars: ${text.length} | History: ${this.historyStack.length}${quantumStatus}${agentStatus}`;
            } catch(e) { /* ignore selection errors */ }
        }

        handleMemoryError(error) {
            console.error('Memory error occurred:', error);
            document.getElementById('memory-status').textContent = 'RAM: CRITICAL';
            document.getElementById('memory-status').className = 'memory-status low';
            
            this.memoryManager.emergencyCleanup();
            this.editor.textContent = '// Memory optimization in progress...\n// Please save your work and refresh if issues persist';
            
            quantumNotify('Memory optimized for stability', 'warn');
        }

        setContent(content, fileType = 'javascript') {
            try {
                this.currentFileType = fileType;
                this.highlighter.setLanguage(fileType);
                this.render(content);
                this.historyStack = [content];
                this.redoStack = [];
            } catch (error) {
                this.handleMemoryError(error);
            }
        }

        getContent() {
            return this.editor.textContent;
        }
        
        beautifyCode() {
            try {
                const content = this.getContent();
                let beautified = content;

                if (typeof js_beautify === 'undefined') {
                    quantumNotify('Beautify library not loaded.', 'warn');
                    return;
                }
                const options = { indent_size: 2, space_in_empty_paren: true };

                if (['javascript', 'json', 'typescript', 'jsx', 'tsx'].includes(this.currentFileType)) {
                    beautified = js_beautify(content, options);
                } else if (['html', 'xml'].includes(this.currentFileType)) {
                    beautified = html_beautify(content, options);
                } else if (this.currentFileType === 'css') {
                    beautified = css_beautify(content, { indent_size: 2 });
                }

                this.setContent(beautified, this.currentFileType);
                quantumNotify('Code beautified', 'success');
            } catch (error) {
                console.error("Beautify error:", error);
                quantumNotify('Beautification failed', 'error');
            }
        }
    }

    /* =========================================================================
       ENHANCED QUANTUM ORCHESTRATOR WITH HASHING-INDEX MODEL POOL
       ========================================================================== */

    class EnhancedQuantumOrchestrator {
        constructor(GoogleGenAI) {
            this.GoogleGenAI = GoogleGenAI;
            this.ai = null;
            this.agents = {
                core: document.querySelector('.agent-core .agent-content'),
                loop: document.querySelector('.agent-loop .agent-content'),
                '2244': document.querySelector('.agent-t2244 .agent-content'),
                coin: document.querySelector('.agent-coin .agent-content'),
                code: document.querySelector('.agent-code .agent-content')
            };

            this.logElements = {
                core: document.getElementById('core-log'),
                loop: document.getElementById('loop-log'),
                '2244': document.getElementById('2244-log'),
                coin: document.getElementById('coin-log'),
                code: document.getElementById('code-log')
            };

            this.agentCards = {
                core: document.querySelector('.agent-core'),
                loop: document.querySelector('.agent-loop'),
                '2244': document.querySelector('.agent-t2244'),
                coin: document.querySelector('.agent-coin'),
                code: document.querySelector('.agent-code')
            };

            this.consensusPanel = document.getElementById('consensus-panel');
            this.candidatesList = document.getElementById('candidates-list');
            this.consensusScore = document.getElementById('consensus-score');

            this.isGenerating = false;
            this.quantumConnected = false;
            
            // Enhanced hashing-index model pool
            this.modelPool = {
                core: { name: 'Quantum Core', weight: 1.2, specialization: 'architectural patterns' },
                loop: { name: 'Fractal Loop', weight: 1.1, specialization: 'recursive optimization' },
                '2244': { name: 'Temporal 2244', weight: 1.0, specialization: 'future-proofing' },
                coin: { name: 'Entropy Coin', weight: 0.9, specialization: 'probabilistic validation' },
                code: { name: 'Genesis Code', weight: 1.3, specialization: 'syntactic perfection' }
            };
            
            this.fileSystem = {
                genesisHash: null,
                eventLog: [],
                fragments: [],
                origins: {},
                tokenPool: new Map(),
                mindMap: new Map()
            };
            
            this.init();
        }

        init() {
            this.checkQuantumConnection();
            this.bindOrchestratorEvents();
        }

        bindOrchestratorEvents() {
            document.getElementById('run-orchestrator').addEventListener('click', () => {
                this.runEnhancedOrchestrator();
            });

            document.getElementById('btn-orchestrate').addEventListener('click', () => {
                this.runEnhancedOrchestrator();
            });
        }

        async checkQuantumConnection() {
            try {
                if (process.env.API_KEY && this.GoogleGenAI) {
                    this.ai = new this.GoogleGenAI({ apiKey: process.env.API_KEY });
                    this.quantumConnected = true;
                    quantumNotify('Gemini connection ready', 'success');
                    document.getElementById('ai-dot').classList.remove('probing');
                    document.getElementById('ai-dot').classList.add('connected');
                    document.getElementById('ai-indicator').textContent = 'Quantum AI: Ready';
                } else {
                    throw new Error("API_KEY not found or GoogleGenAI not provided");
                }
            } catch (error) {
                this.setQuantumDisconnected();
            }
        }

        setQuantumDisconnected() {
            this.quantumConnected = false;
            quantumNotify('Gemini API key not found.', 'warn');
            document.getElementById('ai-dot').classList.add('probing');
            document.getElementById('ai-dot').classList.remove('connected');
            document.getElementById('ai-indicator').textContent = 'Quantum AI: No Key';
        }

        async sha256(str) {
            const textAsBuffer = new TextEncoder().encode(str);
            const hashBuffer = await window.crypto.subtle.digest('SHA-256', textAsBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashAsHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return hashAsHex;
        }

        /* =========================================================================
           ENHANCED HASHING-INDEX MODEL POOL IMPLEMENTATION
           ========================================================================== */

        async runEnhancedOrchestrator() {
            if (this.isGenerating) return;

            this.isGenerating = true;
            document.querySelectorAll('button').forEach(b => b.disabled = true);
            const promptInput = document.getElementById('prompt-input');
            const promptText = promptInput.value.trim() || "Optimize this code with quantum fractal patterns";
            const editorContext = quantumEditor.getContent();

            document.getElementById('ai-response-panel').style.display = 'block';

            Object.values(this.agents).forEach(agent => {
                agent.innerHTML = 'Initializing enhanced orchestration...';
            });
            Object.values(this.agentCards).forEach(card => card.classList.remove('active'));
            Object.values(this.logElements).forEach(log => log.innerHTML = '');

            this.agents.core.innerHTML = '<div class="quantum-spinner"></div>Starting enhanced quantum orchestration...';
            this.agentCards.core.classList.add('active');

            try {
                // STEP 1: Generate genesis hash shared by all agents
                await this.addLog('core', 'Generating genesis hash from current code...', 'genesis');
                const genesisHash = await this.generateGenesisHash(editorContext, promptText);
                this.fileSystem.genesisHash = genesisHash;
                await this.addLog('core', `Genesis: ${genesisHash.substring(0, 16)}...`, 'genesis');

                // STEP 2: Generate genesis-based origin hash for each agent
                await this.addLog('core', 'Generating origin hashes for agents...', 'origin');
                const agents = Object.keys(this.modelPool);
                
                for (const agentId of agents) {
                    const originHash = await this.generateOriginHash(genesisHash, agentId);
                    this.fileSystem.origins[agentId] = originHash;
                    await this.addLog('core', `${agentId}: ${originHash.substring(0, 12)}...`, 'origin');
                }

                // STEP 3: Parse natural prompt and setup timestamp-indexed event stack
                await this.addLog('core', 'Creating event log entry...', 'event');
                const event = {
                    prompt: promptText,
                    timestamp: Date.now(),
                    origin: genesisHash,
                    eventId: this.generateEventId(),
                    timestampIndex: this.createTimestampIndex()
                };
                this.fileSystem.eventLog.push(event);
                await this.addLog('core', `Event: ${event.eventId} logged`, 'event');

                // STEP 4: Start fractal-based quantum-stated mindmap resolution
                await this.addLog('loop', '<div class="quantum-spinner"></div>Spawning fractal agents with genesis mindset...');
                this.agentCards.loop.classList.add('active');

                const allCandidates = [];
                const maxRounds = window.quantumState.settings.maxRounds;
                
                // Initialize mind map with genesis hash
                this.fileSystem.mindMap.set(genesisHash, {
                    type: 'genesis',
                    content: editorContext,
                    timestamp: Date.now(),
                    entropy: await this.calculateEntropy(genesisHash)
                });

                for (let round = 0; round < maxRounds; round++) {
                    await this.addLog('2244', `<div class="quantum-spinner"></div>Round ${round + 1}/${maxRounds} - Hyperthreaded reasoning...`);
                    this.agentCards['2244'].classList.add('active');

                    // STEP 5: Rehash each origin hash with genesis hash as memory-staged counter
                    const roundPromises = agents.map(async (agentId) => {
                        const newOrigin = await this.rehashOrigin(this.fileSystem.origins[agentId], genesisHash, round);
                        this.fileSystem.origins[agentId] = newOrigin;

                        // STEP 6: Accelerate reasoning with fractal-based math logics
                        const candidate = await this.performFractalReasoning(
                            agentId, 
                            promptText, 
                            editorContext, 
                            round,
                            genesisHash,
                            newOrigin
                        );
                        
                        const fragment = {
                            agentId: agentId,
                            origin: newOrigin,
                            round,
                            candidate,
                            entropy: await this.calculateEntropy(newOrigin),
                            timestamp: Date.now(),
                            genesisReference: genesisHash
                        };
                        
                        this.fileSystem.fragments.push(fragment);
                        
                        // STEP 8: Store fragments in token pool for real-time injection
                        await this.storeInTokenPool(fragment, agentId);
                        
                        await this.addLog('coin', `Fragment from ${agentId} (round ${round})`, 'fragment');

                        allCandidates.push(fragment);
                        return fragment;
                    });

                    const roundResults = await Promise.all(roundPromises);
                    
                    // STEP 7: Adapt rehashed origin hashes for collaborative acceleration
                    await this.accelerateCollaboration(roundResults, genesisHash);
                    
                    await new Promise(r => setTimeout(r, 300));
                }

                // STEP 9: Source final answer by assembling origin-rehashed genesis logic
                await this.addLog('coin', `<div class="quantum-spinner"></div>Assembling final consensus with entropy sorting...`);
                this.agentCards.coin.classList.add('active');
                
                const consensus = await this.assembleFinalAnswer(allCandidates, genesisHash);

                // STEP 10: Use highest entropy for cyclic math-based reassembly
                await this.addLog('code', `<div class="quantum-spinner"></div>Reassembling script from entropy-sorted chunks...`);
                this.agentCards.code.classList.add('active');
                
                await this.displayEnhancedConsensusResults(consensus, allCandidates);

            } catch (e) {
                console.error("Enhanced orchestrator error:", e);
                this.agents.code.innerHTML = `<span style="color: #ff4444">Orchestrator Error: ${e.message}</span>`;
            } finally {
                this.agents.core.innerHTML = 'Enhanced orchestration complete';
                this.agents.loop.innerHTML = 'Ready';
                this.agents['2244'].innerHTML = 'Ready';
                this.agents.coin.innerHTML = 'Ready';
                Object.values(this.agentCards).forEach(card => card.classList.remove('active'));
                this.isGenerating = false;
                document.querySelectorAll('button').forEach(b => b.disabled = false);
            }
        }

        /* =========================================================================
           CORE HASHING-INDEX IMPLEMENTATION
           ========================================================================== */

        async generateGenesisHash(content, prompt) {
            const timestamp = Date.now().toString();
            const combined = 'GENESIS_ROOT:' + timestamp + ':' + prompt + ':' + content;
            return this.sha256(combined);
        }

        async generateOriginHash(genesis, agentId) {
            const nonce = Math.random().toString(36).substring(2, 15);
            const combined = genesis + ':' + agentId + ':' + nonce + ':' + this.modelPool[agentId].specialization;
            return this.sha256(combined);
        }

        async rehashOrigin(origin, genesis, round) {
            const combined = origin + ':' + genesis + ':' + round.toString() + ':' + Date.now().toString();
            return this.sha256(combined);
        }

        createTimestampIndex() {
            const now = Date.now();
            return {
                primary: now,
                secondary: now.toString(36),
                fractal: this.generateFractalTimestamp(now)
            };
        }

        generateFractalTimestamp(baseTimestamp) {
            let fractal = baseTimestamp.toString();
            for (let i = 0; i < 3; i++) {
                fractal = btoa(fractal).substring(0, 20);
            }
            return fractal;
        }

        async calculateEntropy(hash) {
            const charCounts = {};
            for (const char of hash) {
                charCounts[char] = (charCounts[char] || 0) + 1;
            }
            let entropy = 0;
            const length = hash.length;
            for (const char in charCounts) {
                const probability = charCounts[char] / length;
                entropy -= probability * Math.log2(probability);
            }
            return entropy;
        }

        generateEventId() {
            return 'event_' + Date.now().toString(36) + Math.random().toString(36).substring(2, 8);
        }

        async performFractalReasoning(agentId, prompt, context, round, genesisHash, currentOrigin) {
            if (!this.quantumConnected || !this.ai) {
                await this.addLog('coin', `Agent ${agentId} falling back to simulation.`, 'fragment');
                await new Promise(r => setTimeout(r, 200 + (Math.random() * 400)));
                return this.generateSimulatedResponse(agentId, genesisHash, currentOrigin);
            }

            const reasoningDepth = window.quantumState.settings.reasoningDepth;
            const strategy = this.getFractalStrategy(agentId, round, reasoningDepth);
            
            const MAX_CONTEXT_LENGTH = 8000;
            let truncatedContext = context;
            if (context.length > MAX_CONTEXT_LENGTH) {
                const half = MAX_CONTEXT_LENGTH / 2;
                truncatedContext = context.substring(0, half) +
                                   '\n\n// ... [CODE TRUNCATED FOR BREVITY] ...\n\n' +
                                   context.substring(context.length - half);
            }

            const fullPrompt = this.buildQuantumPrompt(
                agentId, prompt, truncatedContext, round, 
                genesisHash, currentOrigin, strategy, reasoningDepth
            );

            try {
                const response = await this.ai.models.generateContent({
                    model: 'gemini-2.5-pro',
                    contents: fullPrompt,
                });
                
                const codeCandidate = response.text;
                
                return this.formatAgentResponse(agentId, codeCandidate, round, strategy, currentOrigin);

            } catch (error) {
                console.error(`Agent ${agentId} failed:`, error);
                await this.addLog('coin', `Agent ${agentId} encountered an error: ${error.message}`, 'fragment');
                return this.generateSimulatedResponse(agentId, genesisHash, currentOrigin);
            }
        }

        getFractalStrategy(agentId, round, depth) {
            const strategies = {
                core: [
                    "Apply quantum architectural patterns",
                    "Implement genesis-rooted structures",
                    "Use hashing-index optimization",
                    "Apply fractal decomposition"
                ],
                loop: [
                    "Implement recursive optimization",
                    "Use iterative refinement",
                    "Apply fractal looping patterns",
                    "Use cyclic reasoning"
                ],
                '2244': [
                    "Apply temporal optimization",
                    "Use future-proofing patterns",
                    "Implement time-aware structures",
                    "Apply temporal hashing"
                ],
                coin: [
                    "Use probabilistic validation",
                    "Apply entropy-based selection",
                    "Implement stochastic optimization",
                    "Use quantum probability"
                ],
                code: [
                    "Apply syntactic perfection",
                    "Use genesis-aligned structures",
                    "Implement quantum syntax",
                    "Apply fractal code patterns"
                ]
            };

            const agentStrategies = strategies[agentId] || strategies.core;
            const strategyIndex = (round * depth) % agentStrategies.length;
            return agentStrategies[strategyIndex];
        }

        buildQuantumPrompt(agentId, userPrompt, context, round, genesisHash, originHash, strategy, depth) {
            return `You are ${this.modelPool[agentId].name}, an expert coding agent in a quantum fractal AI system.

CRITICAL CONTEXT:
- You are part of a multi-agent system using genesis-hashing and origin-rehashing
- Current genesis hash: ${genesisHash.substring(0, 16)}...
- Your origin hash: ${originHash.substring(0, 16)}...
- Round: ${round + 1} of ${window.quantumState.settings.maxRounds}
- Reasoning depth: ${depth}
- Assigned strategy: "${strategy}"

YOUR MISSION:
Generate code that aligns with the genesis-rooted pattern and follows your specialized reasoning strategy.

USER REQUEST: "${userPrompt}"

CODE CONTEXT:
\`\`\`${quantumEditor.currentFileType}
${context}
\`\`\`

SPECIAL INSTRUCTIONS:
- Your response must reflect ${this.modelPool[agentId].specialization}
- Align with the quantum fractal patterns implied by the genesis hash
- Apply ${strategy} in your reasoning
- Provide only clean, executable code without explanations
- Ensure your output can be reassembled with other agent fragments

Generate the optimal code solution:`;
        }

        formatAgentResponse(agentId, code, round, strategy, originHash) {
            return `// Agent: ${agentId} | ${this.modelPool[agentId].name}
// Round: ${round + 1} | Strategy: ${strategy}
// Origin: ${originHash.substring(0, 16)}... | Specialization: ${this.modelPool[agentId].specialization}
${code}`;
        }

        generateSimulatedResponse(agentId, genesisHash, originHash) {
            const strategies = {
                core: "architectural quantum patterns",
                loop: "recursive fractal optimization", 
                '2244': "temporal future-proofing",
                coin: "probabilistic entropy validation",
                code: "syntactic genesis alignment"
            };

            return `// SIMULATED: Agent ${agentId} (${this.modelPool[agentId].name})
// Genesis: ${genesisHash.substring(0, 12)}... | Origin: ${originHash.substring(0, 12)}...
// Strategy: ${strategies[agentId]}

function quantum_${agentId}_optimization() {
    // Simulated ${strategies[agentId]} implementation
    console.log("${this.modelPool[agentId].name} optimization applied");
    return "Enhanced by ${this.modelPool[agentId].specialization}";
}`;
        }

        async storeInTokenPool(fragment, agentId) {
            const tokenKey = `token_${agentId}_${fragment.round}_${Date.now()}`;
            this.fileSystem.tokenPool.set(tokenKey, {
                fragment,
                agentId,
                timestamp: Date.now(),
                entropy: fragment.entropy
            });

            // Real-time injection into editor (temporary display)
            if (window.quantumState.settings.quantumMode) {
                await this.injectTokenToEditor(fragment, agentId);
            }
        }

        async injectTokenToEditor(fragment, agentId) {
            // Create a temporary visual effect for token injection
            const packet = document.createElement('div');
            packet.className = 'quantum-packet';
            packet.style.left = `${Math.random() * 80 + 10}%`;
            packet.style.top = `${Math.random() * 80 + 10}%`;
            packet.style.background = this.getAgentColor(agentId);
            
            document.getElementById('editor-stage').appendChild(packet);
            
            // Animate the packet
            gsap.to(packet, {
                duration: 0.8,
                opacity: 1,
                scale: 2,
                ease: "power2.out",
                onComplete: () => {
                    gsap.to(packet, {
                        duration: 0.5,
                        opacity: 0,
                        scale: 0.5,
                        ease: "power2.in",
                        onComplete: () => {
                            document.getElementById('editor-stage').removeChild(packet);
                        }
                    });
                }
            });

            await new Promise(r => setTimeout(r, 100));
        }

        getAgentColor(agentId) {
            const colors = {
                core: 'var(--agent-core)',
                loop: 'var(--agent-loop)',
                '2244': 'var(--agent-2244)',
                coin: 'var(--agent-coin)',
                code: 'var(--agent-code)'
            };
            return colors[agentId] || 'var(--accent)';
        }

        async accelerateCollaboration(roundFragments, genesisHash) {
            // STEP 7: Enhance collaboration through mind map updates
            for (const fragment of roundFragments) {
                const mindKey = `mind_${fragment.agentId}_${fragment.round}`;
                this.fileSystem.mindMap.set(mindKey, {
                    type: 'reasoning',
                    agent: fragment.agentId,
                    round: fragment.round,
                    origin: fragment.origin,
                    entropy: fragment.entropy,
                    genesisReference: genesisHash,
                    timestamp: Date.now()
                });
            }

            // Share insights across agents through the mind map
            await this.distributeInsights(roundFragments, genesisHash);
        }

        async distributeInsights(fragments, genesisHash) {
            // Find the fragment with highest entropy to share as insight
            if (fragments.length === 0) return;

            const highestEntropyFragment = fragments.reduce((best, current) => 
                current.entropy > best.entropy ? current : best
            );

            // Add this as a shared insight in the mind map
            this.fileSystem.mindMap.set(`insight_${Date.now()}`, {
                type: 'shared_insight',
                sourceAgent: highestEntropyFragment.agentId,
                entropy: highestEntropyFragment.entropy,
                genesisReference: genesisHash,
                timestamp: Date.now(),
                content: `High-entropy pattern from ${highestEntropyFragment.agentId}`
            });

            await this.addLog('2244', `Shared insight from ${highestEntropyFragment.agentId} (entropy: ${highestEntropyFragment.entropy.toFixed(3)})`, 'event');
        }

        async assembleFinalAnswer(allCandidates, genesis) {
            // STEP 9 & 10: Use entropy-based sorting and cyclic reassembly
            
            if (allCandidates.length === 0) {
                return {
                    genesis,
                    selectedCandidate: "// No valid candidates were generated by the agents.",
                    score: 0,
                    agentCount: 0,
                    roundCount: 0,
                    avgEntropy: 0,
                    rootAgent: 'N/A',
                    rootEntropy: 0,
                    allGroups: []
                };
            }

            // Group by similarity and calculate consensus scores
            const candidateGroups = this.groupCandidatesByGenesisAlignment(allCandidates, genesis);
            const scoredGroups = this.scoreCandidateGroups(candidateGroups);
            
            // Sort by score (highest first)
            scoredGroups.sort((a, b) => b.score - a.score);
            const topGroup = scoredGroups[0];
            
            // Find root candidate with highest entropy
            const rootCandidate = topGroup.candidates.reduce((best, current) => 
                current.entropy > best.entropy ? current : best
            );

            // Assemble final code using entropy-sorted chunks
            const assembledCode = await this.assembleEntropySortedCode(topGroup.candidates, genesis);

            return {
                genesis,
                selectedCandidate: assembledCode,
                score: topGroup.score.toFixed(3),
                agentCount: topGroup.agentCount,
                roundCount: topGroup.roundCount,
                avgEntropy: topGroup.avgEntropy.toFixed(3),
                rootAgent: rootCandidate.agentId,
                rootEntropy: rootCandidate.entropy.toFixed(3),
                allGroups: scoredGroups
            };
        }

        groupCandidatesByGenesisAlignment(candidates, genesisHash) {
            const groups = new Map();

            for (const candidate of candidates) {
                // Create grouping key based on genesis alignment and content pattern
                const contentStart = candidate.candidate.substring(0, 100);
                const entropyBucket = Math.floor(candidate.entropy * 10) / 10; // Group by entropy deciles
                const groupKey = `${contentStart.substring(0, 30)}_${entropyBucket}`;

                if (!groups.has(groupKey)) {
                    groups.set(groupKey, {
                        candidates: [],
                        totalEntropy: 0,
                        agents: new Set(),
                        rounds: new Set(),
                        genesisAlignment: 0
                    });
                }

                const group = groups.get(groupKey);
                group.candidates.push(candidate);
                group.totalEntropy += candidate.entropy;
                group.agents.add(candidate.agentId);
                group.rounds.add(candidate.round);
                
                // Calculate genesis alignment (simplified)
                group.genesisAlignment += candidate.genesisReference === genesisHash ? 1 : 0;
            }

            // Convert Map to array of objects
            return Array.from(groups.entries()).map(([key, group]) => ({
                key,
                candidates: group.candidates,
                totalEntropy: group.totalEntropy,
                agents: group.agents,
                rounds: group.rounds,
                genesisAlignment: group.genesisAlignment
            }));
        }

        scoreCandidateGroups(groups) {
            return groups.map(group => {
                const agentCount = group.agents.size;
                const roundCount = group.rounds.size;
                const avgEntropy = group.totalEntropy / group.candidates.length;
                const genesisScore = group.genesisAlignment / group.candidates.length;
                
                // Weighted scoring formula
                const score = (agentCount * 2.5) + 
                             (roundCount * 2.0) + 
                             (avgEntropy * 4.0) + 
                             (genesisScore * 3.0);
                
                return {
                    key: group.key,
                    candidates: group.candidates,
                    score,
                    agentCount,
                    roundCount,
                    avgEntropy,
                    genesisScore
                };
            });
        }

        async assembleEntropySortedCode(candidates, genesisHash) {
            // Sort candidates by entropy (highest first)
            const sortedCandidates = [...candidates].sort((a, b) => b.entropy - a.entropy);
            
            let assembledCode = `// QUANTUM FRACTAL ASSEMBLY - Genesis: ${genesisHash.substring(0, 16)}...\n`;
            assembledCode += `// Assembled from ${sortedCandidates.length} entropy-sorted fragments\n\n`;
            
            // Take the best candidate as base and augment with high-entropy fragments
            if (sortedCandidates.length > 0) {
                const baseCandidate = sortedCandidates[0];
                assembledCode += baseCandidate.candidate + '\n\n';
                
                // Add contributions from other high-entropy candidates
                assembledCode += '// Additional enhancements from quantum agents:\n';
                for (let i = 1; i < Math.min(3, sortedCandidates.length); i++) {
                    assembledCode += `// ${sortedCandidates[i].agentId} contribution (entropy: ${sortedCandidates[i].entropy.toFixed(3)})\n`;
                    // Extract key enhancements (simplified - in reality would parse and merge)
                    const lines = sortedCandidates[i].candidate.split('\n').slice(5); // Skip headers
                    assembledCode += lines.join('\n') + '\n\n';
                }
            }
            
            return assembledCode;
        }

        async displayEnhancedConsensusResults(consensus, allCandidates) {
            this.consensusPanel.style.display = 'block';
            this.consensusScore.textContent = `Score: ${consensus.score}`;
            this.candidatesList.innerHTML = '';
            this.logElements.code.innerHTML = '';

            // Display candidate groups
            consensus.allGroups.forEach((group, index) => {
                const isSelected = index === 0;
                const candidateEl = document.createElement('div');
                candidateEl.className = `candidate-item ${isSelected ? 'selected-candidate' : ''}`;
                
                const contentPreview = new QuantumSyntaxHighlighter().escapeHtml(
                    group.candidates[0].candidate.substring(0, 200)
                );
                
                candidateEl.innerHTML = `
                    <div class="candidate-meta">
                        <span>Agents: ${group.agentCount} | Rounds: ${group.roundCount}</span>
                        <span>Score: ${group.score.toFixed(2)} | Entropy: ${group.avgEntropy}</span>
                    </div>
                    <div class="candidate-content">${contentPreview}${group.candidates[0].candidate.length > 200 ? '...' : ''}</div>
                `;
                this.candidatesList.appendChild(candidateEl);
            });

            // Log the assembly process
            await this.addLog('code', `Assembly started. Genesis: ${consensus.genesis.substring(0,12)}...`, 'consensus');
            await new Promise(r => setTimeout(r, 250));
            await this.addLog('code', `Root agent: ${consensus.rootAgent} (entropy: ${consensus.rootEntropy})`, 'consensus');
            await new Promise(r => setTimeout(r, 250));
            
            const finalCodeHash = await this.sha256(consensus.selectedCandidate);
            await this.addLog('code', `Final hash: ${finalCodeHash.substring(0,12)}...`, 'consensus');
            await new Promise(r => setTimeout(r, 250));
            await this.addLog('code', `Quantum assembly complete.`, 'consensus');

            // Display final assembled code
            const highlighter = new QuantumSyntaxHighlighter();
            const highlightedCode = highlighter.highlightText(
                consensus.selectedCandidate, 
                quantumEditor.currentFileType
            );

            const quantumButtons = `
                <div class="action-buttons">
                    <button class="small success" onclick="quantumCopyEnhancedConsensus()">Copy Assembled Code</button>
                    <button class="small info" onclick="quantumApplyEnhancedConsensus()">Apply Assembled Code</button>
                    <button class="small" onclick="quantumRerunEnhancedOrchestrator()" style="background: var(--agent-core);">Rerun Orchestration</button>
                </div>
            `;

            this.agents.code.innerHTML = `
                <div style="border-left: 3px solid var(--agent-core); padding-left: 10px; margin-bottom: 10px;">
                    <strong>Quantum Assembly Complete</strong><br>
                    <small>Genesis: ${consensus.genesis.substring(0, 16)}...</small><br>
                    <small>Final Hash: ${finalCodeHash.substring(0, 16)}...</small><br>
                    <small>Root Agent: ${consensus.rootAgent} | Entropy: ${consensus.rootEntropy}</small>
                </div>
                <pre style="background: #1a1a1a; padding: 10px; border-radius: 4px; overflow: auto; max-height: 300px; border: 1px solid var(--agent-loop);">${highlightedCode}</pre>
                ${quantumButtons}
            `;

            window.quantumConsensusCode = consensus.selectedCandidate;
        }

        async addLog(agent, message, type = 'info') {
            const logEl = this.logElements[agent];
            if (!logEl) return;

            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.innerHTML = `[${timestamp}] ${message}`;
            
            logEl.appendChild(logEntry);
            logEl.scrollTop = logEl.scrollHeight;

            this.agentCards[agent].classList.add('active');
            setTimeout(() => {
                this.agentCards[agent].classList.remove('active');
            }, 500);
        }

        // Quick action methods
        async quantumOptimize() {
            document.getElementById('prompt-input').value = "Optimize this code using quantum fractal patterns and genesis-hashing";
            this.runEnhancedOrchestrator();
        }

        async quantumDocument() {
            document.getElementById('prompt-input').value = "Add comprehensive quantum-aligned documentation with genesis references";
            this.runEnhancedOrchestrator();
        }

        async quantumRefactor() {
            document.getElementById('prompt-input').value = "Refactor using quantum fractal architecture and hashing-index patterns";
            this.runEnhancedOrchestrator();
        }
    }

    // Update global functions to use new agent names
    window.quantumCopyEnhancedConsensus = function() {
        if (window.quantumConsensusCode) {
            navigator.clipboard.writeText(window.quantumConsensusCode).then(() => {
                quantumNotify('Quantum assembled code copied!', 'success');
            });
        }
    }

    window.quantumApplyEnhancedConsensus = function() {
        if (window.quantumConsensusCode) {
            quantumEditor.setContent(window.quantumConsensusCode, quantumEditor.currentFileType);
            quantumNotify('Quantum code applied!', 'success');
        }
    }

    window.quantumRerunEnhancedOrchestrator = function() {
        enhancedOrchestrator.runEnhancedOrchestrator();
    }

    function quantumNotify(message, type = 'info') {
        const notification = document.createElement('div');
        notification.textContent = message;
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${type === 'success' ? 'var(--accent)' : 
                        type === 'warn' ? 'var(--warn-bg)' : 
                        type === 'error' ? 'var(--err)' : 'var(--info)'};
            color: ${type === 'warn' ? '#3a3c31' : 'white'};
            padding: 10px 15px;
            border-radius: 4px;
            z-index: 1000;
            font-size: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        `;
        document.body.appendChild(notification);

        setTimeout(() => {
            document.body.removeChild(notification);
        }, 3000);
    }

    // Initialize the application
    let quantumEditor;
    let enhancedOrchestrator;
    let memoryManager;

    document.addEventListener('DOMContentLoaded', () => {
        try {
            memoryManager = new QuantumMemoryManager();
            quantumEditor = new QuantumEditor();
            enhancedOrchestrator = new EnhancedQuantumOrchestrator(GoogleGenAI);
            
            initQuantumFileHandling();
            initQuantumAI();
            initQuantumPreview();
            initQuantumLeftPanel();
            initQuantumQuickActions();
            
            quantumNotify('Quantum Fractal AI Editor Ready', 'success');
        } catch (error) {
            console.error('Initialization failed:', error);
            quantumNotify('Initialization failed - check console', 'error');
        }
    });

    window.addEventListener('error', (event) => {
        console.error('Global error:', event.error);
        if (memoryManager) {
            memoryManager.emergencyCleanup();
        }
    });

    function getMimeType(fileType) {
        const mimeMap = {
            'javascript': 'application/javascript',
            'jsx': 'application/javascript',
            'typescript': 'application/typescript',
            'tsx': 'application/typescript',
            'html': 'text/html',
            'css': 'text/css',
            'python': 'text/x-python',
            'php': 'application/x-httpd-php',
            'sql': 'application/sql',
            'markdown': 'text/markdown',
            'json': 'application/json',
            'xml': 'application/xml',
            'yaml': 'application/x-yaml',
            'yml': 'application/x-yaml'
        };
        return mimeMap[fileType] || 'text/plain';
    }

    function initQuantumFileHandling() {
        document.getElementById('open-file').addEventListener('click', () => {
            document.getElementById('file-input').click();
        });

        document.getElementById('file-input').addEventListener('change', handleFileOpen);
        document.getElementById('save-file').addEventListener('click', quantumSaveFile);
        document.getElementById('save-as').addEventListener('click', quantumSaveAsFile);
    }

    function handleFileOpen(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(ev) {
            const fileName = file.name;
            const fileType = quantumEditor.highlighter.detectLanguage(fileName);
            const content = ev.target.result;

            quantumEditor.setContent(content, fileType);
            document.getElementById('file-meta').textContent = fileName;
            quantumEditor.currentFileName = fileName;
            memoryManager.addRecentFile(fileName, content);
        };
        reader.readAsText(file);
    }

    function quantumSaveFile() {
        if (!quantumEditor.currentFileName) {
            quantumSaveAsFile();
            return;
        }
        
        const mimeType = getMimeType(quantumEditor.currentFileType);
        const blob = new Blob([quantumEditor.getContent()], { type: mimeType });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = quantumEditor.currentFileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        
        quantumNotify('File saved successfully', 'success');
    }

    function quantumSaveAsFile() {
        const fileName = prompt('Enter file name:', quantumEditor.currentFileName || 'quantum_code.js');
        if (fileName) {
            quantumEditor.currentFileName = fileName;
            const fileType = quantumEditor.highlighter.detectLanguage(fileName);
            quantumEditor.setContent(quantumEditor.getContent(), fileType);
            document.getElementById('file-meta').textContent = fileName;
            quantumSaveFile();
        }
    }

    function initQuantumAI() {
        document.getElementById('send-button').addEventListener('click', runQuantumAI);
        document.getElementById('run-local-ai').addEventListener('click', runQuantumAI);

        document.getElementById('prompt-input').addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                runQuantumAI();
            }
        });

        document.getElementById('close-ai-panel').addEventListener('click', () => {
            document.getElementById('ai-response-panel').style.display = 'none';
        });
    }

    function runQuantumAI() {
        const promptInput = document.getElementById('prompt-input');
        const prompt = promptInput.value.trim();
        if (!prompt) return;

        if (window.quantumState.settings.multiAgentMode) {
            enhancedOrchestrator.runEnhancedOrchestrator();
        } else {
            // Simplified single agent call could be implemented here
            document.getElementById('prompt-input').value = "Single-agent mode requires Multi-Agent Consensus to be enabled in settings.";
            quantumNotify('Enable Multi-Agent Consensus in settings', 'warn');
        }
    }

    function initQuantumPreview() {
        document.getElementById('btn-render').addEventListener('click', renderQuantumHTML);
        document.getElementById('render-html').addEventListener('click', renderQuantumHTML);

        document.getElementById('close-preview').addEventListener('click', () => {
            document.getElementById('preview-panel').style.display = 'none';
            const previewContent = document.getElementById('preview-content');
            if (previewContent.src.startsWith('blob:')) {
                URL.revokeObjectURL(previewContent.src);
            }
        });
    }

    function renderQuantumHTML() {
        try {
            const blob = new Blob([quantumEditor.getContent()], { type: 'text/html' });
            const previewContent = document.getElementById('preview-content');
            if (previewContent.src.startsWith('blob:')) {
                 URL.revokeObjectURL(previewContent.src);
            }
            previewContent.src = URL.createObjectURL(blob);
            document.getElementById('preview-panel').style.display = 'flex';
        } catch (e) {
            alert('Quantum rendering error: ' + e.message);
        }
    }

    function initQuantumLeftPanel() {
        document.getElementById('left-toggle').addEventListener('click', () => {
            const editorStage = document.getElementById('editor-stage');
            const isOpen = editorStage.classList.toggle('left-panel-open');
            document.getElementById('left-toggle').textContent = isOpen ? '✕' : '☰';
        });

        document.getElementById('btn-undo').addEventListener('click', () => quantumEditor.undo());
        document.getElementById('btn-redo').addEventListener('click', () => quantumEditor.redo());
        document.getElementById('btn-beautify').addEventListener('click', () => quantumEditor.beautifyCode());
    }

    function initQuantumQuickActions() {
        document.getElementById('btn-optimize').addEventListener('click', () => enhancedOrchestrator.quantumOptimize());
        document.getElementById('btn-document').addEventListener('click', () => enhancedOrchestrator.quantumDocument());
        document.getElementById('btn-refactor').addEventListener('click', () => enhancedOrchestrator.quantumRefactor());
    }

</script>
</body>
</html>
