<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Agent-Atom Model</title>
    <!-- Load Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load OrbitControls for camera manipulation -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        :root {
            --bg-color: #0d1117;
            --text-color: #e6e6e6;
            --accent-color: #4ac94a;
            --nucleus-color: #ff9800; /* Core Model */
            --loop-color: #03DAC6; /* Electron 1 */
            --coin-color: #BB86FC; /* Electron 2 */
            --code-color: #CF6679; /* Ion */
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Inter', sans-serif;
            color: var(--text-color);
        }
        canvas {
            display: block;
        }
        #info-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            z-index: 10;
        }
        #ollama-status {
            background: rgba(13, 17, 23, 0.8);
            border: 1px solid var(--accent-color);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        .status-dot {
            height: 10px;
            width: 10px;
            background-color: #f44336;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
            animation: pulse-red 1.5s infinite;
        }
        .connected {
            background-color: var(--accent-color);
            animation: pulse-green 1.5s infinite;
        }
        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(74, 201, 74, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(74, 201, 74, 0); }
            100% { box-shadow: 0 0 0 0 rgba(74, 201, 74, 0); }
        }
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(244, 67, 54, 0); }
            100% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0); }
        }
        #model-key {
            background: rgba(13, 17, 23, 0.8);
            border: 1px solid #2e3026;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        #model-key div {
            margin-bottom: 5px;
        }
        .legend-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
        }
    </style>
</head>
<body>
    <div id="info-overlay">
        <div id="ollama-status">
            <span id="status-dot" class="status-dot connected"></span>
            Ollama v12.x Bridge: **Natural-Prompt Resolving**
        </div>
        <div id="model-key">
            <div style="color: var(--nucleus-color);"><span class="legend-dot" style="background-color: var(--nucleus-color);"></span>Core Model (Nucleus)</div>
            <div style="color: var(--loop-color);"><span class="legend-dot" style="background-color: var(--loop-color);"></span>Loop Model (Electron 1)</div>
            <div style="color: var(--coin-color);"><span class="legend-dot" style="background-color: var(--coin-color);"></span>Coin Model (Electron 2)</div>
            <div style="color: var(--code-color);"><span class="legend-dot" style="background-color: var(--code-color);"></span>Code Model (Ion)</div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let nucleus, loop, coin, ion;
        const orbitData = [
            { name: 'loop', radius: 4, speed: 0.8, color: 0x03DAC6, particle: null },
            { name: 'coin', radius: 6, speed: 0.6, color: 0xBB86FC, particle: null },
            { name: 'code', radius: 8, speed: 0.4, color: 0xCF6679, particle: null }
        ];

        function init() {
            // 1. Setup Scene, Camera, Renderer
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x0d1117, 1); // Dark background
            document.body.appendChild(renderer.domElement);

            camera.position.z = 12;

            // 2. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            // 3. Atom/Particle Creation (Core Model - Nucleus)
            const nucleusGeometry = new THREE.SphereGeometry(1.5, 32, 32);
            const nucleusMaterial = new THREE.MeshPhongMaterial({ color: 0xff9800, emissive: 0xffa040, emissiveIntensity: 0.5 });
            nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
            scene.add(nucleus);

            // 4. Orbit and Particle Creation (Electrons + Ion)
            orbitData.forEach(data => {
                // Visual Orbit Ring
                const orbitGeometry = new THREE.RingGeometry(data.radius - 0.05, data.radius + 0.05, 128);
                const orbitMaterial = new THREE.MeshBasicMaterial({ 
                    color: data.color, 
                    side: THREE.DoubleSide, 
                    transparent: true, 
                    opacity: 0.2 
                });
                const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
                orbit.rotation.x = Math.PI / 2; // Lay flat on XZ plane
                scene.add(orbit);

                // Particle (Electron/Ion)
                const particleGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                const particleMaterial = new THREE.MeshPhongMaterial({ color: data.color, emissive: data.color, emissiveIntensity: 0.8 });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                scene.add(particle);
                data.particle = particle;

                // Set initial position (exact orbit)
                particle.position.x = data.radius;
            });
            
            // 5. OrbitControls for interaction
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // smooth rotation
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 50;

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;
            
            // Animate Core (Spinning)
            nucleus.rotation.y = time * 0.1;

            // Animate Orbiting Particles
            orbitData.forEach(data => {
                const particle = data.particle;
                const radius = data.radius;
                const speed = data.speed;

                // The particle follows a perfect circle (exact orbit) on the XZ plane
                particle.position.x = radius * Math.cos(time * speed);
                particle.position.z = radius * Math.sin(time * speed);
            });

            controls.update();
            renderer.render(scene, camera);
        }

        // Mandatory onload event to start the animation
        window.onload = function () {
            init();
            animate();
        };
    </script>
</body>
</html>

