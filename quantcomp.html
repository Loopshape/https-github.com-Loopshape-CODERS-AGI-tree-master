<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>QUANTUM HYPER-THREADED 5-AGENT SYSTEM | Fractal Reasoning Boost</title>
<!-- Load necessary external libraries -->
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>

<style>
/* Enhanced Base Styles with Quantum Visual Effects */

html {
    position: relative;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    font-size: 100.01%;
    display: inline-block;
}

body{margin:0;background:#0a0a0a;color:#eee;font-family:'Inter',Roboto,sans-serif;height:100vh;overflow:hidden;
}
#three-canvas{position:fixed;top:0;left:0;z-index:10;width:100%;height:100%;}
#ui-container{
    position:absolute;top:0;left:0;width:100%;height:100%;z-index:20;
    padding:16px;display:grid;
    grid-template-columns:repeat(12, 1fr); 
    grid-template-rows: auto 1fr auto; 
    gap: 16px;
    pointer-events:none;
    zoom: 0.5;

}

/* Enhanced Material Card Styling with Quantum Effects */
.agent-card{
    background:rgba(31,31,31,0.9);
    border-radius:16px;
    padding:16px;
    color:#eee;
    box-shadow:0 4px 6px -1px rgba(0,0,0,0.4), 0 10px 15px -3px rgba(0,0,0,0.4);
    pointer-events:auto;
    transition: all 0.4s ease;
    border: 1px solid transparent;
    backdrop-filter: blur(10px);
}
.agent-card.quantum-active {
    border: 1px solid #BB86FC;
    box-shadow: 0 0 30px rgba(187,134,252,0.6), 0 4px 20px rgba(0,0,0,0.8);
    background: rgba(31,31,31,0.95);
}

/* Enhanced Grid Layout */
#agent-nexus { 
    grid-column: 5 / 9; 
    grid-row: 1 / 2; 
    height: fit-content;
} 
#agent-echo { 
    grid-column: 1 / 13; 
    grid-row: 2 / 3; 
    max-height: 100%; 
    overflow-y: auto; 
    z-index: 20;
}
#agent-cognito { 
    grid-column: 1 / 5; 
    grid-row: 3 / 4; 
    height: fit-content;
} 
#agent-relay { 
    grid-column: 5 / 9; 
    grid-row: 3 / 4; 
    height: fit-content;
} 
#agent-sentinel { 
    grid-column: 9 / 13; 
    grid-row: 3 / 4; 
    height: fit-content;
}

/* Enhanced Typography & Quantum Colors */
.agent-title{color:#BB86FC;font-weight:700;font-size:1.4em;display:flex;align-items:center;gap:8px;}
.agent-subtitle{color:#03DAC6;font-weight:300;font-size:0.8em;margin-bottom:8px;}
.agent-content{
    margin-top:12px;
    font-size:0.9em;
    color:rgba(255,255,255,0.7);
    max-height: 100px;
    overflow-y: auto;
}
.quantum-boost-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #03DAC6;
    box-shadow: 0 0 10px #03DAC6;
    animation: pulse 2s infinite;
}
@keyframes pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.5; transform: scale(1.2); }
}

/* Enhanced Input Prompt */
#prompt-container{
    position:fixed;top:45%;left:50%;transform:translate(-50%,-50%);
    display:flex;gap:12px;z-index:25;
    width: min(90vw, 600px);
    background: rgba(31,31,31,0.95);
    border-radius: 12px;
    padding: 16px;
    box-shadow: 0 10px 30px rgba(187,134,252,0.3);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(187,134,252,0.3);
}
#prompt-input{
    flex-grow:1;
    background:transparent;
    border:none;
    border-bottom:2px solid rgba(187,134,252,0.5);
    color:#eee;
    font-size:1em;
    padding:8px;
    outline:none;
    transition: border-color 0.3s ease;
}
#prompt-input:focus{border-bottom-color:#BB86FC;}
#prompt-submit{
    width:48px;height:48px;
    border-radius:50%;
    background:linear-gradient(135deg, #03DAC6, #BB86FC);
    color: #121212;
    border:none;
    cursor:pointer;
    display:flex;align-items:center;justify-content:center;
    box-shadow: 0 4px 15px rgba(3,218,198,0.6);
    transition: all 0.3s ease;
}
#prompt-submit:active{transform:scale(0.95);}
#prompt-submit:hover{box-shadow: 0 6px 20px rgba(187,134,252,0.8);}

/* Enhanced Data Packet Animation */
.data-packet{
    position:fixed;width:8px;height:8px;border-radius:50%;
    background:linear-gradient(135deg, #BB86FC, #03DAC6);
    box-shadow:0 0 15px #BB86FC;
    opacity:0;
    z-index:30;
}
.quantum-particle {
    position: fixed;
    width: 4px;
    height: 4px;
    border-radius: 50%;
    background: #03DAC6;
    pointer-events: none;
    z-index: 15;
}
.spinner{border:4px solid rgba(255,255,255,0.1);border-left-color:#03DAC6;border-radius:50%;width:16px;height:16px;animation:spin 1s linear infinite;}
@keyframes spin{to{transform:rotate(360deg);}}

/* Quantum Fractal Visualization */
.fractal-progress {
    height: 4px;
    background: linear-gradient(90deg, #03DAC6, #BB86FC);
    border-radius: 2px;
    margin-top: 8px;
    transition: width 0.5s ease;
}

/* Enhanced Code Styling */
pre[class*="language-"] {
    margin: 0; padding: 10px; border-radius: 6px;
    background: rgba(18,18,18,0.9);
    font-size: 0.8em;
    white-space: pre-wrap;
    word-break: break-all;
    border: 1px solid rgba(187,134,252,0.3);
    backdrop-filter: blur(5px);
}
.token.string { color: #81C784; }
.token.keyword { color: #BB86FC; }
.token.comment { color: #666666; }

/* Hyper-threaded Verbose Output */
.verbose-thinking {
    background: rgba(30,30,40,0.8);
    border-left: 3px solid #BB86FC;
    padding: 8px 12px;
    margin: 4px 0;
    border-radius: 4px;
    font-family: 'Courier New', monospace;
    font-size: 0.8em;
    max-height: 200px;
    overflow-y: auto;
}
</style>
</head>
<body>

<canvas id="three-canvas"></canvas>
<div id="prompt-container">
<input type="text" id="prompt-input" placeholder="Enter quantum-enhanced command..." autofocus>
<button id="prompt-submit">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M3 3l18 9-18 9V3z"/></svg>
</button>
</div>

<div id="ui-container">
<div id="agent-nexus" class="agent-card"><div class="agent-title">Nexus <div class="quantum-boost-indicator"></div></div><div class="agent-subtitle">Quantum Orchestrator (Core)</div><div class="agent-content">Quantum state: Superposition ready.</div><div class="fractal-progress" style="width:0%"></div></div>
<div id="agent-cognito" class="agent-card"><div class="agent-title">Cognito <div class="quantum-boost-indicator"></div></div><div class="agent-subtitle">Fractal Analyzer (Loop)</div><div class="agent-content">Fractal depth: Calibrating...</div><div class="fractal-progress" style="width:0%"></div></div>
<div id="agent-relay" class="agent-card"><div class="agent-title">Relay <div class="quantum-boost-indicator"></div></div><div class="agent-subtitle">Hyper-Communicator (2244)</div><div class="agent-content">Entanglement: Establishing...</div><div class="fractal-progress" style="width:0%"></div></div>
<div id="agent-sentinel" class="agent-card"><div class="agent-title">Sentinel <div class="quantum-boost-indicator"></div></div><div class="agent-subtitle">Quantum Monitor (Coin)</div><div class="agent-content">Superstate: Monitoring...</div><div class="fractal-progress" style="width:0%"></div></div>
<div id="agent-echo" class="agent-card"><div class="agent-title">Echo <div class="quantum-boost-indicator"></div></div><div class="agent-subtitle">Meta-Reporter (Code)</div><div class="agent-content">Awaiting quantum final report...</div><div class="fractal-progress" style="width:0%"></div></div>
</div>

<!-- QUANTUM FRACTAL ACCELERATOR IMPLEMENTATION -->
<script>
/**
 * @class QuantumFractalAccelerator
 * Enhanced with hyper-threading and multi-agent integration
 */
class QuantumFractalAccelerator {
    static _quantumStates = new Map();
    static _fractalCache = new Map();
    static _entanglementMatrix = new Map();

    static _quantumEnhancementFactor(agentId = 'default') {
        const baseFactor = (Math.random() * 9 + 1) / 100;
        const entangledBoost = this._getEntanglementBoost(agentId);
        return Math.min(0.15, baseFactor * (1 + entangledBoost));
    }

    static _fractalReasoning(depth, maxDepth, complexity = 1) {
        const cacheKey = `${depth}-${maxDepth}-${complexity}`;
        if (this._fractalCache.has(cacheKey)) {
            return this._fractalCache.get(cacheKey);
        }

        if (depth >= maxDepth) {
            return 1 + (complexity * 0.02);
        }

        const recursiveGain = this._fractalReasoning(depth + 1, maxDepth, complexity);
        const currentGain = (1 + (0.07 / depth)) * recursiveGain * complexity;

        this._fractalCache.set(cacheKey, currentGain);
        return currentGain;
    }

    static _getEntanglementBoost(agentId) {
        let totalBoost = 0;
        let connectionCount = 0;

        this._entanglementMatrix.forEach((strength, connectedAgent) => {
            if (connectedAgent !== agentId) {
                totalBoost += strength;
                connectionCount++;
            }
        });

        return connectionCount > 0 ? totalBoost / connectionCount : 0;
    }

    static _updateEntanglement(fromAgent, toAgent, strength = 0.1) {
        const key = `${fromAgent}-${toAgent}`;
        this._entanglementMatrix.set(key, strength);
    }

    static accelerateMultiAgent(agents, targetReasoningDepth = 7) {
        console.log(`🚀 QUANTUM HYPER-THREADING ACTIVATED | Depth: ${targetReasoningDepth}`);
        
        const results = new Map();
        let totalBoost = 0;

        // Create entanglement between all agents
        agents.forEach((fromAgent, fromId) => {
            agents.forEach((toAgent, toId) => {
                if (fromId !== toId) {
                    this._updateEntanglement(fromId, toId, 0.15);
                }
            });
        });

        // Apply quantum fractal acceleration to each agent
        agents.forEach((agent, agentId) => {
            const quantumBoost = agent.progress * this._quantumEnhancementFactor(agentId);
            const fractalFactor = this._fractalReasoning(1, targetReasoningDepth, agent.complexity || 1);
            const entangledBoost = this._getEntanglementBoost(agentId);
            
            const enhancedProgress = agent.progress + quantumBoost * fractalFactor * (1 + entangledBoost);
            const finalProgress = Math.min(100, enhancedProgress);

            results.set(agentId, {
                progress: finalProgress,
                quantumBoost,
                fractalFactor,
                entangledBoost,
                enhancement: finalProgress - agent.progress
            });

            totalBoost += finalProgress - agent.progress;
        });

        console.log(`⚡ QUANTUM BOOST SUMMARY: +${totalBoost.toFixed(2)}% across ${agents.size} agents`);
        return results;
    }

    static accelerateProgress(currentProgress, targetReasoningDepth = 5, complexity = 1) {
        const quantumBoost = currentProgress * this._quantumEnhancementFactor();
        const fractalFactor = this._fractalReasoning(1, Math.max(1, targetReasoningDepth), complexity);
        const enhancedProgress = currentProgress + quantumBoost * fractalFactor;
        return Math.min(100, enhancedProgress);
    }
}
</script>

<!-- ENVIRONMENT VARIABLE INJECTION -->
<script>
    (function() {
        window.__API_KEY_INJECTION__ = window.__API_KEY_INJECTION__ || null; 
        window.__app_id = window.__app_id || 'quantum-simulation-app-v2';
        window.__firebase_config = window.__firebase_config || JSON.stringify({
            apiKey: null,
            authDomain: null,
            projectId: null,
            storageBucket: null,
            messagingSenderId: null,
            appId: null
        });
        window.__initial_auth_token = window.__initial_auth_token || null;
        window.__FEATURE_FLAGS__ = window.__FEATURE_FLAGS__ || {
            enableQuantumAcceleration: true,
            enableHyperThreading: true,
            enableFractalReasoning: true,
            enableDebugMode: false
        };

        console.log("[QUANTUM ENV INJECTION] Enhanced globals initialized");
    })();
</script>

<script type="module">
// --- Enhanced Firebase & Auth Setup ---
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, doc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

window.firebaseApp = null;
window.db = null;
window.auth = null;
window.userId = 'unauthenticated-user';

const appId = typeof window.__app_id !== 'undefined' ? window.__app_id : 'default-app-id';
const firebaseConfig = typeof window.__firebase_config !== 'undefined' ? JSON.parse(window.__firebase_config) : null;
const initialAuthToken = typeof window.__initial_auth_token !== 'undefined' ? window.__initial_auth_token : null;

if (firebaseConfig && Object.keys(firebaseConfig).some(key => firebaseConfig[key] !== null)) {
    setLogLevel('Debug');
    window.firebaseApp = initializeApp(firebaseConfig);
    window.db = getFirestore(window.firebaseApp);
    window.auth = getAuth(window.firebaseApp);

    onAuthStateChanged(window.auth, async (user) => {
        if (user) window.userId = user.uid;
        else if (!user && initialAuthToken) {
            try { await signInWithCustomToken(window.auth, initialAuthToken); window.userId = window.auth.currentUser.uid; }
            catch { await signInAnonymously(window.auth); window.userId = window.auth.currentUser.uid; }
        } else { await signInAnonymously(window.auth); window.userId = window.auth.currentUser.uid; }
        console.log("Quantum Firebase Auth Ready. User ID:", window.userId);
    });
} else {
    console.log("Firebase not configured. Running in quantum unauthenticated mode.");
}

// --- Enhanced Core Application Logic ---
const injectedApiKey = typeof window.__API_KEY_INJECTION__ !== 'undefined' && window.__API_KEY_INJECTION__ !== null 
    ? window.__API_KEY_INJECTION__ 
    : "AIzaSyBtto2pvY2bTO26XwuV1hAB9RbSqYo3Fnw";
    
const apiKey = injectedApiKey; 
const modelName = "gemini-2.5-flash-preview-09-2025";
const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;

const crew = {
    nexus: { 
        model:'core', 
        el: document.getElementById('agent-nexus'), 
        content: document.querySelector('#agent-nexus .agent-content'),
        progress: 0,
        complexity: 1.2
    },
    cognito: { 
        model:'loop', 
        el: document.getElementById('agent-cognito'), 
        content: document.querySelector('#agent-cognito .agent-content'),
        progress: 0,
        complexity: 1.4
    },
    relay: { 
        model:'2244', 
        el: document.getElementById('agent-relay'), 
        content: document.querySelector('#agent-relay .agent-content'),
        progress: 0,
        complexity: 1.1
    },
    sentinel: { 
        model:'coin', 
        el: document.getElementById('agent-sentinel'), 
        content: document.querySelector('#agent-sentinel .agent-content'),
        progress: 0,
        complexity: 1.3
    },
    echo: { 
        model:'code', 
        el: document.getElementById('agent-echo'), 
        content: document.querySelector('#agent-echo .agent-content'),
        progress: 0,
        complexity: 1.5
    }
};

let isGenerating = false;
let isSpeaking = false;
let currentThinkingDepth = 7;

// --- Enhanced Quantum Visualization ---
function createQuantumParticles(sourceElement, count = 15) {
    const rect = sourceElement.getBoundingClientRect();
    for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = 'quantum-particle';
        particle.style.left = (rect.left + rect.width / 2) + 'px';
        particle.style.top = (rect.top + rect.height / 2) + 'px';
        document.body.appendChild(particle);

        const angle = Math.random() * Math.PI * 2;
        const distance = 50 + Math.random() * 100;
        const duration = 0.8 + Math.random() * 0.7;

        gsap.to(particle, {
            x: Math.cos(angle) * distance,
            y: Math.sin(angle) * distance,
            opacity: 0,
            scale: 0,
            duration: duration,
            ease: "power2.out",
            onComplete: () => particle.remove()
        });
    }
}

function updateFractalProgress(agentId, progress) {
    const progressBar = crew[agentId].el.querySelector('.fractal-progress');
    if (progressBar) {
        progressBar.style.width = `${progress}%`;
    }
}

// --- Enhanced LLM Interaction with Quantum Boost ---
function isHumanPrompt(text){
    return /\?$|^who|^what|^how|^when|^where|^why|^wer|^was|^wie|^wann|^wo|^warum/i.test(text.trim());
}

async function echoAnswer(promptText, answer){
    const isQuestion = isHumanPrompt(promptText);
    crew.echo.el.classList.add('quantum-active');
    
    // Apply quantum acceleration to the display process
    const displayProgress = QuantumFractalAccelerator.accelerateProgress(0, 3, 1.2);
    updateFractalProgress('echo', displayProgress);

    crew.echo.content.innerHTML = `<div class="verbose-thinking">🚀 QUANTUM PROCESSING: Applying fractal reasoning depth ${currentThinkingDepth}</div>`;

    if(isQuestion){
        crew.echo.content.innerHTML += `<div class="verbose-thinking">🎯 QUESTION ANALYSIS: Human query detected</div>`;
        await generateTTSAndPlay(answer);
    } else {
        crew.echo.content.innerHTML += `<div class="verbose-thinking">⚡ COMMAND EXECUTION: Code generation initiated</div>`;
        try {
            const codeMatch = answer.match(/```(?:javascript|js)\n([\s\S]*?)\n```/i);
            const content = codeMatch ? codeMatch[1].trim() : answer.trim();
            const highlightedCode = Prism.highlight(content, Prism.languages.javascript, 'javascript');
            
            crew.echo.content.innerHTML += `<div class="verbose-thinking">✅ CODE OPTIMIZATION: Quantum fractal acceleration applied</div>`;
            crew.echo.content.innerHTML += `<pre class="language-javascript"><code class="language-javascript">${highlightedCode}</code></pre>`;
        } catch(e) {
            crew.echo.content.innerHTML += `<div class="verbose-thinking">❌ ERROR: ${e.message}</div>`;
        }
    }

    updateFractalProgress('echo', 100);
    setTimeout(() => crew.echo.el.classList.remove('quantum-active'), 1000);
}

// --- HYPER-THREADED QUANTUM AGENT WORKFLOW ---
async function startQuantumCrewSimulation(promptText) {
    if (isGenerating || isSpeaking) return;
    if (apiKey === "YOUR_GEMINI_API_KEY_HERE" || apiKey === null) {
         alert("Quantum acceleration requires valid API key configuration.");
         return;
    }
    
    isGenerating = true;
    const submitBtn = document.getElementById('prompt-submit');
    submitBtn.disabled = true;

    // Initialize quantum state for all agents
    Object.values(crew).forEach(agent => {
        agent.progress = 0;
        updateFractalProgress(Object.keys(crew).find(key => crew[key] === agent), 0);
        agent.content.innerHTML = `<div class="flex items-center space-x-2"><div class="spinner"></div><span>Quantum initialization...</span></div>`;
        agent.el.classList.remove('quantum-active');
    });

    crew.echo.content.innerHTML = `<div class="verbose-thinking">🌌 QUANTUM FRACTAL ACCELERATOR: Initializing hyper-threaded reasoning...</div>`;

    const quantumStep = async (agentKey, statusMessage, duration = 800, reasoningDepth = 5) => {
        const agent = crew[agentKey];
        agent.el.classList.add('quantum-active');
        createQuantumParticles(agent.el);
        
        // Apply quantum acceleration to this step
        const stepProgress = QuantumFractalAccelerator.accelerateProgress(agent.progress, reasoningDepth, agent.complexity);
        agent.progress = stepProgress;
        updateFractalProgress(agentKey, stepProgress);

        const boostedDuration = duration / (1 + (reasoningDepth * 0.1)); // Faster with higher reasoning
        agent.content.innerHTML = `<div class="flex items-center space-x-2"><div class="spinner"></div><span>${statusMessage} [Q-Boost: ${reasoningDepth}x]</span></div>`;
        
        await new Promise(r => setTimeout(r, boostedDuration));
        agent.el.classList.remove('quantum-active');
    };

    try {
        // PHASE 1: QUANTUM INITIALIZATION
        const inputRect = document.getElementById('prompt-container').getBoundingClientRect();
        const nexusRect = crew.nexus.el.getBoundingClientRect();
        
        animateDataPacket(inputRect, nexusRect, async () => {
            await quantumStep('nexus', `Quantum command received. Entangling agents...`, 600, 7);

            // PHASE 2: HYPER-THREADED MULTI-AGENT PROCESSING
            const cognitoRect = crew.cognito.el.getBoundingClientRect();
            animateDataPacket(nexusRect, cognitoRect, async () => {
                await quantumStep('cognito', `Executing fractal reasoning...`, 1200, 8);

                const systemPrompt = isHumanPrompt(promptText)
                    ? "You are a quantum-enhanced AI system. Provide deeply analytical, fractal-reasoned answers with multi-dimensional insights."
                    : "You are a quantum coding agent. Provide optimized, commented JavaScript code with quantum-inspired algorithms and fractal optimization patterns.";

                const payload = {
                    contents: [{ parts: [{ text: promptText }] }],
                    tools: [{ "google_search": {} }],
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    generationConfig: {
                        temperature: 0.7,
                        topK: 40,
                        topP: 0.95
                    }
                };

                let responseData = null, retryCount = 0, maxRetries = 3;
                while (retryCount < maxRetries) {
                    try {
                        const response = await fetch(apiUrl, { 
                            method: 'POST', 
                            headers: { 'Content-Type': 'application/json' }, 
                            body: JSON.stringify(payload) 
                        });
                        if (!response.ok) {
                            if (response.status === 429 && retryCount < maxRetries - 1) {
                                const backoff = (Math.pow(2, retryCount) * 1000 + Math.random() * 1000);
                                await new Promise(r => setTimeout(r, backoff)); 
                                retryCount++; 
                                continue;
                            } else { 
                                throw new Error(`Quantum API error: ${response.status}`); 
                            }
                        }
                        responseData = await response.json();
                        break;
                    } catch (e) { 
                        throw new Error(`Quantum Processing Failure: ${e.message}`); 
                    }
                }

                // PHASE 3: QUANTUM VALIDATION & ENTANGLEMENT
                const cognitoRectUpdated = crew.cognito.el.getBoundingClientRect();
                const echoRect = crew.echo.el.getBoundingClientRect();
                
                animateDataPacket(cognitoRectUpdated, echoRect, async () => {
                    // Apply multi-agent quantum acceleration
                    const quantumResults = QuantumFractalAccelerator.accelerateMultiAgent(
                        new Map([
                            ['relay', {progress: 60, complexity: 1.1}],
                            ['sentinel', {progress: 70, complexity: 1.3}],
                            ['echo', {progress: 80, complexity: 1.5}]
                        ]), 
                        currentThinkingDepth
                    );

                    await quantumStep('relay', `Hyper-threaded transmission...`, 800, 6);
                    await quantumStep('sentinel', `Quantum validation...`, 900, 7);

                    // PHASE 4: META-CODED FINAL OUTPUT
                    await quantumStep('echo', `Generating superstate report...`, 600, 9);

                    const generatedText = responseData?.candidates?.[0]?.content?.parts?.[0]?.text || "Quantum void: No response detected.";
                    
                    crew.echo.content.innerHTML = `<div class="verbose-thinking">✅ QUANTUM PROCESSING COMPLETE: All agents entangled and boosted</div>`;
                    await echoAnswer(promptText, generatedText);

                    // Final quantum state
                    quantumStep('nexus', `Quantum equilibrium achieved`, 400, 5);
                    quantumStep('cognito', `Fractal reasoning stored`, 300, 4);
                    quantumStep('relay', `Entanglement maintained`, 300, 4);
                    quantumStep('sentinel', `Superstate monitoring`, 300, 4);

                    // Enhanced persistence
                    if (window.db && window.userId !== 'unauthenticated-user') {
                        const docRef = doc(window.db, `quantum_artifacts/${appId}/users/${window.userId}/agent_reports`, `quantum_report_${Date.now()}`);
                        await setDoc(docRef, { 
                            prompt: promptText, 
                            response: generatedText.substring(0, 150) + '...', 
                            quantum_depth: currentThinkingDepth,
                            timestamp: new Date().toISOString(),
                            enhancement: "fractal_quantum_v2"
                        });
                    }
                    
                    isGenerating = false;
                    submitBtn.disabled = false;
                    currentThinkingDepth = Math.min(10, currentThinkingDepth + 0.5); // Progressive depth increase
                });
            });
        });

    } catch (e) {
        console.error("Quantum simulation failed:", e);
        Object.values(crew).forEach(a => {
            a.el.style.boxShadow = '0 0 30px #ff0000';
            a.content.innerHTML = `<p class="text-red-400 font-bold">QUANTUM COLLAPSE: ${e.message}</p>`;
        });
        isGenerating = false;
        submitBtn.disabled = false;
    }
}

// --- Enhanced GSAP Data Packet Animation ---
function animateDataPacket(sourceRect, targetRect, onComplete) {
    const packet = document.createElement('div');
    packet.className = 'data-packet';
    document.body.appendChild(packet);

    const startX = sourceRect.left + sourceRect.width / 2;
    const startY = sourceRect.top + sourceRect.height / 2;
    const endX = targetRect.left + targetRect.width / 2;
    const endY = targetRect.top + targetRect.height / 2;

    gsap.set(packet, { x: startX, y: startY, opacity: 1, scale: 0.3 });

    gsap.to(packet, {
        x: endX,
        y: endY,
        scale: 1.8,
        opacity: 0.9,
        duration: 0.6,
        ease: "power2.inOut",
        onComplete: () => {
            packet.remove();
            createQuantumParticles({getBoundingClientRect: () => targetRect}, 8);
            onComplete && onComplete();
        }
    });
}

// --- Enhanced Three.js Quantum Plasma Background ---
let scene, camera, renderer, uniforms, mesh;
let width = window.innerWidth, height = window.innerHeight;

const vertexShader = `void main(){gl_Position=vec4(position,1.0);}`;
const fragmentShader = `
uniform float time;
uniform vec2 resolution;
const float PI = 3.14159265359;

float fractalNoise(vec2 p) {
    return sin(p.x*12.0+time)*cos(p.y*8.0+time/1.5)+sin((p.x+p.y)*15.0+time/2.0)*0.5;
}

float quantumField(vec2 uv) {
    float f = 0.0;
    vec2 q = vec2(fractalNoise(uv), fractalNoise(uv+vec2(5.2,1.3)));
    vec2 r = vec2(fractalNoise(uv+4.0*q+vec2(1.7,9.2)), fractalNoise(uv+4.0*q+vec2(8.3,2.8)));
    f = fractalNoise(uv+4.0*r);
    return f;
}

void main(){
    vec2 uv = (gl_FragCoord.xy-0.5*resolution.xy)/resolution.y;
    uv *= 2.0;
    
    float q = quantumField(uv);
    float q2 = quantumField(uv*1.5+0.5);
    float q3 = quantumField(uv*2.0-0.3);
    
    vec3 color = 0.5 + 0.5*cos(PI*(q*0.5+vec3(0.0,0.6,0.9)+q2*0.3));
    color *= vec3(0.1,0.15,0.3) + q3*0.2;
    color += vec3(0.4,0.2,0.6) * abs(q) * 0.3;
    
    gl_FragColor = vec4(color,1.0);
}`;

function initThree() {
    scene = new THREE.Scene();
    camera = new THREE.Camera();
    camera.position.z = 1;
    renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('three-canvas'),
        alpha: true,
        antialias: true 
    });
    renderer.setSize(width, height);

    uniforms = { 
        time: { type: 'f', value: 1.0 }, 
        resolution: { type: 'v2', value: new THREE.Vector2(width, height) } 
    };
    
    const material = new THREE.ShaderMaterial({ 
        uniforms: uniforms, 
        vertexShader: vertexShader, 
        fragmentShader: fragmentShader 
    });
    
    const geometry = new THREE.PlaneGeometry(2, 2);
    mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    window.addEventListener('resize', onWindowResize);
    onWindowResize();
    animateThree();
}

function onWindowResize() {
    width = window.innerWidth; 
    height = window.innerHeight;
    renderer.setSize(width, height);
    uniforms.resolution.value.x = width;
    uniforms.resolution.value.y = height;
}

function animateThree() {
    requestAnimationFrame(animateThree);
    uniforms.time.value += 0.02; // Slower, more quantum-like
    renderer.render(scene, camera);
}

// --- Audio TTS Utility Functions (Keep existing) ---
function base64ToArrayBuffer(base64) {
    const binaryString = atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
}

function pcmToWav(pcm16, sampleRate = 24000) {
    const numChannels = 1;
    const bitsPerSample = 16;
    const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
    const blockAlign = numChannels * (bitsPerSample / 8);
    const dataSize = pcm16.byteLength;
    const buffer = new ArrayBuffer(44 + dataSize);
    const view = new DataView(buffer);

    function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }
    writeString(view, 0, 'RIFF'); view.setUint32(4, 36 + dataSize, true); writeString(view, 8, 'WAVE');
    writeString(view, 12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true);
    view.setUint16(22, numChannels, true); view.setUint32(24, sampleRate, true);
    view.setUint32(28, byteRate, true); view.setUint16(32, blockAlign, true); view.setUint16(34, bitsPerSample, true);
    writeString(view, 36, 'data'); view.setUint32(40, dataSize, true);

    let offset = 44;
    for (let i = 0; i < pcm16.length; i++) { view.setInt16(offset, pcm16[i], true); offset += 2; }
    return new Blob([buffer], { type: 'audio/wav' });
}

function playAudioBuffer(wavBlob) {
    if (isSpeaking) return;
    const audioUrl = URL.createObjectURL(wavBlob);
    const audio = new Audio(audioUrl);

    audio.onplay = () => { 
        isSpeaking = true; 
        crew.echo.el.classList.add('quantum-active');
        createQuantumParticles(crew.echo.el, 20);
    };
    audio.onended = () => {
        isSpeaking = false;
        crew.echo.el.classList.remove('quantum-active');
        URL.revokeObjectURL(audioUrl);
    };
    audio.play();
}

async function generateTTSAndPlay(textToSpeak) {
    if (isSpeaking) return;
    crew.echo.content.innerHTML = `<div class="flex items-center space-x-2"><div class="spinner"></div><span>Quantum speech synthesis...</span></div>`;

    const ttsModelUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
    const payload = {
        contents: [{ parts: [{ text: textToSpeak }] }],
        generationConfig: { responseModalities: ["AUDIO"], speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Kore" } } } },
    };

    let responseData = null, retryCount = 0, maxRetries = 3;
    while (retryCount < maxRetries) {
        try {
            const response = await fetch(ttsModelUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                if (response.status === 429 && retryCount < maxRetries - 1) { 
                    await new Promise(r => setTimeout(r, (Math.pow(2, retryCount) * 1000 + Math.random() * 1000))); 
                    retryCount++; 
                    continue; 
                } else { 
                    throw new Error(`Quantum TTS API error: ${response.status}`); 
                }
            }
            responseData = await response.json();
            break;
        } catch (e) {
            console.error("Quantum TTS generation failed:", e);
            crew.echo.content.innerHTML = `<span class="text-red-500">Quantum TTS Error: Temporal anomaly detected.</span>`;
            return;
        }
    }

    const part = responseData?.candidates?.[0]?.content?.parts?.[0];
    const audioData = part?.inlineData?.data;
    const mimeType = part?.inlineData?.mimeType;

    if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
        const rateMatch = mimeType.match(/rate=(\d+)/);
        const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000;
        const pcmDataBuffer = base64ToArrayBuffer(audioData);
        const pcm16 = new Int16Array(pcmDataBuffer);
        const wavBlob = pcmToWav(pcm16, sampleRate);
        crew.echo.content.innerHTML = `<p class="text-green-400">Quantum vocalization active...</p>`;
        playAudioBuffer(wavBlob);
    } else {
        console.error("No quantum audio data returned from TTS API.");
        crew.echo.content.innerHTML = `<span class="text-red-500">Quantum TTS Error: Waveform collapse.</span>`;
    }
}

// --- Enhanced Event Listeners and Initialization ---
window.addEventListener('load', () => {
    initThree();
    const promptInput = document.getElementById('prompt-input');
    const promptSubmit = document.getElementById('prompt-submit');

    // Quantum initialization state
    crew.cognito.content.innerHTML = 'Quantum ready. Fractal depth calibrated.';
    crew.relay.content.innerHTML = 'Hyper-threaded. Entanglement established.';
    crew.sentinel.content.innerHTML = 'Superstate monitoring active.';
    crew.echo.content.innerHTML = 'Quantum reporting system online. Enter a command or question to begin hyper-threaded processing.';

    const handleSubmit = () => {
        const promptText = promptInput.value.trim();
        if (promptText && !isGenerating && !isSpeaking) {
            startQuantumCrewSimulation(promptText);
            promptInput.value = '';
        }
    };

    promptSubmit.addEventListener('click', handleSubmit);
    promptInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            handleSubmit();
        }
    });

    console.log("🚀 QUANTUM HYPER-THREADED 5-AGENT SYSTEM INITIALIZED");
    console.log("🌌 Fractal Reasoning Depth:", currentThinkingDepth);
    console.log("⚡ Quantum Acceleration: ACTIVE");
});
</script>
</body>
</html>
